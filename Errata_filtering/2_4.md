# Expert-Issues Summary (Excluding Router) — Appendix A (Examples)

RFC: Unknown  
Section: Appendix A (example SSLKEYLOGFILE content for TLS 1.2, TLS 1.3, TLS 1.3+ECH)

This summarizes **all potential bugs raised by the experts** (not the router), deduplicated.

---

## 1) Example ambiguity: “single-line” format vs RFC 8792 backslash-folded examples

**Concise explanation:**  
Section 2 normatively defines each secret record as **one physical line** with three space-separated fields. Appendix A says it shows “a sample of a file in this format,” but presents records folded across multiple lines using RFC 8792 trailing backslashes (`\`), which—if copied literally—does not match the normative grammar.

**Justification:** ⚠️ Mostly an editorial/clarity issue (risk of misimplementation)  
- **Scope** and **CrossRFC** argue this is a real ambiguity because the draft relies on RFC 8792 “unfolding” behavior without explicitly stating that the backslashes/newlines are *not* part of real files. A reader unfamiliar with RFC 8792 could mistakenly treat `\` as a continuation marker in the actual format.
- **Causal** agrees the “sample file” is not valid if pasted verbatim, but says the *normative* format is still coherent; the problem is documentation confusion, not a protocol break.
- **Structural** treats it as **not a bug** because the examples are explicitly annotated “# NOTE: '\' line wrapping per RFC 8792,” and unfolding restores single logical lines consistent with Section 2.

**Net:** This is best filed as an **example/presentation clarification**: add one explicit sentence that the examples are RFC-folded for display only and must be unfolded to obtain the literal on-disk SSLKEYLOGFILE content (and real files MUST NOT include the backslashes).

**Experts mentioning this issue:**  
- Scope (BugType: Both)  
- Causal (documentation tension, not fundamental bug)  
- CrossRFC (BugType: Both)  
- Structural (explicitly says *no issue* if unfolded per RFC 8792)

---

## 2) Cross-RFC mismatch: TLS 1.3 exporter secret names (“exporter_secret” vs “exporter_master_secret”)

**Concise explanation:**  
The draft text maps `EXPORTER_SECRET` to a TLS key schedule secret named `exporter_secret` (and similarly implies an “early exporter secret” name), but RFC 8446’s TLS 1.3 key schedule names are **exporter_master_secret** and **early_exporter_master_secret**. There is no key-schedule secret literally named `exporter_secret` / `early_exporter_secret`.

**Justification:** ✅ Real cross-RFC naming inconsistency  
CrossRFC flags this as a high-confidence mismatch: implementers might look for non-existent secret identifiers in RFC 8446 or misinterpret what should be logged. Even if most readers infer the intent (“exporter master secret”), the spec’s stated mapping is incorrect relative to RFC 8446 terminology.

**Experts mentioning this issue:**  
- CrossRFC (Confidence: High)

---

# Recap
**Expert-raised issues (deduplicated):**
1. **RFC 8792 folding in Appendix A** can be misread as literal syntax unless explicitly clarified (editorial/clarity risk).
2. **Wrong TLS 1.3 exporter secret naming** vs RFC 8446 (real cross-RFC inconsistency).

---
