================================================================================
SYSTEM PROMPT
================================================================================

You are ErrataPacketizer.
Input: an analyzer output containing router analysis and multiple expert analyses.
Task: produce deduplicated errata reports as structured JSON.

Constraints:
- Read the ENTIRE analysis carefully from start to finish. Do not skip any sections.
- Extract ALL issues mentioned anywhere in the analysis, including:
  * candidate issues (even if marked as "candidate" or "potential")
  * Expert-identified issues (even if experts conclude "no issue" or "editorial only")
  * Issues discussed in expert reasoning sections, even if not in formal issue lists
  * Any inconsistencies, ambiguities, or problems mentioned in any part of the text
  * Issues labeled as "potential", "candidate", "may cause", "underspecification", or similar
- Only use information present in the input text.
- Labels must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (include specific terms, values, or section references when relevant).
- Evidence snippets (5a) must be copied verbatim from the input text (without quotes). Snippets must be complete and sufficient - include all relevant context needed to understand and verify the issue. Do not use partial snippets.
- Evidence summary (5b) must be derived ONLY from the evidence snippets E1..En and must cite (E#) per bullet.
- Deduplicate: merge issues that refer to the same underlying erratum and list all experts.
- Severity/Confidence: prefer explicit expert values; otherwise infer conservatively and state "inferred".

================================================================================
USER PROMPT
================================================================================

Read the ENTIRE analyzer output below carefully from start to finish. Extract ALL issues, problems, inconsistencies, or ambiguities mentioned anywhere in the text.

Include ALL issues mentioned in the analysis:
- Router candidate issues (even if marked "candidate" or "potential")
- Expert-identified issues (check all expert sections: Scope, Causal, Quantitative, Structural, CrossRFC, Terminology, etc.)
- Issues discussed in expert reasoning/analysis sections, even if not in formal issue lists
- Any inconsistencies, ambiguities, underspecifications, or problems mentioned anywhere
- Issues labeled as "potential", "candidate", "may cause", "editorial", "underspecification", or similar
- Do NOT skip issues just because an expert concludes "no issue" or "editorial only" - if it's discussed, include it

Produce deduplicated errata reports as JSON.

Each errata report MUST contain exactly these fields:
1) label: Errata short Label (must be explicit and descriptive - readers should understand the problem at a glance, e.g., "Misnamed LDAP/X.509 CA certificate attribute ("caCertificate" vs "cACertificate")")
2) bug_type: Bug Type
3) explanation: Concise Explanation (1-2 sentences, neutral)
4) justification: Justification (array of bullets, must be supported by Evidence snippets)
5) evidence: Object with:
   - snippets: Array of {id: "E1", text: "..."} (verbatim, complete and sufficient excerpts, no quotes around text)
   - summary: Array of strings, each citing (E1), (E2), etc.
6) fix_direction: Fix Direction if exists, else null
7) severity: Low | Medium | High | Unspecified
8) severity_basis: Basis for severity
9) confidence: High | Medium | Low | Unspecified
10) experts: Array of "ExpertName: issue_id" strings

Constraints:
- Label must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (e.g., include specific terms, section references, or conflicting values when relevant).
- Evidence snippets must be verbatim from input (format: text directly, no quotes).
- Evidence snippets must be complete and sufficient - include all relevant context needed to understand the issue.
- Evidence summary must cite (E1), (E2), ... and contain no new facts beyond snippets.
- Keep each errata report concise.

Analyzer output:
<<<
REASONING EXPERT ANALYSES
================================================================================

## Temporal Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
TemporalAnalysis:
  HighLevelSummary: |
    Section 14 (and its cross‑references) defines how clients rate‑limit transmissions and how they schedule Renew/Rebind when T1/T2 are left at 0 in IA_NA/IA_PD. The core temporal behavior is coherent at a high level, but the “client‑chosen T1/T2 = 0” case is only loosely constrained. This leads to underspecified scheduling of Renew/Rebind, both in terms of avoiding storms and in terms of how long a Renew exchange should run when no T2 time exists.
  OverallTemporalRisk: Medium
  CandidateIssues:
    - Id: T1
      Type: Underspecification
      ShortLabel: T1/T2=0 — vague client scheduling and “avoid message storms”
      Description: |
        When a server sets T1 and/or T2 to 0 in IA_NA/IA_PD, the spec explicitly delegates the choice of Renew/Rebind times to the client and requires that the client “MUST choose a time to avoid message storms” and “MUST NOT transmit immediately,” and that it obey the per‑interface rate limit. However, there is no concrete lower or upper bound, no requirement for randomization, and no normative relationship to preferred/valid lifetimes or to other clients’ behavior. The term “immediately” is not defined in any time scale, so a client that sends a Renew a few milliseconds or a few seconds after the Reply could both plausibly claim compliance. Because other parts of the document do specify explicit random delays to decorrelate clients (e.g., SOL_MAX_DELAY, INF_MAX_DELAY, CNF_MAX_DELAY), this looser treatment for the T1/T2=0 case stands out as a temporal gap. This makes compliance hard to test and allows behaviors that technically meet the MUSTs but still create large bursts across many clients or risk very late renewals.
      TemporalReasoning: |
        1. Normal case (T1/T2 non‑zero):
           - The server chooses T1/T2 values per IA; the client MUST use them unless they are 0   (21.4, 21.21).
           - Recommended T1/T2 are 0.5 and 0.8 of the shortest preferred lifetime in the IA, giving an explicit ordering: Solicit/Request → Reply → T1 time → Renew exchange → T2 time → Rebind exchange → valid lifetime expiry   (21.4, 21.21).
           - Section 18.2.4 then says the client “MUST select T1 and T2 times from all IA options that will guarantee that the client initiates transmissions … not later than at the T1/T2 times associated with any of the client’s bindings”  , so the Renew/Rebind schedule is tightly constrained.

        2. T1/T2 set to 0 by the server:
           - For IA_NA and IA_PD, the spec states that 0 means “the time at which the addresses/prefixes … are to be renewed is to be left to the discretion of the client,” and that in this case “the client MUST follow the rules defined in Section 14.2”   (21.4, 21.21).
           - Section 14.2 then says: when T1 and/or T2 are 0, the client:
             * “MUST choose a time to avoid message storms,”
             * “MUST NOT transmit immediately,”
             * SHOULD coalesce multiple IA options into one Renew/Rebind exchange if possible, and
             * “MUST choose renew and rebind times to not violate rate-limiting restrictions as defined in Section 14.1”  .
           - There is no definition of “immediately” (e.g., “within the same second as the Reply”) and no guidance on a minimum delay beyond “not 0.”
           - There is also no normative advice tying the chosen times to the remaining preferred/valid lifetimes. A client could, in theory, choose to Renew very early (e.g., seconds after getting a lease with hours of lifetime) or very late (e.g., only when lifetimes are almost expired, or even not at all), and still respect “not immediately” and the per‑interface token bucket rate limit in 14.1  .

        3. Comparison to other temporal anti‑storm mechanisms:
           - For first Solicit, Confirm, and Information‑request messages, the spec defines explicit random delays: first Solicit SHOULD be delayed by a random time in [0, SOL_MAX_DELAY]  , Confirm must be delayed by a random time in [0, CNF_MAX_DELAY]  , and first Information‑request by [0, INF_MAX_DELAY]  .
           - These sections demonstrate an intent to decorrelate clients in time using specified ranges and randomization; by contrast, 14.2 has only a qualitative “avoid message storms” requirement with no mechanics.

        4. Consequences for realizable timelines:
           - A population of identical clients can all receive a Reply with T1/T2=0 at roughly the same time, then all choose a fixed non‑random delay (e.g., 1 second) and send Renew messages together. They respect “MUST NOT transmit immediately” and remain within per‑interface rate-limits, but they still create a burst that looks like a “storm” from the server’s perspective.
           - At the other extreme, a client could set its Renew only after 95–99% of the valid lifetime, or even never renew at all, letting lifetimes expire and then re‑Soliciting. This does not violate any explicit timing requirement in 14.2, 18.2.4, or 21.4/21.21, beyond the generic requirement to stop using addresses after valid lifetime expiry   (6.2, 12.1, 12.2).

        Overall, the only strict temporal constraints in the T1/T2=0 case are: (a) don’t send the Renew/Rebind “immediately,” and (b) stay within the local token‑bucket limit. The central requirement “MUST choose a time to avoid message storms” is too qualitative to derive a specific ordering or delay bound, and it is not anchored to lifetimes or to any degree of randomization.
      KeyEvidence:
        ExcerptPoints:
          - “When T1 and/or T2 values are set to 0, the client MUST choose a time to avoid message storms. In particular, it MUST NOT transmit immediately. … The client MUST choose renew and rebind times to not violate rate-limiting restrictions as defined in Section 14.1.” (Section 14.2)
          - “In a message sent by a server to a client, the client MUST use the values in the T1 and T2 fields for the T1 and T2 times, unless values in those fields are 0. … If the time at which the addresses in an IA_NA are to be renewed is to be left to the discretion of the client, the server sets the T1 and T2 values to 0. The client MUST follow the rules defined in Section 14.2.” (Section 21.4; analogous text in 21.21)
          - “The server controls the time at which the client should contact the server … through the T1 and T2 values… the client MUST select T1 and T2 times from all IA options that will guarantee that the client initiates transmissions … not later than at the T1/T2 times associated with any of the client’s bindings (earliest T1/T2). … If T1 or T2 had been set to 0 by the server … the client may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.” (Section 18.2.4)
          - Explicit random‑delay rules for first Solicit, Confirm, and Information‑request messages (Sections 18.2.1, 18.2.3, 18.2.6).
          - Per‑interface rate‑limiting requirement: “A DHCPv6 client MUST limit the rate of DHCP messages it transmits or retransmits … For a device that has multiple interfaces, the limit MUST be enforced on a per-interface basis.” (Section 14.1)
        ContextPoints: []
      ImpactOnImplementations: |
        Implementers have no clear, testable rule for how long after a Reply they must wait before sending a Renew/Rebind when T1/T2=0, nor how early is “too early” in relation to lifetimes. Different stacks may choose very different strategies: some may renew aggressively and frequently, others rarely or only when lifetimes are nearly expired. All of these can plausibly claim to satisfy 14.2. This variability does not break wire‑level interoperability but can materially affect network behavior: synchronized bursts of Renew/Rebind messages from many clients are still possible while nominally conforming to per‑interface rate limits, and very late renewals may systematically let leases expire before renewal attempts. The ambiguous “MUST avoid message storms” therefore does not reliably prevent the very patterns it is intended to avoid, and it makes conformance testing difficult.
      AffectedArtifacts:
        - Section 14.2 (Client Behavior when T1 and/or T2 Are 0)
        - Section 21.4 (IA_NA) and Section 21.21 (IA_PD) — paragraphs discussing T1/T2=0
        - Section 18.2.4 (Creation and Transmission of Renew Messages) — handling of T1/T2=0 case
      Severity: Medium

    - Id: T2
      Type: Underspecification
      ShortLabel: MRD computation for Renew when all T2 values are zero
      Description: |
        The Renew retransmission procedure depends on an MRD (“Maximum Retransmission Duration”) parameter defined as “remaining time until earliest T2,” but when all T2 fields are 0, T2 times are intentionally undefined and control is delegated to the client. The text that defines MRD for Renew does not specify how to handle this case. This leaves a gap in the lifetime of a Renew/Reply exchange triggered under T2=0: an implementation has to guess whether MRD should be treated as infinite, zero, based on lifetimes, or simply ignored.
      TemporalReasoning: |
        1. For “normal” IAs (T2 > 0):
           - The IA defines a T2 field in seconds; client computes a T2 time = reception_time + T2_value   (4.2, 21.4, 21.21).
           - In Renew, the spec says: “The client transmits the message according to Section 15, using the following parameters: … MRD = Remaining time until earliest T2. The message exchange is terminated when the earliest time T2 is reached, at which point the client begins the Rebind message exchange.”  
           - This gives a clear sequence: Renew attempts for up to (T2_time – now), then switch to Rebind.

        2. For IAs with T2=0:
           - For IA_NA/IA_PD, “In a message sent by a server to a client, the client MUST use the values in the T1 and T2 fields for the T1 and T2 times, unless values in those fields are 0.”   (21.4, 21.21). When T2=0, there is explicitly no T2 time to schedule against.
           - Instead, “If the time at which the addresses … are to be renewed is to be left to the discretion of the client, the server sets the T1 and T2 values to 0. The client MUST follow the rules defined in Section 14.2.”  
           - Section 18.2.4 acknowledges this: “If T1 or T2 had been set to 0 by the server … the client may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.”  

        3. Ambiguity in MRD:
           - Despite this special handling, the very same section (18.2.4) still defines MRD for Renew as “Remaining time until earliest T2,” with no exception for the T2=0 case  .
           - If every IA from that server has T2=0, there *is no* “earliest T2 time” in the normal sense; the spec has told the client not to interpret 0 as an absolute time.
           - Possible readings (none stated normatively) include:
             * Treat T2=0 as if T2_time equals the Reply reception time (i.e., already passed), which would make MRD=0 and cause the Renew exchange to immediately “expire” by time but still leave the client free to keep sending Renew under MRC, contradicting the intended meaning of MRD.
             * Treat MRD as infinite / not applicable when all T2 are 0, and rely solely on MRC to terminate the Renew exchange.
             * Derive MRD from remaining valid lifetimes instead (e.g., match the Rebind MRD rule), but this is not specified.

        4. Resulting temporal uncertainty:
           - In a case where all T2 fields are 0, two conformant implementations might behave very differently:
             * One might effectively have Renew exchanges with no time‑based cutoff, retrying forever (subject to MRC) until a Reply arrives or the process is manually abandoned.
             * Another might interpret MRD as 0 and consider the Renew “failed” immediately for timer purposes, perhaps jumping straight to Rebind or Solicit.
           - Because 14.2 only constrains *when to send* Renew/Rebind messages (not how long to keep retrying a failed Renew), this missing definition of MRD leaves the duration of a Renew exchange in the T2=0 case under‑specified.
      KeyEvidence:
        ExcerptPoints:
          - “In a message sent by a server to a client, the client MUST use the values in the T1 and T2 fields for the T1 and T2 times, unless values in those fields are 0. … If the time at which the addresses in an IA_NA are to be renewed is to be left to the discretion of the client, the server sets the T1 and T2 values to 0. The client MUST follow the rules defined in Section 14.2.” (Section 21.4; similarly for IA_PD in Section 21.21)
          - “If T1 or T2 had been set to 0 by the server … the client may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.” (Section 18.2.4)
          - “The client transmits the [Renew] message according to Section 15, using the following parameters: … MRD = Remaining time until earliest T2. The message exchange is terminated when the earliest time T2 is reached…” (Section 18.2.4)
          - General MRD semantics: “MRD specifies an upper bound on the length of time a client may retransmit a message. Unless MRD is zero, the message exchange fails once MRD seconds have elapsed…” (Section 15)
        ContextPoints: []
      ImpactOnImplementations: |
        When all relevant IA_NA/IA_PD options have T2=0, implementers must make an unstated choice for MRD in the Renew state machine. Different decisions change how long the client will continue Renew attempts before giving up or switching behavior, which affects how quickly it falls back to Rebind or full server discovery after a server outage. This does not prevent interoperable packet exchanges once a working server replies, but it can lead to very different failure behavior and recovery times across implementations. Clarifying how to compute MRD in the T2=0 case (e.g., explicitly stating that MRD is not time‑bounded and Renew continues until MRC is hit or until lifetimes expire) would remove this ambiguity.
      AffectedArtifacts:
        - Section 18.2.4 (Creation and Transmission of Renew Messages) — MRD definition
        - Section 21.4 and Section 21.21 — semantics of T2=0
        - Section 15 (Reliability of Client-Initiated Message Exchanges) — MRD semantics
      Severity: Low

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]

## ActorDirectionality Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
ActorDirectionalityReport:
- ExcerptSummary: >
    The excerpt defines DHCPv6 roles (client, server, relay agent), who sends
    which message types in which direction, and then in Section 14 adds
    client-specific rules: clients send to the All_DHCP_Relay_Agents_and_Servers
    multicast address by default, must rate‑limit their own transmissions, and
    must choose Renew/Rebind times themselves when T1/T2 are zero.

- OverallAssessment: NoBug

- FindingsOnRoutedIssues:
  # No concrete IssueIds were provided in the prompt; nothing to map.

- AdditionalActorIssues:
  # No new actor/direction issues found.

- IfNoActorIssues:
  - Comment: >
      No actor/direction/role problems detected in this excerpt. The specification
      consistently assigns transmission responsibilities to the DHCPv6 client,
      server, and relay agent, and Section 14’s new rules are clearly scoped to
      the client only.

      In particular:
      * Message directions are coherent with the role definitions in Sections 5 and 7.3
        (e.g., clients send Solicit/Request/Renew/Rebind/Release/Decline/Information‑request;
        servers send Advertise/Reply/Reconfigure; relays send Relay‑forward/Relay‑reply).
      * Section 14 correctly constrains only the client: “A DHCPv6 client MUST limit
        the rate of DHCP messages it transmits or retransmits” and explicitly says
        “Rate limiting of forwarded DHCP messages and server-side messages is out of
        scope”, which cleanly avoids mis-assigning obligations to servers or relays.
      * The multicast/unicast rules are directionally consistent: clients send to the
        All_DHCP_Relay_Agents_and_Servers multicast address; servers and relays are
        the intended receivers of those multicasts; later, clients “SHOULD NOT accept
        multicast messages”, while servers/relays accept and process them and then
        send unicast (or relayed) replies back to clients.
      * The T1/T2=0 behavior is consistently client‑centric: servers signal “client’s
        choice” by setting T1/T2 to 0 in IA_NA/IA_PD, and Section 14.2 plus the
        cross‑references in Sections 18.2.4, 21.4, and 21.21 clearly place the
        responsibility on the client to choose actual Renew/Rebind times, with the
        only constraints being avoidance of storms and compliance with the client‑side
        rate limiting.

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]

## Scope Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
ScopeAnalysis:
- ExcerptSummary: Section 14 defines how a DHCPv6 client sends messages (destination address semantics), introduces a mandatory client-side rate limit, and constrains how a client may choose renew/rebind times when T1/T2 are set to zero in IA_NA/IA_PD. The surrounding sections define per–message-type validity of the Server Identifier option and how T1/T2 are interpreted in IA options, and describe the general retransmission algorithm that “may be influenced” by rate limiting.

- ScopeModel:
  - Targets:
    - DHCPv6 *clients* only, not servers or relays, for:
      - Default destination address of client-originated DHCP messages (All_DHCP_Relay_Agents_and_Servers ff02::1:2).
      - Rate limiting of client transmissions and retransmissions (per-interface).
      - Client-side choice of renew/rebind times when T1 and/or T2 in IA_NA / IA_PD are zero.
    - IA options:
      - IA_NA and IA_PD options whose T1/T2 fields are set to 0 in Replies from servers (renew/rebind left to client discretion).
  - Conditions:
    - Destination address:
      - “Unless otherwise specified in this document or in a document that describes how IPv6 is carried over a specific type of link (for link types that do not support multicast), a client sends DHCP messages to the All_DHCP_Relay_Agents_and_Servers multicast address.” (Section 14)
      - Client always uses multicast, even when addressing an “individual server” by including a Server Identifier option; omission of that option supposedly means “all servers are indicated” (Section 14).
    - Rate limiting:
      - A DHCPv6 client “MUST limit the rate of DHCP messages it transmits or retransmits,” with a configurable limit, recommended default “20 messages in 20 seconds,” and per-interface enforcement on multi-interface devices (Section 14.1).
      - Rate limiting is explicitly *not* specified for relayed or server-originated messages (Section 14.1), although Table 1 / Section 7.6 say transmissions “may also be influenced by rate limiting (see Section 14.1).”
    - T1/T2 = 0:
      - “In certain cases, T1 and/or T2 values may be set to 0,” currently enumerated as:
        1. client received an IA_NA option with a zero value;
        2. client received an IA_PD option with a zero value. (Section 14.2)
      - Zero T1/T2 is “an indication that the renew and rebind times are left to the discretion of the client,” but the client:
        - MUST NOT transmit immediately.
        - SHOULD try to align renew/rebind so that “all IA options are handled in one exchange” if possible.
        - MUST choose renew/rebind times so as not to violate Section 14.1 rate limits. (Section 14.2)
      - Other sections tie this explicitly to IA_NA and IA_PD semantics and to specific client behavior:
        - IA_NA and IA_PD definition sections say that if T1/T2 are 0, the server leaves timing to client discretion and “The client MUST follow the rules defined in Section 14.2.” (Sections 21.4, 21.21)
        - Renew/Rebind behavior says “If T1 or T2 had been set to 0 … the client may, at its discretion, send a Renew or Rebind… The client MUST follow the rules defined in Section 14.2.” (Section 18.2.4)
  - NotedAmbiguities:
    - Section 14’s description of using the Server Identifier option to select an “individual server” versus “all servers when this option is not supplied” is written generically, without restricting it to only those message types where the option is actually permitted and optional.
    - The list of “currently, there are two such cases” for T1/T2=0 in Section 14.2 is phrased as “a client received an IA_NA option with a zero value / IA_PD option with a zero value,” which relies on context to mean “T1/T2 fields are zero,” and might be read more broadly.
    - Section 7.6 says “Transmissions may also be influenced by rate limiting (see Section 14.1)” in a table that covers both clients and servers, while Section 14.1 explicitly scopes the normative rate-limiting requirement to clients only and declares server-side rate limiting out of scope.

- CandidateIssues:
  - Issue-1:
    - BugType: Inconsistency
    - ShortLabel: Server Identifier semantics in Section 14 are stated with global scope but contradict per–message-type rules on when the option may/must/must-not appear
    - ScopeProblemType: Over-broad, unqualified description of option semantics (Server Identifier) conflicting with message-type–scoped validity rules
    - Evidence:
      - Section 14: “A client uses multicast to reach all servers or an individual server. An individual server is indicated by specifying that server's DUID in a Server Identifier option (see Section 21.3) in the client's message. (All servers will receive this message, but only the indicated server will respond.) All servers are indicated when this option is not supplied.”
      - Solicit validation (Section 16.2): “Servers MUST discard any Solicit messages that … do include a Server Identifier option.”
      - Request validation (Section 16.4): “Servers MUST discard any received Request message that meets any of the following conditions: * the message does not include a Server Identifier option …”
      - Renew/Decline/Release validation (Sections 16.6, 16.8, 16.9): same pattern – Server Identifier is *mandatory* for these messages.
      - Information-request behavior and validation:
        - Generic behavior: “When responding to a Reconfigure, the client MUST include a Server Identifier option (see Section 21.3) with the identifier from the Reconfigure message…”; otherwise, the client *may* omit it (Section 18.2.6).
        - Servers “MUST discard any received Information-request message that … includes a Server Identifier option, and the DUID in the option does not match the server's DUID.” (Section 16.12)
    - DetailedReasoning:
      - Section 14 presents a general model for how a client “uses multicast to reach all servers or an individual server,” defining the semantics of presence vs absence of the Server Identifier option with no qualification by message type: including a Server Identifier is said to mean “individual server,” and omitting it is said to mean “all servers are indicated.”
      - However, later sections define strict, message-type–specific rules for when the Server Identifier option is mandatory, forbidden, or optional. In particular:
        - For Solicit, servers MUST discard messages that include a Server Identifier; the “individual server” mechanism described in Section 14 is explicitly disallowed for Solicit. A Solicit is always to “all” eligible servers, regardless of any desire to talk to one specific server.
        - For Request, Renew, Decline, and Release, servers MUST discard messages that lack a Server Identifier; there is no valid “all servers” semantics for omitting the option here – an omitted Server Identifier makes the message invalid, not a broadcast request.
        - For Information-request, the Server Identifier is optional in the general case, but *mandatory* in the Reconfigure-triggered case; omitting it in that subcase does not mean “all servers,” it means “non-compliant,” and including a mismatching Server Identifier mandates discard.
      - Because Section 14’s description is unqualified, an implementer could reasonably infer that for any client-originated message, they can:
        - Omit the Server Identifier to speak to “all” servers; or
        - Include a Server Identifier to target a specific server,
        with the same semantics across messages.
      - That inferred global semantics directly contradict the message validation rules: for example, a Request without a Server Identifier is not treated by the protocol as a “Request to all servers,” but rather must be discarded by all compliant servers; conversely, a Solicit with a Server Identifier is not a “targeted Solicit” but an invalid message to be dropped.
      - The root cause is a *scope mismatch*: Section 14 appears to ascribe global semantics to the Server Identifier option at the “all messages” level, but the rest of the document actually gives that semantics only to those message types where the option is both (a) allowed and (b) optional (e.g., generic Information-request and perhaps some other cases), and gives *different* semantics (must/must-not be present) for other message types.
      - If an implementation follows the literal text of Section 14 for all messages but overlooks or misreads the later validation rules, it might send:
        - Request, Renew, or Release messages without a Server Identifier to try to talk to “any server,” where in fact all such messages must be discarded, leading to failure to renew or release leases.
        - Solicit messages with a Server Identifier to select a particular server, but such Solicits must be discarded by all compliant servers, causing server discovery to fail.
      - A more accurate scoping would say explicitly that the “individual server” vs “all servers” interpretation of the Server Identifier option only applies to those DHCP message types where the option is *permitted and optional* according to Sections 16 and 18, and that for other message types, presence/absence is constrained as specified in those sections. The current wording fails to express that scope, creating a real inconsistency in how the option’s semantics are described.

- ResidualUncertainties:
  - Section 14.2’s introductory phrasing (“Currently, there are two such cases: a client received an IA_NA option with a zero value / IA_PD option with a zero value”) is slightly ambiguous about which field in the IA is “zero,” but cross-references from Sections 21.4, 21.21, and 18.2.4 make it clear that the intended scope is the T1/T2 fields of IA_NA and IA_PD options in Replies from servers. I did not treat this as an erratum because the surrounding context sufficiently pins down the intended scope for implementers.

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]

## Causal Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
1. **Summary**

Section 14.2 is implementable and does not create a contradiction with the rest of the state machine. However, it leaves the client’s choice of renew/rebind times when T1/T2 are zero very loosely constrained. That underspecification can lead to widely different, possibly sub‑optimal but still interoperable behaviors (e.g., very early or very late renewals), but it does not make the protocol fail in a fundamental way.

---

2. **Causal Analysis**

**What 14.2 actually requires**

When a server sets T1 and/or T2 to 0 in IA_NA or IA_PD (meaning “client decides” per 21.4 and 21.21), the client must:

- “choose a time to avoid message storms” and “MUST NOT transmit immediately” 14.2  
- “MUST choose renew and rebind times to not violate rate-limiting restrictions as defined in Section 14.1” 14.2  

14.1, in turn, requires that the client rate‑limit DHCP messages, with a RECOMMENDED token bucket like ~20 messages per 20 seconds per interface.

Sections 21.4 and 21.21 explicitly say that if the server wants the client to decide renewal timing, it sets T1/T2 to 0, and then: “The client MUST follow the rules defined in Section 14.2.” So 14.2 is the *only* normative guidance for that case.

**Interaction with the rest of the state machine**

- Renew/Rebind behavior (18.2.4, 18.2.5) assumes default semantics where non‑zero T1, T2 are provided and defines:
  - At T1: start Renew; MRD = remaining time until earliest T2, stop at T2 and switch to Rebind 18.2.4.
  - At T2: start Rebind; MRD = remaining time until valid lifetimes expire 18.2.5.

- When T1 or T2 is zero, 18.2.4 says the client “may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.” So for those IAs, the client’s chosen “renew and rebind times” conceptually substitute for server-provided T1/T2 in deciding *when* to start Renew/Rebind, but the retransmission algorithm itself (IRT, MRT, etc.) is unchanged once it does start.

- Lifetimes are still independent invariants: valid lifetimes in IA Address / IA Prefix options define the absolute latest time the client may continue using addresses/prefixes 12.1, 12.2, and the client *must* stop using them when the valid lifetime expires 6.2, 6.3. Nothing in 14.2 alters this.

So an honest implementer can:

- Define any internal policy (e.g., “renew when 50% of valid lifetime has elapsed, rebind at 80%, add some random jitter”) when T1/T2=0.
- Feed those chosen times into the existing Renew/Rebind machinery without violating any MUSTs.

There is no requirement elsewhere that the client *must* approximate the server’s usual 0.5/0.8 rules when T1/T2 are zero, only a recommendation when the server chooses T1/T2 itself 21.4, 21.21.

**What “vague” behavior is allowed and its consequences**

Because 14.2 only says:

- don’t transmit “immediately”,  
- avoid “message storms”,  
- respect the per-interface rate limit,

without specific numbers, several behaviors are possible:

- **Very early renewals.** A client might choose to renew very aggressively (e.g., every few minutes, or with a small fixed delay after each Reply), as long as it stays under the rate limit. That increases DHCP load but does not break correctness: servers will respond; leases remain valid; and per‑interface rate limiting bounds how bad an individual client can be.

- **Very late renewals.** A client might choose to renew only shortly before the valid lifetime expires. That increases the risk of losing leases if the server or path is down, but this is consistent with the lifetime semantics: if the valid lifetime expires, the client must stop using the address/prefix anyway. It is not an interoperability failure; it is a policy/robustness choice.

- **Synchronized bursts.** If many clients implement the same deterministic policy (e.g., “renew 60 seconds after Reply, with no jitter”) they can cause bursts of Renew messages. 14.2’s qualitative “avoid message storms” requirement is supposed to discourage that, but it is not mechanically enforceable. Even so:
  - Per‑client rate limiting still holds.
  - Servers do not depend on a particular spread of renew times; they just need to handle whatever arrival pattern occurs, up to scale.

In all these cases, the protocol’s state machine remains coherent: messages are legal, timers are implementable, and both sides can process them without ambiguity.

**Ambiguities that are *not* fatal**

- **Meaning of “immediately”.** The spec does not define how long a delay is sufficient to count as “not immediate.” An implementer can choose any positive delay (say ≥1 second), and nothing else in the spec contradicts that choice. This affects how much initial burst you get, but not correctness.

- **Quantifying “message storms”.** There is no precise threshold, so this MUST is not rigorously testable. However, that doesn’t create a situation where *no* correct implementation is possible; rather, it leaves performance and load‑management largely up to implementers and operators.

- **Relationship to lifetimes.** The text doesn’t say “you MUST renew by some fraction of the preferred/valid lifetime” for the T1/T2=0 case, but the absolute invariant “do not use addresses/prefixes past valid lifetime” is still enforceable and unambiguous. Different clients may use different policies, but all remain interoperable with servers.

---

3. **Problem Classification**

- **Type:** Causal Underspecification (low severity).

The spec does not fully specify *how* to choose renew/rebind times when T1/T2 are zero, beyond some qualitative constraints. That can lead to inconsistent or suboptimal behaviors across clients and makes it hard to tell, in a black‑box way, whether a client really “avoids message storms.” However, it does **not** make the protocol unimplementable or logically inconsistent, nor does it force any violation of address/prefix lifetime invariants, so the underspecification is about scaling/efficiency rather than fundamental correctness.

---

4. **Minimal Fix Shape (Optional)**

If the WG wants more precise behavior here, a minimal, local enhancement would be:

- Add a **RECOMMENDED algorithm** for the T1/T2=0 case (e.g., choose client‑side T1′ and T2′ as fractions of the minimum preferred/valid lifetime in the IA, plus randomized jitter, and treat those as the conceptual T1/T2 for 18.2.4/18.2.5).
- Optionally clarify that “immediately” means “with zero or negligible delay relative to typical RTTs” and that clients SHOULD introduce randomization when scheduling discretionary Renew/Rebind to avoid synchronization.

This would make the “avoid message storms” intent more operationally concrete without changing wire behavior.

---

5. **Non‑Issues**

- There is no circular or impossible dependence (e.g., using data that doesn’t exist yet) in 14.2.
- No server behavior depends on clients picking a *specific* schedule when T1/T2=0; servers simply answer Renew/Rebind as they come.
- Lease expiry semantics remain clear and enforceable regardless of how clients choose renewal times.

So while 14.2 is somewhat high‑level for a BCP‑14 “MUST,” it does not cause fundamental protocol breakage if implemented as written.

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]

## Deontic Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
DeonticAnalysis:
- ExcerptSummary: Section 14 (and its references) defines how a DHCPv6 client sends messages (default multicast to All_DHCP_Relay_Agents_and_Servers), mandates client-side rate limiting of DHCP traffic, and specifies client behavior when T1 and/or T2 are zero (server leaves renew/rebind timing to the client, but with constraints to avoid storms and obey rate limits).

- OverallDeonticRisk: None

- Issues:
  - Issue-1:
    - BugType: None
    - Title: T1/T2=0 behavior is intentionally flexible but not normatively broken
    - Description:
      The key normative statements in this area are: (1) a DHCPv6 client MUST limit the rate of DHCP messages it transmits or retransmits, with the limit enforced per interface  ; (2) when T1 and/or T2 values are set to 0, the client MUST choose a time to avoid message storms, MUST NOT transmit immediately, SHOULD coalesce multiple IAs into one exchange, and MUST choose renew and rebind times so as not to violate the Section 14.1 rate limits  ; and (3) when a server sets T1/T2 to 0 in IA_NA or IA_PD, the client MUST follow the rules in Section 14.2  , with Section 18.2.4 reiterating this for Renew/Rebind behavior  . These constraints deliberately leave the actual timing algorithm to the client, beyond the hard requirements “not immediate” and “respect rate limiting.” In context, this is consistent with other parts of the spec: clients are required to stop using addresses/prefixes when valid lifetimes expire, but they are not required to retain leases at all, so there is no normative requirement that renewals happen by any particular point before expiry. The spec also explicitly allows rate limiting to influence retransmissions  , so there is no conflict between Section 14.1’s MUST and the retransmission algorithm in Section 15. The router’s concern that “avoid message storms” is high level is fair as a style critique, but from a deontic standpoint the obligations are coherent and implementable: a compliant implementation must (a) implement some per-interface rate limiter, (b) avoid generating an immediate Renew/Rebind when T1/T2 are zero, and (c) pick some nonzero delay that does not exceed its own configured rate. There is no cross-implementation dependency on the exact delay values, so differing choices do not cause interoperability failure; they only affect load on the server, which is already under the server’s control when it chooses to set T1/T2 to 0. The lack of a specific numeric lower or upper bound, or a mandated randomization scheme, is therefore an intentional design choice rather than a missing normative constraint.
    - KeyTextSnippets:
      - “A DHCPv6 client MUST limit the rate of DHCP messages it transmits or retransmits… For a device that has multiple interfaces, the limit MUST be enforced on a per-interface basis.”  
      - “When T1 and/or T2 values are set to 0, the client MUST choose a time to avoid message storms. In particular, it MUST NOT transmit immediately… The client MUST choose renew and rebind times to not violate rate-limiting restrictions as defined in Section 14.1.”  
      - “If T1 or T2 had been set to 0 by the server (for an IA_NA or IA_PD) in a previous Reply, the client may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.”  
      - “If the time at which the addresses in an IA_NA are to be renewed is to be left to the discretion of the client, the server sets the T1 and T2 values to 0. The client MUST follow the rules defined in Section 14.2.” (similarly for IA_PD)  
      - “Transmissions may also be influenced by rate limiting (see Section 14.1).”  
    - Impact:
      Because the only inter-node semantic of T1/T2=0 is “the server leaves timing to the client, subject to basic anti-storm and rate-limit rules,” and there is no requirement that the client keep leases beyond their valid lifetimes, the freedom left to the client does not cause protocol-level inconsistency or interoperability failure. Different clients may choose conservative or aggressive timers, but as long as they obey the MUST NOT “immediate” and the per-interface rate limit, they remain compliant, and servers cannot rely on any stronger guarantees when they choose to set T1/T2 to zero.

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]

## Boundary Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
BoundaryAnalysis:
- ExcerptUnderstanding: Section 14 defines how a DHCPv6 client sends messages (always to the All_DHCP_Relay_Agents_and_Servers multicast group unless a link-specific spec says otherwise) and introduces a mandatory client-side rate limit, with token-bucket as a recommended mechanism and a per-interface scope. Section 14.2 covers the exceptional case where the server sets T1 and/or T2 to 0 in IA_NA/IA_PD, which is interpreted as “renew/rebind timing is left to the client,” but constrained to avoid “message storms” and to respect the rate limit, with a recommendation to coalesce multiple IAs into one exchange. Other sections (18.2.4, 18.2.5, 21.4, 21.21) tie these special T1/T2=0 cases into the general Renew/Rebind state machine and the address/prefix lifetimes.

- OverallBoundaryBugLikelihood: None

- Findings:
  - Finding-1:
    - BugType: None
    - ShortLabel: Semantics for T1/T2 = 0 are high-level but coherent
    - BoundaryAxis: Special case where T1 and/or T2 are zero (client-chosen renew/rebind times)
    - ExcerptEvidence: Section 14.2 says that when T1 and/or T2 are 0 in IA_NA or IA_PD, “This is an indication that the renew and rebind times are left to the discretion of the client,” but the client “MUST choose a time to avoid message storms. In particular, it MUST NOT transmit immediately… [and] MUST choose renew and rebind times to not violate rate-limiting restrictions as defined in Section 14.1.” Section 21.4/21.21 state that when renewal timing is left to the client, the server sets T1 and T2 to 0 and “The client MUST follow the rules defined in Section 14.2.” Section 18.2.4 adds that “If T1 or T2 had been set to 0 by the server… the client may, at its discretion, send a Renew or Rebind message, respectively. The client MUST follow the rules defined in Section 14.2.” Lifetimes and the obligation to stop using expired addresses/prefixes are defined elsewhere (e.g., Sections 6.2 and 6.3).
    - Reasoning: The domain here is the space of possible times at which a client may initiate Renew/Rebind when the server has signaled T1=0 and/or T2=0. The spec gives an explicit rule: in that case, the client selects its own times, but (a) MUST NOT send immediately upon receiving the Reply, and (b) MUST respect an explicit rate limit (per Section 14.1), with an additional SHOULD to coalesce all IAs into one exchange  . This is then cleanly integrated into the general state machine via 18.2.4’s special-case language for T1/T2=0 (client may send Renew/Rebind at its discretion, but “MUST follow” 14.2), while the “normal” T1/T2>0 cases remain governed by “At time T1/T2…” in 18.2.4/18.2.5. There is no state in which the client’s obligations are undefined: for non-zero T1/T2, the timer-based behavior is clear; for zero values, the client must not flood and must obey the token-bucket limit. The remaining degrees of freedom – exactly *how far* after receipt to send, whether to add jitter, how to relate the chosen times to preferred/valid lifetimes – are consistent with the intent (“left to the discretion of the client”) and do not affect interoperability on the wire: regardless of when a client issues Renew/Rebind within the valid-lifetime window, the server processes those messages identically. Behavior after valid lifetime expiry is also covered elsewhere (client must stop using expired addresses/prefixes and can fall back to a new Solicit/Request)  .
    - ImpactAssessment: Although phrases like “avoid message storms” and “immediately” are informal and leave room for different renewal heuristics, they do not create contradictory requirements or leave any boundary state with undefined behavior. Different choices of renewal timing can impact load and efficiency, but they do not affect interoperability or correctness of the protocol as specified, so this is not a specification bug in the boundary/exceptional-case sense.

- Notes:
  - Not a bug, but slightly loose wording: Section 14.2 speaks of “T1 and/or T2 values” being 0 and of “renew and rebind times” being left to the client, while 21.4 and 21.21 describe the server setting *both* T1 and T2 to 0 when it wants to delegate timing to the client. In practice, 18.2.4 explicitly covers the per-field case (“If T1 or T2 had been set to 0…”) and the semantics remain consistent, so this does not lead to ambiguous behavior.

[Used vector stores: vs_6958be89a44481918c2ddd280ca7a32c]


Vector Stores Used: vs_6958be89a44481918c2ddd280ca7a32c
>>>

Return JSON array of errata reports:
{
  "reports": [
    {
      "label": "...",
      "bug_type": "...",
      "explanation": "...",
      "justification": ["...", "..."],
      "evidence": {
        "snippets": [
          {"id": "E1", "text": "..."}
        ],
        "summary": ["(E1) ...", "(E2) ..."]
      },
      "fix_direction": "..." or null,
      "severity": "...",
      "severity_basis": "...",
      "confidence": "...",
      "experts": ["..."]
    }
  ]
}