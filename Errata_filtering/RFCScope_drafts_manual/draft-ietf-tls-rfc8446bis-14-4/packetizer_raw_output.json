{
  "reports": [
    {
      "label": "Global Handshake Ordering vs Post‑Handshake Message Flexibility",
      "bug_type": "Inconsistency",
      "explanation": "The specification mandates that protocol messages are sent in a strict order (per Section 4.4.1 and the diagrams in Section 2), yet later sections allow post‐handshake messages (e.g. NewSessionTicket, post‑handshake CertificateRequest, and KeyUpdate) to be interleaved with application data.",
      "justification": [
        "The text states: Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.  A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ‘unexpected_message’ alert.",
        "Section 4.6.1 describes that after the server receives the client Finished message, it MAY send a NewSessionTicket message, allowing multiple tickets at different times.",
        "Section 4.6.2 explains that a server MAY request certificate-based client authentication at any time after the handshake by sending a CertificateRequest, with an allowance for interleaving of other messages.",
        "The KeyUpdate message is defined to be sent by either peer after sending a Finished message, with no fixed placement relative to the main handshake messages."
      ],
      "evidence": {
        "snippets": [
          {
            "id": "E1",
            "text": "“Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2.  A peer which receives a handshake message in an unexpected order MUST abort the handshake with an ‘unexpected_message’ alert.”"
          },
          {
            "id": "E2",
            "text": "“At any time after the server has received the client Finished message, it MAY send a NewSessionTicket message. … Servers MAY send multiple tickets on a single connection, either immediately after each other or after specific events…”"
          },
          {
            "id": "E3",
            "text": "“When the client has sent the ‘post_handshake_auth’ extension … a server MAY request certificate-based client authentication at any time after the handshake has completed by sending a CertificateRequest message. … servers MUST be prepared for some delay, including receiving an arbitrary number of other messages between sending the CertificateRequest and receiving a response.”"
          },
          {
            "id": "E4",
            "text": "“The KeyUpdate handshake message is used to indicate that the sender is updating its sending cryptographic keys.  This message can be sent by either peer after it has sent a Finished message.”"
          }
        ],
        "summary": [
          "(E1) Stipulates a strict ordering for handshake messages per Section 4.4.1 and the diagrams in Section 2.",
          "(E2) Permits NewSessionTicket messages to be sent at arbitrary later times after Finished.",
          "(E3) Allows post‑handshake CertificateRequest interleaved with other messages.",
          "(E4) Defines KeyUpdate as a post‑handshake message with flexible ordering."
        ]
      },
      "fix_direction": "Clarify the global ordering requirement so that it explicitly applies only to the main handshake messages, thereby excluding post‑handshake messages from this strict ordering.",
      "severity": "Medium",
      "severity_basis": "The conflicting prescriptions can lead to divergent implementations that either reject valid post‑handshake sequences or misinterpret the rules for message ordering.",
      "confidence": "High",
      "experts": [
        "Temporal: T1"
      ],
      "report_id": "draft-ietf-tls-rfc8446bis-14-4-1"
    },
    {
      "label": "Unclear Global Scope for ‘PSK or Certificate, but not both’ Requirement",
      "bug_type": "Underspecification",
      "explanation": "The statement in Section 4.1.1 that either a PSK or a certificate must be used is too global, while later sections allow combinations (e.g. post‑handshake client authentication and use of external PSKs per RFC8773), creating ambiguity in its intended scope.",
      "justification": [
        "Section 4.1.1 states: In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together.",
        "The text in Section 2.2 / Figure 3 indicates that when a server is authenticating via a PSK, it does not send a Certificate or CertificateVerify message.",
        "Section 4.4 notes that certificate-based client authentication is not available in PSK handshake flows (including 0‑RTT), yet Sections 4.3.2 and 4.6.2 allow for post‑handshake client authentication.",
        "Additionally, the draft references RFC8773 as an extension to permit the combination of certificates with an external PSK, contradicting the global prohibition."
      ],
      "evidence": {
        "snippets": [
          {
            "id": "E1",
            "text": "In TLS 1.3 as defined by this document, either a PSK or a certificate is always used, but not both. Future documents may define how to use them together."
          },
          {
            "id": "E2",
            "text": "Section 2.2 / Figure 3 shows a PSK resumption handshake without server certificates and then says: “As the server is authenticating via a PSK, it does not send a Certificate or a CertificateVerify message.”"
          },
          {
            "id": "E3",
            "text": "Section 4.4: Certificate description ends with: “Note that certificate-based client authentication is not available in PSK handshake flows (including 0‑RTT).”"
          },
          {
            "id": "E4",
            "text": "Section 4.3.2: “Servers which are authenticating with a PSK MUST NOT send the CertificateRequest message in the main handshake, though they MAY send it in post‑handshake authentication …” and later references RFC8773 as providing an extension to permit combining with an external PSK."
          }
        ],
        "summary": [
          "(E1) Provides the global rule that either a PSK or a certificate must be used.",
          "(E2) Illustrates the intended use in PSK-only handshakes.",
          "(E3) States that certificate-based client authentication is not allowed in PSK handshake flows.",
          "(E4) Introduces an exception via post‑handshake authentication and RFC8773 for external PSKs."
        ]
      },
      "fix_direction": "Revise the phrasing in Section 4.1.1 to explicitly limit the rule to server authentication in the main handshake and to clarify that exceptions (e.g. for post‑handshake authentication or external PSKs via RFC8773) are permitted.",
      "severity": "Medium",
      "severity_basis": "Ambiguity in the rule’s scope may mislead implementers into erroneously rejecting valid PSK and certificate combinations under extended conditions.",
      "confidence": "High",
      "experts": [
        "Scope: Issue-1",
        "CrossRFC: Issue-2"
      ],
      "report_id": "draft-ietf-tls-rfc8446bis-14-4-2"
    },
    {
      "label": "ClientHello.extensions Minimum Length Inconsistency",
      "bug_type": "Inconsistency",
      "explanation": "The structural definition mandates a minimum length of 8 bytes for ClientHello.extensions, yet a ClientHello containing only a supported_versions extension encodes to 7 bytes, resulting in a conflict between the formal specification and its descriptive text.",
      "justification": [
        "The struct definition in Section 4.1.2/B.3.1 specifies: Extension extensions<8..2^16-1>; in ClientHello.",
        "The accompanying description states: “TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages).”",
        "The supported_versions structure is defined as: struct { ProtocolVersion versions<2..254>; } SupportedVersions; which, with its 1‑byte length and 2 bytes for the version, totals 3 bytes of extension data, plus 4 bytes for the extension header, yielding 7 bytes."
      ],
      "evidence": {
        "snippets": [
          {
            "id": "E1",
            "text": "Extension extensions<8..2^16-1>; (in ClientHello)"
          },
          {
            "id": "E2",
            "text": "TLS 1.3 ClientHello messages always contain extensions (minimally \"supported_versions\", otherwise, they will be interpreted as TLS 1.2 ClientHello messages)."
          },
          {
            "id": "E3",
            "text": "struct { ProtocolVersion versions<2..254>; } SupportedVersions; i.e., versions is a vector with a 1‑byte length and at least 2 bytes of data."
          }
        ],
        "summary": [
          "(E1) Specifies the minimum length of the extensions vector as 8 bytes.",
          "(E2) Indicates that a minimal ClientHello may contain only the supported_versions extension.",
          "(E3) Shows that a minimal supported_versions extension would be encoded in 7 bytes."
        ]
      },
      "fix_direction": "Either adjust the minimum length of ClientHello.extensions to 7 bytes for the sole supported_versions case or modify the supported_versions extension to meet the 8-byte minimum.",
      "severity": "Medium",
      "severity_basis": "This structural mismatch can cause interoperable implementations to either reject valid messages or generate messages that do not conform to the specified bounds.",
      "confidence": "High",
      "experts": [
        "Quantitative: Issue-1"
      ],
      "report_id": "draft-ietf-tls-rfc8446bis-14-4-3"
    },
    {
      "label": "Conflicting Requirements in SupportedVersions Handling",
      "bug_type": "Inconsistency",
      "explanation": "There are contradictory requirements for handling a ClientHello with a legacy_version of 0x0304 or later when the supported_versions extension is absent, with one clause mandating negotiation of TLS 1.2 and another clause permitting the handshake to be aborted.",
      "justification": [
        "Section 4.1.2 states: “A server which receives a legacy_version value not equal to 0x0303 MUST abort the handshake with an ‘illegal_parameter’ alert.”",
        "Section 4.2.1 instructs: “If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.”",
        "Immediately following, Section 4.2.1 adds: “Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.”"
      ],
      "evidence": {
        "snippets": [
          {
            "id": "E1",
            "text": "Section 4.1.2: “A server which receives a legacy_version value not equal to 0x0303 MUST abort the handshake with an ‘illegal_parameter’ alert.”"
          },
          {
            "id": "E2",
            "text": "Section 4.2.1: “If this extension is not present, servers which are compliant with this specification and which also support TLS 1.2 MUST negotiate TLS 1.2 or prior as specified in [RFC5246], even if ClientHello.legacy_version is 0x0304 or later.”"
          },
          {
            "id": "E3",
            "text": "Section 4.2.1: “Servers MAY abort the handshake upon receiving a ClientHello with legacy_version 0x0304 or later.”"
          }
        ],
        "summary": [
          "(E1) Imposes an unconditional abort for legacy_version values not equal to 0x0303.",
          "(E2) Requires that servers supporting TLS 1.2 negotiate TLS 1.2 when the supported_versions extension is absent.",
          "(E3) Provides a general permission to abort the handshake in the same scenario."
        ]
      },
      "fix_direction": "Clarify the text so that the MUST negotiate TLS 1.2 requirement applies exclusively to servers that support TLS 1.2, while the MAY abort option is limited to servers that do not support TLS 1.2, or otherwise harmonize the requirements to remove the contradiction.",
      "severity": "Medium",
      "severity_basis": "The conflicting requirements for version negotiation versus outright abortion can result in divergent behaviors among implementations when encountering non‐conformant ClientHello messages.",
      "confidence": "High",
      "experts": [
        "Causal: Non‑conformant Client Case",
        "CrossRFC: Issue-3"
      ],
      "report_id": "draft-ietf-tls-rfc8446bis-14-4-4"
    }
  ]
}