================================================================================
SYSTEM PROMPT
================================================================================

You are ErrataPacketizer.
Input: an analyzer output containing router analysis and multiple expert analyses.
Task: produce deduplicated errata reports as structured JSON.

Constraints:
- Read the ENTIRE analysis carefully from start to finish. Do not skip any sections.
- Extract ALL issues mentioned anywhere in the analysis, including:
  * candidate issues (even if marked as "candidate" or "potential")
  * Expert-identified issues (even if experts conclude "no issue" or "editorial only")
  * Issues discussed in expert reasoning sections, even if not in formal issue lists
  * Any inconsistencies, ambiguities, or problems mentioned in any part of the text
  * Issues labeled as "potential", "candidate", "may cause", "underspecification", or similar
- Only use information present in the input text.
- Labels must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (include specific terms, values, or section references when relevant).
- Evidence snippets (5a) must be copied verbatim from the input text (without quotes). Snippets must be complete and sufficient - include all relevant context needed to understand and verify the issue. Do not use partial snippets.
- Evidence summary (5b) must be derived ONLY from the evidence snippets E1..En and must cite (E#) per bullet.
- Deduplicate: merge issues that refer to the same underlying erratum and list all experts.
- Severity/Confidence: prefer explicit expert values; otherwise infer conservatively and state "inferred".

================================================================================
USER PROMPT
================================================================================

Read the ENTIRE analyzer output below carefully from start to finish. Extract ALL issues, problems, inconsistencies, or ambiguities mentioned anywhere in the text.

Include ALL issues mentioned in the analysis:
- Router candidate issues (even if marked "candidate" or "potential")
- Expert-identified issues (check all expert sections: Scope, Causal, Quantitative, Structural, CrossRFC, Terminology, etc.)
- Issues discussed in expert reasoning/analysis sections, even if not in formal issue lists
- Any inconsistencies, ambiguities, underspecifications, or problems mentioned anywhere
- Issues labeled as "potential", "candidate", "may cause", "editorial", "underspecification", or similar
- Do NOT skip issues just because an expert concludes "no issue" or "editorial only" - if it's discussed, include it

Produce deduplicated errata reports as JSON.

Each errata report MUST contain exactly these fields:
1) label: Errata short Label (must be explicit and descriptive - readers should understand the problem at a glance, e.g., "Misnamed LDAP/X.509 CA certificate attribute ("caCertificate" vs "cACertificate")")
2) bug_type: Bug Type
3) explanation: Concise Explanation (1-2 sentences, neutral)
4) justification: Justification (array of bullets, must be supported by Evidence snippets)
5) evidence: Object with:
   - snippets: Array of {id: "E1", text: "..."} (verbatim, complete and sufficient excerpts, no quotes around text)
   - summary: Array of strings, each citing (E1), (E2), etc.
6) fix_direction: Fix Direction if exists, else null
7) severity: Low | Medium | High | Unspecified
8) severity_basis: Basis for severity
9) confidence: High | Medium | Low | Unspecified
10) experts: Array of "ExpertName: issue_id" strings

Constraints:
- Label must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (e.g., include specific terms, section references, or conflicting values when relevant).
- Evidence snippets must be verbatim from input (format: text directly, no quotes).
- Evidence snippets must be complete and sufficient - include all relevant context needed to understand the issue.
- Evidence summary must cite (E1), (E2), ... and contain no new facts beyond snippets.
- Keep each errata report concise.

Analyzer output:
<<<
REASONING EXPERT ANALYSES
================================================================================

## Scope Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
ScopeAnalysis:
- ExcerptSummary: Section 5 (plus related earlier sections) defines how TLS is to be used with TACACS+, including port separation, TLS version/cipher policies, 0‑RTT prohibition, certificate handling, SNI, and wildcard usage; it mixes implementer requirements and operational guidance. The main subtle scope issue arises around how strictly wildcard certificates must be constrained to a “dedicated subdomain” and whether that constraint is a recommendation or a hard requirement, and for which kinds of TACACS+ servers it applies.

- ScopeModel:
  - Targets:
    - “TLS TACACS+ servers”: TACACS+ servers using TLS transport, defined as bound to a specific IP/hostname and port.
    - “Non‑TLS TACACS+ servers”: TACACS+ servers using the legacy, non‑TLS transport (obfuscation or cleartext) on port 49.
    - TACACS+ clients: devices initiating connections to configured TACACS+ servers, which choose ports, TLS options, and whether to fall back to non‑TLS.
    - TLS configuration artefacts: TLS versions, cipher suites, PSKs, and TLS extensions (especially SNI and early_data).
    - PKIX certificates and identifiers used for TLS TACACS+ servers and for client authentication (DNS‑ID, IP‑ID, SRV‑ID, wildcards per RFC 9525).
    - DNS subdomains that host TACACS+ services and that may be covered by wildcard certificates.
  - Conditions:
    - New production deployments vs migration/legacy deployments with both TLS and non‑TLS servers present (Section 5.1.1, 6.1, 6.2).
    - Whether a given server instance is a “TLS TACACS+ server” (listening on the TLS port and doing TLS from the start) vs a non‑TLS TACACS+ server (Section 2, 3.1, 3.2, 5.1.1).
    - Whether defaults (ports 49 and 300) are overridden by explicit configuration (Section 3.1, 5.2).
    - Whether wildcard certificates are used for TLS TACACS+ server identities, and where in the DNS namespace those wildcard names live (Sections 3.4.2, 5.1.6).
    - Whether TLS resumption and/or external PSKs are used (Sections 3.5, 3.6, 5.1.2).
    - Whether non‑TLS operation is globally disabled on a client or server via a configuration switch (Section 5.2).
  - NotedAmbiguities:
    - The same “dedicated subdomain” constraint on wildcard certificates is expressed with different normative strength and slightly different target sets (“TACACS+ servers” vs “TLS TACACS+ servers”) in Sections 3.4.2 and 5.1.6, creating uncertainty whether confinement to such a subdomain is a recommendation (with allowed exceptions) or an unconditional requirement.
    - Operational vs implementer subjects are sometimes blended (e.g., “Implementors must ensure that the configuration scheme… is straightforward” in Section 5.2 uses lower‑case “must” and mixes UI/UX guidance with wire‑protocol requirements), but this is more stylistic than strictly a scope bug.
    - TLS resumption text (“certificates must be verified to check for revocation during the period since the last NewSessionTicket Message”) does not clearly state whether this applies to all forms of PSK resumption (external PSKs vs ticket‑based), but it is non‑BCP14 “must” and does not directly affect protocol interoperability.

- CandidateIssues:
  - Issue-1:
    - BugType: Inconsistency
    - ShortLabel: Conflicting normative level and target scope for wildcard certificate subdomain restriction
    - ScopeProblemType: Overlapping but differently scoped requirements (SHOULD vs MUST; TACACS+ vs TLS TACACS+ servers) for the same wildcard‑subdomain confinement rule.
    - Evidence:
      - Section 3.4.2 (client‑side TLS server identity validation): “Wildcards in TLS TACACS+ server identities… introduce security risks… To address these risks, the guidelines in Section 6.3 of [RFC9525] MUST be followed, and the wildcard SHOULD be confined to a subdomain dedicated solely to TACACS+ servers.”
      - Section 5.1.6 (Server Identity Wildcards): “The use of wildcards in TLS server identities creates a single point of failure… Their use MUST follow the recommendations of Section 7.1 of [RFC9525]. Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.”
    - DetailedReasoning:
      1. Both sections address the same subject: use of wildcard names in TLS certificates for TACACS+ over TLS, and how their scope in DNS should be limited to reduce blast radius if a wildcard key is compromised.
      2. In Section 3.4.2, the text says the RFC9525 Section 6.3 rules “MUST” be followed (this aligns with RFC 9525’s own matching rules) and then adds a *new* constraint: “the wildcard SHOULD be confined to a subdomain dedicated solely to TACACS+ servers.” Here the BCP14 “SHOULD” clearly indicates a strong recommendation that still allows exceptions if an operator has a compelling reason.
      3. In Section 5.1.6, ostensibly a security‑considerations recap, the same configuration pattern is revisited with stronger language: “Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.” That moves the “dedicated subdomain” idea from a recommendation to a hard requirement, and narrows the subdomain’s content to TLS TACACS+ servers specifically.
      4. From a scope perspective, this yields two overlapping but non‑identical rules about *where* wildcard names may reside. Section 3.4.2’s “subdomain dedicated solely to TACACS+ servers” allows that the subdomain could contain both TLS and non‑TLS TACACS+ servers (as long as there are no unrelated services). Section 5.1.6’s “subdomain dedicated solely to TLS TACACS+ servers” would forbid non‑TLS TACACS+ servers in that same subdomain.
      5. Moreover, an implementer or operator reading Section 3.4.2 might reasonably conclude that placing wildcard names under such a dedicated subdomain is “only” a SHOULD‑level best practice, and that there might be justified deployments which do not meet it but are still compliant. Section 5.1.6, by contrast, frames it as an unconditional operator MUST, with no exceptions described.
      6. The document does not say that Section 5.1.6 is intentionally tightening or overriding the earlier SHOULD in Section 3.4.2, nor does it explain why exceptions that might be acceptable in 3.4.2 become categorically disallowed in 5.1.6. This leaves the intended normative scope unclear: is “dedicated subdomain” merely recommended or strictly mandatory?
      7. Because BCP14 keywords are used in both places, and because the underlying behavior (confining the wildcard to a dedicated TACACS+/TLS‑TACACS+ subdomain) is the same design pattern, implementers and operators cannot tell from the text whether a deployment that uses a wildcard spanning a broader subdomain is non‑compliant (violating the MUST in 5.1.6) or merely not following best practice (deviating from the SHOULD in 3.4.2).
      8. While an extremely strict reader could resolve the conflict by always following the stronger requirement (MUST in 5.1.6, which also implies the weaker SHOULD in 3.4.2), in practice this looks like an editorial oversight rather than a deliberate “tighten later” policy: the two sections cite different sub‑sections of RFC 9525 (6.3 vs 7.1) and use different subject phrases (“TACACS+ servers” vs “TLS TACACS+ servers”) without explanation.
      9. The net effect is a scope ambiguity: Is wildcard confinement to such a subdomain mandated for *all* TLS TACACS+ deployments, or only strongly recommended? And is the subdomain permitted to contain non‑TLS TACACS+ servers, or must it host only TLS TACACS+ servers? Different interpretations could lead to different deployment patterns, especially in mixed TLS/non‑TLS environments.
      10. An erratum could usefully align these sections by (a) choosing a single normative level (either both MUST or both SHOULD, with rationale) for the dedicated‑subdomain constraint and (b) clarifying whether the intended subdomain is “solely for TACACS+ servers (including TLS and non‑TLS variants)” or “solely for TLS TACACS+ servers,” so that the scope of permitted hostnames is unambiguous.

- ResidualUncertainties:
  - It is unclear whether the authors intended Section 5.1.6 to *upgrade* the earlier SHOULD in Section 3.4.2 to a universal MUST (i.e., retroactively banning all exceptions) or merely to restate the existing recommendation with stronger language. Clarification from the authors/IESG would help determine the correct final normative level.
  - The choice of “TACACS+ servers” vs “TLS TACACS+ servers” in the two sections might be intentional (to forbid co‑locating non‑TLS TACACS+ servers in the wildcard’s subdomain) or accidental; the current text does not make that design decision explicit.

[Used vector stores: vs_6958c1299d1881919236f07c8d11bc8e]

## Causal Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
1. **Summary**

Following RFC 9887 literally does not break the TACACS+/TLS protocol flow or interoperability. However, Section 5.1.6 contains a **normative requirement that is effectively impossible to satisfy and not operationally specified**: operators “MUST ensure” wildcard‑covered servers are “impervious to redirection” (including on‑path and DNS attacks). This is not something an operator can objectively achieve or even test, and no concrete mechanisms are mandated, so the requirement is not implementable in the normal IETF threat model.

---

2. **Causal Analysis**

**What the spec says in 5.1.6**

> “The use of wildcards in TLS server identities creates a single point of failure: a compromised private key of a wildcard certificate impacts all servers using it. Their use MUST follow the recommendations of Section 7.1 of [RFC9525]. Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers. Further, operators MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).”

Mechanistically, nothing in this paragraph changes the on‑wire behavior of TACACS+ over TLS. A conforming TACACS+ implementation:

- Uses TLS 1.3 with mutual authentication (certificates, PSKs, or RPKs).
- Validates certificates and service identity per RFC 9525 (DNS‑ID, IP‑ID, SRV‑ID, wildcard rules).    
- Then runs TACACS+ as application data.

Using a wildcard certificate here means: several TACACS+ servers share a single certificate/private key (e.g., `*.tacacs.example.com`). As RFC 9525 §7.1 explains, this is risky because compromise of one host compromises them all, but it is still a *normal* TLS setup.    

**What “impervious to redirection” would mean causally**

The RFC explicitly says operators:

> “MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).”

To interpret this literally in terms of behavior:

- The requirement is to ensure that TACACS+ traffic **cannot be redirected** to *any different server* by:
  - DNS cache poisoning, or
  - On‑path attacks (which, in IETF threat models, includes an active attacker who can rewrite routing, ARP, or other lower‑layer state).

But in a standard IP network model:

- A sufficiently powerful on‑path attacker can always:
  - Drop packets (DoS),
  - Reroute packets (e.g., via BGP/IGP hijack, ARP spoofing),
  - Terminate TCP on a host they control.
- TLS is explicitly *not* designed to prevent routing redirection; it is designed to ensure that **even if traffic is redirected**, the attacker cannot successfully impersonate the endpoint without the relevant key material.    

Thus:

- If the attacker does *not* possess the wildcard private key:
  - Redirection causes handshake failure, not session compromise. That is already guaranteed by TLS, with or without this 5.1.6 requirement.
- If the attacker *does* possess the wildcard private key (e.g., by compromising any server using it):
  - They can impersonate *any* host name covered by that wildcard, regardless of routing;
  - No amount of “anti‑redirection” at the IP/DNS layer can recover security, because TLS will validate the attacker’s certificate as legitimate for the service name.

So, from a cause‑and‑effect standpoint:

- The *real* critical property is: *limit the blast radius of a compromised wildcard key* (e.g., by using a dedicated subdomain and minimizing where that key is deployed), as discussed in RFC 9525 §7.1.    
- Being “impervious to redirection” in the face of an on‑path adversary is *not* achievable in general; the best one can do is reduce the attack surface (DNSSEC, pinned IPs, isolated management networks, etc.), but not guarantee imperviousness.

**Why this is an underspecified / impossible normative requirement**

1. **No concrete mechanism is specified.**  
   The document does not say *how* operators should make servers “impervious” to redirection, only gives examples of the *threats* (on‑path, DNS poisoning). There is no requirement to deploy DNSSEC, strict resolver pinning, static host files, management‑only networks, BGP security mechanisms, etc. Without such mechanisms, operators cannot translate the “MUST ensure” into any definite set of actions.

2. **The property is not achievable in the generic Internet threat model.**  
   Even if an operator deploys DNSSEC, ACLs, and separate management networks, they cannot *guarantee* that:

   - No router is ever compromised,
   - No internal L2/L3 infrastructure can ever be used for redirection,
   - No misconfiguration causes unintentional routing changes.

   Given that “on‑path attacks” are explicitly named, this requirement is equivalent to “MUST ensure that an on‑path attacker cannot redirect traffic”, which is impossible to guarantee; you can only design protocols (TLS) to remain secure *even if* redirection occurs.

3. **No observable compliance criterion.**  
   There is no way for an implementer or operator to *test* whether they have met “impervious to redirection”:

   - You can test “TLS client MUST NOT send early_data extension” by checking handshake traces.
   - You cannot test “impervious to redirection” because it depends on all possible future routing/DNS states and attackers’ capabilities.

4. **No interaction with other normative text that would make this concrete.**  
   The spec already normatively requires following RFC 9525 §7.1 for wildcard use   and BCP 195 / TLS 1.3 for TLS configuration.    
   Those documents *do not* impose a requirement of “imperviousness to redirection”; they talk about:

   - Constraining wildcard scope (single‑label, left‑most).    
   - Possibly disallowing wildcard certs in some profiles.    

   So RFC 9887 adds a new, much stronger requirement without the usual BCP‑style mitigation language (“SHOULD deploy X, Y, Z to reduce risk”), and without a defined mechanism.

**What happens if people try to follow it literally?**

- **Implementers**: There is nothing to implement in code; they just use standard TLS and certificate validation. So no code‑level failure occurs.
- **Operators**: 
  - Strictly speaking, *no realistic deployment can claim to “ensure imperviousness” against all on‑path/DNS redirection*. An honest operator trying to follow the RFC cannot know when they are compliant.
  - In practice, most will either:
    - Ignore the “impervious” phrasing as aspirational and do best‑effort mitigations; or
    - Treat wildcard certs as effectively forbidden because the requirement is unmeetable.

This doesn’t cause protocol malfunction, but it **undermines the normative clarity** of the document: a BCP 14 “MUST” cannot be satisfied or verified in a concrete sense.

---

3. **Problem Classification**

- **Type**: **Causal Underspecification / Unrealizable Normative Requirement**
- The problem is not that the wire protocol fails, but that a BCP 14 “MUST” is attached to an **undefined and, in the usual threat model, unattainable security property** (“impervious to redirection by on‑path/DNS attacks”), without specifying the mechanisms needed to come even close to that property.

---

4. **Minimal Fix Shape (Optional)**

A minimal, local repair that restores causal clarity would be to:

- Replace the absolute requirement with a requirement to deploy specific classes of mitigations, for example:

  - Change:  
    “Operators MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).”

  - To something like:  
    “Operators **MUST deploy mitigations to reduce the risk of redirection of traffic to unauthorized servers** (for example, operational controls to prevent DNS cache poisoning, BGP/IGP hijacking, or other on-path attacks) when using wildcard certificates.”

- Or downgrade to **SHOULD** and clarify that complete imperviousness cannot be guaranteed, aligning with the style of RFC 9525 §7.1 and other TLS security BCPs.

This would turn an impossible property into a concrete requirement to deploy certain defensive measures.

---

5. **Non-Issues**

- The other security‑related requirements in Section 5 (e.g., **MUST NOT** use TLS 0‑RTT early data, **MUST NOT** fall back from TLS to non‑TLS, use of separate ports 49 vs 300, etc.) are **mechanically implementable and well‑defined** given TLS 1.3 and RFC 8907. They do not introduce impossible states or undefined behavior in the TACACS+/TLS state machine.

[Used vector stores: vs_6958c1299d1881919236f07c8d11bc8e]

## Deontic Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
DeonticAnalysis:
- ExcerptSummary: Section 5 (plus related sections 3.4.2 and 5.1.6) of RFC 9887 defines security and operational requirements for using TACACS+ over TLS 1.3, including TLS usage policy, prohibition of 0‑RTT, port/configuration rules, downgrade protection, SNI use, and certificate/wildcard guidance. Most of the TLS profile is a straightforward tightening of TLS 1.3 and BCP 195. The main deontic tensions arise around the handling of wildcard certificates.

- OverallDeonticRisk: Medium

- Issues:

  - Issue-1:
    - BugType: Inconsistency
    - Title: Conflicting requirement levels for wildcard subdomain scoping
    - Description:  
      The document imposes two different normative strengths on essentially the same wildcard-scoping behavior. In Section 3.4.2, after requiring RFC 9525-style identity checking, the text says that “the guidelines in Section 6.3 of [RFC9525] MUST be followed, and the wildcard SHOULD be confined to a subdomain dedicated solely to TACACS+ servers.” This makes confining wildcard certificates to a dedicated TACACS+ subdomain a recommendation (SHOULD), explicitly allowing exceptions in some deployments. Later, in Section 5.1.6, the same underlying constraint is restated more strongly: “Their use MUST follow the recommendations of Section 7.1 of [RFC9525]. Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.” Here, scoping to a dedicated subdomain is a hard requirement (MUST) with no room for exceptions. The actors and context are effectively the same: operators deploying wildcard certificates for TLS TACACS+ servers. Under the earlier text, a deployment that reuses a wildcard for a broader set of hosts could still be compliant (though discouraged); under the later text, the same deployment is non‑compliant. Because these two statements are in the same RFC and apply to the same behavior without any explicit “upgrade” or conditional context, they create a real ambiguity about what is required for conformance.
    - KeyTextSnippets:
      - “Wildcards in TLS TACACS+ server identities … To address these risks, the guidelines in Section 6.3 of [RFC9525] MUST be followed, and the wildcard SHOULD be confined to a subdomain dedicated solely to TACACS+ servers.” (Section 3.4.2)
      - “The use of wildcards in TLS server identities creates a single point of failure… Their use MUST follow the recommendations of Section 7.1 of [RFC9525]. Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.” (Section 5.1.6)
    - Impact:  
      This inconsistency makes it unclear whether scoping wildcard certificates to a dedicated TACACS+-only subdomain is a recommendation that can be deviated from (SHOULD) or an unconditional requirement (MUST). Implementers, operators, and reviewers cannot reliably determine conformance, and security audits may reach inconsistent conclusions about whether a deployment that does not use a dedicated subdomain is “allowed but discouraged” or “non‑compliant”. An erratum should align these to a single requirement level or clearly scope the stronger requirement (e.g., to specific deployment classes).

  - Issue-2:
    - BugType: Underspecification
    - Title: Unrealistic and non‑implementable “MUST be impervious to redirection” requirement
    - Description:  
      Section 5.1.6 concludes with an absolute requirement: “Operators MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).” This gives operators a normative obligation to achieve *imperviousness* to traffic redirection attacks arising from on‑path adversaries or DNS poisoning. In a general IP network, this is not a realistically satisfiable or testable requirement: no finite set of operational measures can guarantee that servers are “impervious” to such attacks, only that risk is reduced (e.g., via DNSSEC, strict hostname/certificate checks, pinning, etc.). Moreover, the RFC does not specify any concrete set of mechanisms that, if deployed, would count as satisfying this MUST. As a result, even a careful operator cannot objectively determine whether they are in compliance with this clause. Compared with RFC 9525 Section 7.1—which discusses risks and mitigations for wildcards but does not purport to guarantee complete resistance—this text overshoots into an absolute, underdefined requirement.
    - KeyTextSnippets:
      - “Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.” (Section 5.1.6)
      - “Further, operators MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).” (Section 5.1.6)
    - Impact:  
      Because “impervious to redirection” is both practically unachievable in the general Internet threat model and left undefined in terms of concrete countermeasures, this clause cannot be meaningfully implemented or audited. Different implementers and operators will interpret the requirement differently (or ignore it), leading to inconsistent security postures and confusion about what the standard actually demands. A minimal fix would be to weaken and operationalize the requirement (e.g., “MUST deploy mitigations such as … to reduce the risk of redirection attacks when using wildcard certificates”) instead of demanding absolute imperviousness.

[Used vector stores: vs_6958c1299d1881919236f07c8d11bc8e]

## CrossRFC Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
CrossRFCReport:
- ExcerptSummary: Section 5 of RFC 9887 profiles TLS 1.3 for TACACS+ and gives security/operational guidance, with specific references to TLS 1.3 (RFC 8446), SNI (RFC 6066), service identity and wildcards (RFC 9525), and PSK guidance (RFC 9257). Most of these references are consistent and intentionally stricter than the base specs, but there are some internal inconsistencies and one underspecified, effectively unachievable normative requirement around wildcard use.
- OverallCrossRFCLikelihood: Medium
- Issues:
  - Issue-1:
    - BugType: Inconsistency
    - ShortLabel: Conflicting strength on wildcard subdomain confinement vs RFC 9525 profile
    - Description: Section 3.4.2 of RFC 9887 states that for wildcard server identities “the guidelines in Section 6.3 of [RFC9525] MUST be followed, and the wildcard SHOULD be confined to a subdomain dedicated solely to TACACS+ servers.” This profiles RFC 9525’s DNS name and wildcard-matching rules in Section 6.3 and adds a **SHOULD**-level recommendation about scoping the wildcard to a dedicated subdomain. Later, Section 5.1.6 states: “Their use MUST follow the recommendations of Section 7.1 of [RFC9525]. Operators MUST ensure that the wildcard is limited to a subdomain dedicated solely to TLS TACACS+ servers.” RFC 9525 Section 7.1 discusses the risks of wildcard certificates and recommends mitigations but does not itself impose a requirement to confine wildcards to a dedicated subdomain; that scoping rule is introduced by RFC 9887. In practice, one part of RFC 9887 treats subdomain confinement as a **SHOULD** (3.4.2) while another treats essentially the same behavior as a **MUST** (5.1.6), without clarifying that the latter is intentionally tightening the requirement or aimed at a different actor. An implementer or operator attempting to claim compliance with RFC 9887 could reasonably be uncertain whether subdomain confinement is optional-but-recommended or strictly mandatory in all deployments. I partly agree with the router’s hypothesis: the section references to RFC 9525 (6.3 for matching rules, 7.1 for security considerations) are appropriate, but the internal SHOULD vs MUST on the same wildcard scoping rule is a real inconsistency.
    - EntitiesInvolved: ["RFC 9887 Section 3.4.2", "RFC 9887 Section 5.1.6", "RFC 9525 Section 6.3", "RFC 9525 Section 7.1", "Wildcard DNS-IDs for TLS TACACS+ servers"]
    - CrossRefsUsed: ["RFC 9525 §6.3 rules for DNS name and wildcard matching", "RFC 9525 §7.1 security discussion of wildcard certificates"]
    - Confidence: High
  - Issue-2:
    - BugType: Underspecification
    - ShortLabel: Unimplementable “impervious to redirection” requirement for wildcard deployments
    - Description: Section 5.1.6 says: “Operators MUST ensure that the TLS TACACS+ servers covered by a wildcard certificate are impervious to redirection of traffic to a different server (for example, due to on-path attacks or DNS cache poisoning).” In contrast, RFC 9525 Section 7.1, which is cited in the same paragraph, describes specific risks of wildcard certificates and points to following “strict TLS guidelines” (TLS-REC) and other best practices; it does not claim that deployments can or must be absolutely “impervious” to on-path attacks or DNS poisoning. RFC 8446 and related BCPs likewise talk about downgrade and redirection mitigations, not absolute prevention. By using a normative **MUST** tied to an absolute condition (“impervious to redirection”) without specifying concrete, testable mechanisms (e.g., DNSSEC, pinning, specific hostname-validation or SNI policies), RFC 9887 creates a requirement that operators cannot objectively verify or realistically guarantee on a general IP network. Different implementers or operators could interpret “impervious” very differently (ranging from “deploy some mitigations” to “literally impossible to redirect traffic under any circumstances”), leading to divergent security postures while all claim compliance. I agree with the router’s assessment that this is underspecified and not clearly grounded in the concrete, achievable guidance given in RFC 9525 §7.1 and related TLS BCPs.
    - EntitiesInvolved: ["RFC 9887 Section 5.1.6", "RFC 9525 Section 7.1", "Wildcard certificates for TLS TACACS+ servers", "On-path attacks and DNS cache poisoning"]
    - CrossRefsUsed: ["RFC 9525 §7.1 wildcard certificate security notes and reference to strict TLS guidelines"]
    - Confidence: High

[Used vector stores: vs_6958c1299d1881919236f07c8d11bc8e]


Vector Stores Used: vs_6958c1299d1881919236f07c8d11bc8e
>>>

Return JSON array of errata reports:
{
  "reports": [
    {
      "label": "...",
      "bug_type": "...",
      "explanation": "...",
      "justification": ["...", "..."],
      "evidence": {
        "snippets": [
          {"id": "E1", "text": "..."}
        ],
        "summary": ["(E1) ...", "(E2) ..."]
      },
      "fix_direction": "..." or null,
      "severity": "...",
      "severity_basis": "...",
      "confidence": "...",
      "experts": ["..."]
    }
  ]
}