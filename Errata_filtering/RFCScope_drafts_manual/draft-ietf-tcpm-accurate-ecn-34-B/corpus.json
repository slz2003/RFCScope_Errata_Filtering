[
  {
    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
    "rfc_title": "Updates: 3168 (if approved)                                 M. K\u00fchlewind",
    "content": "1. Introduction\n\n   Explicit Congestion Notification (ECN) [RFC3168] is a mechanism where\n   network nodes can mark IP packets instead of dropping them to\n   indicate incipient congestion to the endpoints.  Receivers with an\n   ECN-capable transport protocol feed back this information to the\n   sender.  In RFC 3168, ECN was specified for TCP in such a way that\n   only one feedback signal could be transmitted per Round-Trip Time\n   (RTT).  This is sufficient for congestion control scheme like Reno\n   [RFC6582] and Cubic [RFC9438], as those schemes reduce their\n   congestion window by a fixed factor if congestion occurs within an\n   RTT independent of the number of received congestion markings.\n   Recently, proposed mechanisms like Congestion Exposure (ConEx\n   [RFC7713]), DCTCP [RFC8257] or L4S [RFC9330] need to know when more\n   than one marking is received in one RTT, which is information that\n   cannot be provided by the feedback scheme as specified in [RFC3168].\n   This document specifies an update to the ECN feedback scheme of RFC \n   3168 that provides more accurate information and could be used by\n   these and potentially other future TCP extensions, while still also\n   supporting the pre-existing TCP congestion controllers that use just\n   one feedback signal per round.  Congestion control is the term the\n   IETF uses to describe data rate management.  It is the algorithm that\n   a sender uses to optimize its sending rate so that it transmits data\n   as fast as the network can carry it, but no faster.  A fuller\n   treatment of the motivation for this specification is given in the\n   associated requirements document [RFC7560].\n\n   This document specifies a standards track scheme for ECN feedback in\n   the TCP header to provide more than one feedback signal per RTT.  It\n   will be called the more Accurate ECN feedback scheme, or AccECN for\n   short.  This document updates RFC 3168 with respect to negotiation\n   and use of the feedback scheme for TCP.  All aspects of RFC 3168   other than the TCP feedback scheme and its negotiation remain\n   unchanged by this specification.  In particular the definition of ECN\n   at the IP layer is unaffected.  Section 4 gives a more detailed\n   specification of exactly which aspects of RFC 3168 this document\n   updates. \n   This document uses the term Classic ECN feedback when it needs to\n   distinguish the TCP/ECN feedback scheme defined in [RFC3168] from the\n   AccECN TCP feedback scheme.  AccECN is intended to offer a complete\n   replacement for Classic TCP/ECN feedback, not a fork in the design of\n   TCP.  AccECN feedback complements TCP's loss feedback and it can\n   coexist alongside hosts using Classic TCP/ECN feedback.  So its\n   applicability is intended to include the public Internet as well as\n   private IP network such as data centres (and even any non-IP networks\n   over which TCP is used), whether or not any nodes on the path support\n   ECN, of whatever flavour.\n\n   AccECN feedback overloads the two existing ECN flags in the TCP\n   header and allocates the currently reserved flag (previously called\n   NS) in the TCP header, to be used as one three-bit counter field for\n   feeding back the number of packets marked as congestion experienced\n   (CE).  Given the new definitions of these three bits, both ends have\n   to support the new wire protocol before it can be used.  Therefore,\n   during the TCP handshake, the two ends use these three bits in the\n   TCP header to negotiate the most advanced feedback protocol that they\n   can both support, in a way that is backward compatible with\n   [RFC3168].\n\n   AccECN is solely a change to the TCP wire protocol; it covers the\n   negotiation and signaling of more Accurate ECN feedback from a TCP\n   Data Receiver to a Data Sender.  It is completely independent of how\n   TCP might respond to congestion feedback, which is out of scope, but\n   ultimately the motivation for Accurate ECN feedback.  Like Classic\n   ECN feedback, AccECN can be used by standard Reno or CUBIC congestion\n   control [RFC5681] [RFC9438] to respond to the existence of at least\n   one congestion notification within a round trip.  Or, unlike Reno or\n   CUBIC, AccECN can be used to respond to the extent of congestion\n   notification over a round trip, as for example DCTCP does in\n   controlled environments [RFC8257].  For congestion response, this\n   specification refers to the original ECN specificiation adopted in\n   2001 [RFC3168], as updated by the more relaxed rules introduced in\n   2018 to allow ECN experiments [RFC8311], namely: a TCP-based Low\n   Latency Low Loss Scalable (L4S) congestion control [RFC9330]; or\n   Alternative Backoff with ECN (ABE) [RFC8511]. Section 5.2 explains how AccECN is compatible with current commonly\n   used TCP options, and a number of current experimental modifications\n   to TCP, as well as SYN cookies.\n\n1.1. Document Roadmap\n\n   The following introductory section outlines the goals of AccECN\n   (Section 1.2).  Then, terminology is defined (Section 1.3) and a\n   recap of existing prerequisite technology is given (Section 1.4). \n\n\n\n   Section 2 gives an informative overview of the AccECN protocol.  Then Section 3 gives the normative protocol specification, and Section 3.3   collects together requirements for proxies, offload engines and other\n   middleboxes.  Section 4 clarifies which aspects of RFC 3168 are\n   updated by AccECN.  Section 5 assesses the interaction of AccECN with\n   commonly used variants of TCP, whether standardized or not.  Then Section 6 summarizes the features and properties of AccECN. Section 7 summarizes the protocol fields and numbers that IANA will\n   need to assign and Section 8 points to the aspects of the protocol\n   that will be of interest to the security community. Appendix A  gives pseudocode examples for the various algorithms that\n   AccECN uses and Appendix B  explains why AccECN uses flags in the main\n   TCP header and quantifies the space left for future use.\n\n\n1.2. Goals\n\n   [RFC7560] enumerates requirements that a candidate feedback scheme\n   will need to satisfy, under the headings: resilience, timeliness,\n   integrity, accuracy (including ordering and lack of bias),\n   complexity, overhead and compatibility (both backward and forward).\n   It recognizes that a perfect scheme that fully satisfies all the\n   requirements is unlikely and trade-offs between requirements are\n   likely.  Section 6 presents the properties of AccECN against these\n   requirements and discusses the trade-offs made.\n\n   The requirements document recognizes that a protocol as ubiquitous as\n   TCP needs to be able to serve as-yet-unspecified requirements.\n   Therefore an AccECN receiver acts as a generic (mechanistic)\n   reflector of congestion information with the aim that in future new\n   sender behaviours can be deployed unilaterally (see Section 2.5).\n\n\n1.3. Terminology\n\n   AccECN:  The more Accurate ECN feedback scheme will be called AccECN\n      for short.\n\n   Classic ECN:  The ECN protocol specified in [RFC3168].\n\n   Classic ECN feedback:  The feedback aspect of the ECN protocol\n      specified in [RFC3168], including generation, encoding,\n      transmission and decoding of feedback, but not the Data Sender's\n      subsequent response to that feedback.\n\n   ACK:  A TCP acknowledgement, with or without a data payload (ACK=1).\n\n   Pure ACK:  A TCP acknowledgement without a data payload. \n   Acceptable packet / segment:  A packet or segment that passes the\n      acceptability tests in [RFC9293] and [RFC5961], or that has passed\n      other tests with equivalent protection.\n\n   TCP Client:  The TCP stack that originates a connection (the\n      initiator).\n\n   TCP Server:  The TCP stack that responds to a connection request (the\n      listener).\n\n   Three-way handshake:  The procedure used to establish a TCP\n      connection as described in the TCP protocol specification\n      [RFC9293].\n\n   Data Receiver:  The endpoint of a TCP half-connection that receives\n      data and sends AccECN feedback.\n\n   Data Sender:  The endpoint of a TCP half-connection that sends data\n      and receives AccECN feedback.\n\n   In a mild abuse of terminology, this document sometimes refers to\n   'TCP packets' instead of 'TCP segments'.\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP \n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.\n\n\n1.4. Recap of Existing ECN feedback in IP/TCP\n\n   Explicit Congestion Notification (ECN) [RFC3168] can be split into\n   two parts conceptionally.  In the forward direction, alongside the\n   data stream, it uses a two-bit field in the IP header.  This is\n   referred to as IP-ECN later on.  This signal carried in the IP (Layer\n   3) header is exposed to network devices and may be modified when such\n   a device starts to experience congestion (see Table 1).  The second\n   part is the feedback mechanism, by which the original data sender is\n   notified of the current congestion state of the intermediate path.\n   That returned signal is carried in a protocol specific manner, and is\n   not to be modified by intermediate network devices.  While ECN is in\n   active use for protocols such as QUIC [RFC9000], SCTP [RFC9260], RTP\n   [RFC6679] and Remote Direct Memory Access over Converged Ethernet\n   [RoCEv2], this document only concerns itself with the specific\n   implementation for the TCP protocol. \n   Once ECN has been negotiated for a transport layer connection, the\n   Data Sender for either half-connection can set two possible\n   codepoints (ECT(0) or ECT(1)) in the IP header of a data packet to\n   indicate an ECN-capable transport (ECT).  If the ECN codepoint is\n   0b00, the packet is considered to have been sent by a Not ECN-capable\n   Transport (Not-ECT).  When a network node experiences congestion, it\n   will occasionally either drop or mark a packet, with the choice\n   depending on the packet's ECN codepoint.  If the codepoint is Not-\n   ECT, only drop is appropriate.  If the codepoint is ECT(0) or ECT(1),\n   the node can mark the packet by setting the ECN codepoint to 0b11,\n   which is termed 'Congestion Experienced' (CE), or loosely a\n   'congestion mark'.  Table 1 summarises these codepoints.\n\n     +==================+================+===========================+\n     | IP-ECN codepoint | Codepoint name | Description               |\n     +==================+================+===========================+\n     | 0b00             | Not-ECT        | Not ECN-Capable Transport |\n     +------------------+----------------+---------------------------+\n     | 0b01             | ECT(1)         | ECN-Capable Transport (1) |\n     +------------------+----------------+---------------------------+\n     | 0b10             | ECT(0)         | ECN-Capable Transport (0) |\n     +------------------+----------------+---------------------------+\n     | 0b11             | CE             | Congestion Experienced    |\n     +------------------+----------------+---------------------------+\n\n                  Table 1: The ECN Field in the IP Header\n\n   In the TCP header the first two bits in byte 14 (the TCP header flags\n   at bit offsets 8 and 9 labelled Congestion Window Reduced (CWR) and\n   Explicit Congestion notification Echo (ECE) in Figure 1) are defined\n   as flags for the use of Classic ECN [RFC3168].  A TCP Client\n   indicates that it supports Classic ECN feedback by setting (CWR,ECE)\n   = (1,1) in the SYN, and an ECN-enabled TCP Server confirms Classic\n   ECN support by setting (CWR,ECE) = (0,1) in the SYN/ACK.  On\n   reception of a CE-marked packet at the IP layer, the Data Receiver\n   for that half-connection starts to set the Echo Congestion\n   Experienced (ECE) flag continuously in the TCP header of ACKs, which\n   gives the signal resilience to loss or reordering of ACKs.  The Data\n   Sender for the same half-connection confirms that it has received at\n   least one ECE signal by responding with the congestion window reduced\n   (CWR) flag, which allows the Data Receiver to stop repeating the ECN-\n   Echo flag.  This always leads to a full RTT of ACKs with ECE set.\n   Thus Classic ECN cannot feed back any additional CE markings arriving\n   within this RTT.\n\n   The last bit in byte 13 of the TCP header (the TCP header flag at bit\n   offset 7 in Figure 1) was defined as the Nonce Sum (NS) for the ECN\n   Nonce [RFC3540].  In the absence of widespread deployment RFC 3540\n\n\n\n\n   has been reclassified as historic [RFC8311] and the respective flag\n   has been marked as \"reserved\", making this TCP flag available for use\n   by AccECN instead.\n\n\n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           | N | C | E | U | A | P | R | S | F |\n     | Header Length | Reserved  | S | W | C | R | C | S | S | Y | I |\n     |               |           |   | R | E | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 1: TCP header flags as defined before the Nonce Sum flag\n                            reverted to Reserved\n\n\n2. AccECN Protocol Overview and Rationale\n\n   This section provides an informative overview of the AccECN protocol\n   that will be normatively specified in Section 3   Like the general TCP approach, the Data Receiver of each TCP half-\n   connection sends AccECN feedback to the Data Sender on TCP\n   acknowledgements, reusing data packets of the other half-connection\n   whenever possible.\n\n   The AccECN protocol has had to be designed in two parts:\n\n   *  an essential feedback part that re-uses the TCP-ECN header bits\n      for the Data Receiver to feed back the number of packets arriving\n      with CE in the IP-ECN field.  This provides more accuracy than\n      Classic ECN feedback, but limited resilience against ACK loss;\n\n   *  a supplementary feedback part using one of two new alternative\n      AccECN TCP options that provide additional feedback on the number\n      of payload bytes that arrive marked with each of the three ECN\n      codepoints in the IP-ECN field (not just CE marks).  See the BCP\n      on Byte and Packet Congestion Notification [RFC7141] for the\n      rationale determining that conveying congested payload bytes\n      should be preferred over just providing feedback about congested\n      packets.  This also provides greater resilience against ACK loss\n      than the essential feedback, but it is currently more likely to\n      suffer from middlebox interference.\n\n   The two part design was necessary, given limitations on the space\n   available for TCP options and given the possibility that certain\n   incorrectly designed middleboxes might prevent TCP using any new\n   options. \n   The essential feedback part overloads the previous definition of the\n   three flags in the TCP header that had been assigned for use by\n   Classic ECN.  This design choice deliberately allows AccECN peers to\n   replace the Classic ECN feedback protocol, rather than leaving\n   Classic ECN feedback intact and adding more accurate feedback\n   separately because:\n\n   *  this efficiently reuses scarce TCP header space, given TCP option\n      space is approaching saturation;\n\n   *  a single upgrade path for the TCP protocol is preferable to a fork\n      in the design which modifies the TCP header to convey all ECN\n      feedback;\n\n   *  otherwise Classic and Accurate ECN feedback could give conflicting\n      feedback about the same segment, which could open up new security\n      concerns and make implementations unnecessarily complex;\n\n   *  middleboxes are more likely to faithfully forward the TCP ECN\n      flags than newly defined areas of the TCP header.\n\n   AccECN is designed to work even if the supplementary feedback part is\n   removed or zeroed out, as long as the essential feedback part gets\n   through.\n\n2.1. Capability Negotiation\n\n   AccECN is a change to the wire protocol of the main TCP header,\n   therefore it can only be used if both endpoints have been upgraded to\n   understand it.  The TCP Client signals support for AccECN on the\n   initial SYN of a connection and the TCP Server signals whether it\n   supports AccECN on the SYN/ACK.  The TCP flags on the SYN that the\n   TCP Client uses to signal AccECN support have been carefully chosen\n   so that a TCP Server will interpret them as a request to support the\n   most recent variant of ECN feedback that it supports.  Then the TCP\n   Client falls back to the same variant of ECN feedback.\n\n   An AccECN TCP Client does not send an AccECN Option on the SYN as SYN\n   option space is limited.  The TCP Server sends an AccECN Option on\n   the SYN/ACK and the TCP Client sends one on the first ACK to test\n   whether the network path forwards these options correctly. \n\n\n\n\n\n\n2.2. Feedback Mechanism\n\n   A Data Receiver maintains four counters initialized at the start of\n   the half-connection.  Three count the number of arriving payload\n   bytes marked CE, ECT(1) and ECT(0) in the IP-ECN field.  These byte\n   counters reflect only the TCP payload length, excluding the TCP\n   header and TCP options.  The fourth counter counts the number of\n   packets arriving marked with a CE codepoint (including control\n   packets without payload if they are CE-marked).\n\n   The Data Sender maintains four equivalent counters for the half\n   connection, and the AccECN protocol is designed to ensure they will\n   match the values in the Data Receiver's counters, albeit after a\n   little delay.\n\n   Each ACK carries the three least significant bits (LSBs) of the\n   packet-based CE counter using the ECN bits in the TCP header, now\n   renamed the Accurate ECN (ACE) field (see Figure 3 later).  The 24\n   LSBs of some or all of the byte counters can be optionally carried in\n   an AccECN Option.  For efficient use of limited option space, two\n   alternative forms of AccECN Option are specified with the fields in\n   the opposite order to each other.\n\n\n2.3. Delayed ACKs and Resilience Against ACK Loss\n\n   With both the ACE and the AccECN Option mechanisms, the Data Receiver\n   continually repeats the current LSBs of each of its respective\n   counters.  There is no need to acknowledge these continually repeated\n   counters, so the congestion window reduced (CWR) mechanism of\n   [RFC3168] is no longer used.  Even if some ACKs are lost, the Data\n   Sender ought to be able to infer how much to increment its own\n   counters, even if the protocol field has wrapped.\n\n   The 3-bit ACE field can wrap fairly frequently.  Therefore, even if\n   it appears to have incremented by one (say), the field might have\n   actually cycled completely then incremented by one.  The Data\n   Receiver is not allowed to delay sending an ACK to such an extent\n   that the ACE field would cycle.  However ACKs received at the Data\n   Sender could still cycle because a whole sequence of ACKs carrying\n   intervening values of the field might all be lost or delayed in\n   transit.\n\n   The fields in an AccECN Option are larger, but they will increment in\n   larger steps because they count bytes not packets.  Nonetheless,\n   their size has been chosen such that a whole cycle of the field would\n   never occur between ACKs unless there had been an infeasibly long\n   sequence of ACK losses.  Therefore, provided that an AccECN Option is\n   available, it can be treated as a dependable feedback channel. \n   If an AccECN Option is not available, e.g., it is being stripped by a\n   middlebox, the AccECN protocol will only feed back information on CE\n   markings (using the ACE field).  Although not ideal, this will be\n   sufficient, because it is envisaged that neither ECT(0) nor ECT(1)\n   will ever indicate more severe congestion than CE, even though future\n   uses for ECT(0) or ECT(1) are still unclear [RFC8311].  Because the\n   3-bit ACE field is so small, when it is the only field available, the\n   Data Sender has to interpret it assuming the most likely wrap, but\n   with a degree of conservatism.\n\n   Certain specified events trigger the Data Receiver to include an\n   AccECN Option on an ACK.  The rules are designed to ensure that the\n   order in which different markings arrive at the receiver is\n   communicated to the sender (as long as options are reaching the\n   sender and as long as there is no ACK loss).  Implementations are\n   encouraged to send an AccECN Option more frequently, but this is left\n   up to the implementer.\n\n\n2.4. Feedback Metrics\n\n   The CE packet counter in the ACE field and the CE byte counter in\n   AccECN Options both provide feedback on received CE-marks.  The CE\n   packet counter includes control packets that do not have payload\n   data, while the CE byte counter solely includes marked payload bytes.\n   If both are present, the byte counter in an AccECN Option will\n   provide the more accurate information needed for modern congestion\n   control and policing schemes, such as L4S, DCTCP or ConEx.  If AccECN\n   Options are stripped, a simple algorithm to estimate the number of\n   marked bytes from the ACE field is given in Appendix A.3.\n\n   The AccECN design has been generalized so that it ought to be able to\n   support possible future uses of the experimental ECT(1) codepoint\n   other than the L4S experiment [RFC9330], such as a lower severity or\n   a more instant congestion signal than CE.\n\n   Feedback in bytes is provided to protect against the receiver or a\n   middlebox using attacks similar to 'ACK-Division' to artificially\n   inflate the congestion window, which is why [RFC5681] now recommends\n   that TCP counts acknowledged bytes not packets.\n\n\n2.5. Generic (Mechanistic) Reflector\n\n   The ACE field provides feedback about CE markings in the IP-ECN field\n   of both data and control packets.  According to [RFC3168] the Data\n   Sender is meant to set the IP-ECN field of control packets to Not-\n   ECT.  However, mechanisms in certain private networks (e.g., data\n   centres) set control packets to be ECN capable because they are\n   precisely the packets that performance depends on most. \n   For this reason, AccECN is designed to be a generic reflector of\n   whatever ECN markings it sees, whether or not they are compliant with\n   a current standard.  Then as standards evolve, Data Senders can\n   upgrade unilaterally without any need for receivers to upgrade too.\n\n   It is also useful to be able to rely on generic reflection behaviour\n   when senders need to test for unexpected interference with markings\n   (for instance Section 3.2.2.3, Section 3.2.2.4 and Section 3.2.3.2 of\n   the present document and paragraph 2 of Section 20.2 of [RFC3168]).\n\n   The initial SYN and SYN/ACK are the most critical control packets, so\n   AccECN feeds back their IP-ECN fields.  Although RFC 3168 prohibits\n   ECN-capable SYNs and SYN/ACKs, providing feedback of ECN marking on\n   the SYN and SYN/ACK supports future scenarios in which SYNs might be\n   ECN-enabled (without prejudging whether they ought to be).  For\n   instance, [RFC8311] updates this aspect of RFC 3168 to allow\n   experimentation with ECN-capable TCP control packets.\n\n   Even if the TCP Client (or Server) has set the SYN (or SYN/ACK) to\n   not-ECT in compliance with RFC 3168, feedback on the state of the IP-\n   ECN field when it arrives at the receiver could still be useful,\n   because middleboxes have been known to overwrite the IP-ECN field as\n   if it is still part of the old Type of Service (ToS) field\n   [Mandalari18].  For example, if a TCP Client has set the SYN to Not-\n   ECT, but receives feedback that the IP-ECN field on the SYN arrived\n   with a different codepoint, it can detect such middlebox\n   interference.  Previously, neither end knew what IP-ECN field the\n   other had sent.  So, if a TCP Server received ECT or CE on a SYN, it\n   could not know whether it was invalid because only the TCP Client\n   knew whether it originally marked the SYN as Not-ECT (or ECT).\n   Therefore, prior to AccECN, the Server's only safe course of action\n   in this example was to disable ECN for the connection.  Instead, the\n   AccECN protocol allows the Server and Client to feed back the ECN\n   field received on the SYN and SYN/ACK to their peer, which then has\n   all the information to decide whether the connection has to fall-back\n   from supporting ECN (or not).\n\n\n3. AccECN Protocol Specification\n\n\n\n\n\n3.1. Negotiating to use AccECN\n\n\n\n\n\n\n3.1.1. Negotiation during the TCP three-way handshake\n\n   Given the ECN Nonce [RFC3540] has been reclassified as historic\n   [RFC8311], the TCP flag that was previously called NS (Nonce Sum) is\n   renamed as the AE (Accurate ECN) flag (the TCP header flag at bit\n   offset 7 in Figure 2).  See the IANA Considerations in Section 7. \n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           | A | C | E | U | A | P | R | S | F |\n     | Header Length | Reserved  | E | W | C | R | C | S | S | Y | I |\n     |               |           |   | R | E | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 2: The new definition of the TCP header flags during the\n                          TCP three-way handshake\n\n   During the TCP three-way handshake at the start of a connection, to\n   request more Accurate ECN feedback the TCP Client (host A) MUST set\n   the TCP flags (AE,CWR,ECE) = (1,1,1) in the initial SYN segment.\n\n   If a TCP Server (host B) that is AccECN-enabled receives a SYN with\n   the above three flags set, it MUST set both its half connections into\n   AccECN mode.  Then it MUST set the AE, CWR and ECE TCP flags on the\n   SYN/ACK to the combination in the top block of Table 2 that feeds\n   back the IP-ECN field that arrived on the SYN.  This applies whether\n   or not the Server itself supports setting the IP-ECN field on a SYN\n   or SYN/ACK (see Section 2.5 for rationale).\n\n   When the TCP Server returns any of the 4 combinations in the top\n   block of Table 2, it confirms that it supports AccECN.  The TCP\n   Server MUST NOT set one of these 4 combination of flags on the SYN/\n   ACK unless the preceding SYN requested support for AccECN as above.\n\n   Once a TCP Client (A) has sent the above SYN to declare that it\n   supports AccECN, and once it has received the above SYN/ACK segment\n   that confirms that the TCP Server supports AccECN, the TCP Client\n   MUST set both its half connections into AccECN mode.  The TCP Client\n   MUST NOT enter AccECN mode (or any feedback mode) before it has\n   received the first SYN/ACK.\n\n   Once in AccECN mode, a TCP Client or Server has the rights and\n   obligations to participate in the ECN protocol defined in Section 3.1.5.\n\n   The procedures to follow for retransmission of SYNs or SYN/ACKs are\n   given in Section 3.1.4.\n\n   It is RECOMMENDED that the AccECN protocol is implemented alongside\n   Selective Acknowledgement (SACK) [RFC2018].  If SACK is implemented\n   with AccECN, Duplicate Selective Acknowledgement (D-SACK) [RFC2883]\n   MUST also be implemented. \n\n\n\n\n\n\n3.1.2. Backward Compatibility\n\n   The three flags set to 1 to indicate AccECN support on the SYN have\n   been carefully chosen to enable natural fall-back to prior stages in\n   the evolution of ECN.  Table 2 tabulates all the negotiation\n   possibilities for ECN-related capabilities that involve at least one\n   AccECN-capable host.  The entries in the first two columns have been\n   abbreviated, as follows:\n\n   AccECN:  Supports more Accurate ECN Feedback (the present\n       specification)\n\n   Nonce:  Supports ECN Nonce feedback [RFC3540]\n\n   ECN:  Supports 'Classic' ECN feedback [RFC3168]\n\n   No ECN:  Not ECN-capable.  Implicit congestion notification using\n       packet drop.\n\n   +========+========+============+============+======================+\n   | Host A | Host B |    SYN     |  SYN/ACK   | Feedback Mode        |\n   |        |        |    A->B    |    B->A    | of Host A            |\n   |        |        | AE CWR ECE | AE CWR ECE |                      |\n   +========+========+============+============+======================+\n   | AccECN | AccECN | 1   1   1  | 0   1   0  | AccECN (Not-ECT SYN) |\n   | AccECN | AccECN | 1   1   1  | 0   1   1  | AccECN (ECT1 on SYN) |\n   | AccECN | AccECN | 1   1   1  | 1   0   0  | AccECN (ECT0 on SYN) |\n   | AccECN | AccECN | 1   1   1  | 1   1   0  | AccECN (CE on SYN)   |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | AccECN | Nonce  | 1   1   1  | 1   0   1  | (Reserved)           |\n   | AccECN | ECN    | 1   1   1  | 0   0   1  | Classic ECN          |\n   | AccECN | No ECN | 1   1   1  | 0   0   0  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | Nonce  | AccECN | 0   1   1  | 0   0   1  | Classic ECN          |\n   | ECN    | AccECN | 0   1   1  | 0   0   1  | Classic ECN          |\n   | No ECN | AccECN | 0   0   0  | 0   0   0  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | AccECN | Broken | 1   1   1  | 1   1   1  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n\n        Table 2: ECN capability negotiation between Client (A) and\n                                Server (B)\n\n   Table 2 is divided into blocks each separated by an empty row. \n   1.  The top block shows the case already described in Section 3.1       where both endpoints support AccECN and how the TCP Server (B)\n       indicates congestion feedback.\n\n   2.  The second block shows the cases where the TCP Client (A)\n       supports AccECN but the TCP Server (B) supports some earlier\n       variant of TCP feedback, indicated in its SYN/ACK.  Therefore, as\n       soon as an AccECN-capable TCP Client (A) receives the SYN/ACK\n       shown it MUST set both its half connections into the feedback\n       mode shown in the rightmost column.  If the TCP Client has set\n       itself into Classic ECN feedback mode it MUST then comply with\n       [RFC3168].\n\n       An AccECN implementation has no need to recognize or support the\n       Server response labelled 'Nonce' or ECN Nonce feedback more\n       generally [RFC3540], which has been reclassified as historic\n       [RFC8311].  AccECN is compatible with alternative ECN feedback\n       integrity approaches to the nonce (see Section 5.3).  The SYN/ACK\n       labelled 'Nonce' with (AE,CWR,ECE) = (1,0,1) is reserved for\n       future use.  A TCP Client (A) that receives such a SYN/ACK\n       follows the procedure for forward compatibility given in Section 3.1.3.\n\n   3.  The third block shows the cases where the TCP Server (B) supports\n       AccECN but the TCP Client (A) supports some earlier variant of\n       TCP feedback, indicated in its SYN.\n\n       When an AccECN-enabled TCP Server (B) receives a SYN with\n       (AE,CWR,ECE) = (0,1,1) it MUST do one of the following:\n\n       *  set both its half connections into the Classic ECN feedback\n          mode and return a SYN/ACK with (AE,CWR,ECE) = (0,0,1) as\n          shown.  Then it MUST comply with [RFC3168].\n\n       *  set both its half-connections into Not ECN mode and return a\n          SYN/ACK with (AE,CWR,ECE) = (0,0,0), then continue with ECN\n          disabled.  This latter case is unlikely to be desirable, but\n          it is allowed as a possibility, e.g., for minimal TCP\n          implementations.\n\n       When an AccECN-enabled TCP Server (B) receives a SYN with\n       (AE,CWR,ECE) = (0,0,0) it MUST set both its half connections into\n       the Not ECN feedback mode, return a SYN/ACK with (AE,CWR,ECE) =\n       (0,0,0) as shown and continue with ECN disabled.\n\n   4.  The fourth block displays a combination labelled `Broken'.  Some\n       older TCP Server implementations incorrectly set the TCP-ECN\n       flags in the SYN/ACK by reflecting those in the SYN.  Such broken \n       TCP Servers (B) cannot support ECN, so as soon as an AccECN-\n       capable TCP Client (A) receives such a broken SYN/ACK it MUST\n       fall back to Not ECN mode for both its half connections and\n       continue with ECN disabled.\n\n   The following additional rules do not fit the structure of the table,\n   but they complement it:\n\n   Simultaneous Open:  An originating AccECN Host (A), having sent a SYN\n      with (AE,CWR,ECE) = (1,1,1), might receive another SYN from host\n      B.  Host A MUST then enter the same feedback mode as it would have\n      entered had it been a responding host and received the same SYN.\n      Then host A MUST send the same SYN/ACK as it would have sent had\n      it been a responding host.\n\n   In-window SYN during TIME-WAIT:  Many TCP implementations create a\n      new TCP connection if they receive an in-window SYN packet during\n      TIME-WAIT state.  When a TCP host enters TIME-WAIT or CLOSED\n      state, it ought to ignore any previous state about the negotiation\n      of AccECN for that connection and renegotiate the feedback mode\n      according to Table 2.\n\n\n3.1.3. Forward Compatibility\n\n   If a TCP Server that implements AccECN receives a SYN with the three\n   TCP header flags (AE,CWR,ECE) set to any combination other than\n   (0,0,0), (0,1,1) or (1,1,1) and it does not have logic specific to\n   such a combination, the Server MUST negotiate the use of AccECN as if\n   the three flags had been set to (1,1,1).  However, an AccECN Client\n   implementation MUST NOT send a SYN with any combination other than\n   the three listed.\n\n   If a TCP Client has sent a SYN requesting AccECN feedback with\n   (AE,CWR,ECE) = (1,1,1) then receives a SYN/ACK with the currently\n   reserved combination (AE,CWR,ECE) = (1,0,1) but it does not have\n   logic specific to such a combination, the Client MUST enable AccECN\n   mode as if the SYN/ACK confirmed that the Server supported AccECN and\n   as if it fed back that the IP-ECN field on the SYN had arrived\n   unchanged.  However, an AccECN Server implementation MUST NOT send a\n   SYN/ACK with this combination (AE,CWR,ECE) = (1,0,1).\n\n      |  For the avoidance of doubt, the behaviour described in the\n      |  present specification applies whether or not the three\n      |  remaining reserved TCP header flags are zero. \n   All these requirements ensure that future uses of all the Reserved\n   combinations on a SYN or SYN/ACK can rely on consistent behaviour\n   from the installed base of AccECN implementations.  See Appendix B.3   for related discussion.\n\n\n3.1.4. Multiple SYNs or SYN/ACKs\n\n\n\n\n\n\n3.1.4.1. Retransmitted SYNs\n\n   If the sender of an AccECN SYN (the TCP Client) times out before\n   receiving the SYN/ACK, it SHOULD attempt to negotiate the use of\n   AccECN at least one more time by continuing to set all three TCP ECN\n   flags (AE,CWR,ECE) = (1,1,1) on the first retransmitted SYN (using\n   the usual retransmission time-outs).  If this first retransmission\n   also fails to be acknowledged, in deployment scenarios where AccECN\n   path traversal might be problematic, the TCP Client SHOULD send\n   subsequent retransmissions of the SYN with the three TCP-ECN flags\n   cleared (AE,CWR,ECE) = (0,0,0).  Such a retransmitted SYN MUST use\n   the same initial sequence number (ISN) as the original SYN.\n\n   Retrying once before fall-back adds delay in the case where a\n   middlebox drops an AccECN (or ECN) SYN deliberately.  However, recent\n   measurements [Mandalari18] imply that a drop is less likely to be due\n   to middlebox interference than other intermittent causes of loss,\n   e.g., congestion, wireless transmission loss, etc.\n\n   Implementers MAY use other fall-back strategies if they are found to\n   be more effective (e.g., attempting to negotiate AccECN on the SYN\n   only once or more than twice (most appropriate during high levels of\n   congestion).\n\n   Further it might make sense to also remove any other new or\n   experimental fields or options on the SYN in case a middlebox might\n   be blocking them, although the required behaviour will depend on the\n   specification of the other option(s) and any attempt to co-ordinate\n   fall-back between different modules of the stack.  For instance, even\n   if taking part in an [RFC8311] experiment that allows ECT on a SYN,\n   it would be advisable to try it without.\n\n   Whichever fall-back strategy is used, the TCP initiator SHOULD cache\n   failed connection attempts.  If it does, it SHOULD NOT give up\n   attempting to negotiate AccECN on the SYN of subsequent connection\n   attempts until it is clear that the blockage is persistently and\n   specifically due to AccECN.  The cache needs to be arranged to expire\n   so that the initiator will infrequently attempt to check whether the\n   problem has been resolved. \n   All fall-back strategies will need to follow all the normative rules\n   in Section 3.1.5, which concern behaviour when SYNs or SYN/ACKs\n   negotiating different types of feedback have been sent within the\n   same connection, including the possibility that they arrive out of\n   order.  As examples, the following non-normative bullets call out\n   those rules from Section 3.1.5 that apply to the above fall-back\n   strategies:\n\n   *  Once the TCP Client has sent SYNs with (AE,CWR,ECE) = (1,1,1) and\n      with (AE,CWR,ECE) = (0,0,0), it might eventually receive a SYN/ACK\n      from the Server in response to one, the other, or both and\n      possibly reordered;\n\n   *  Such a TCP Client enters the feedback mode appropriate to the\n      first SYN/ACK it receives according to Table 2, and it does not\n      switch to a different mode, whatever other SYN/ACKs it might\n      receive or send;\n\n   *  If a TCP Client has entered AccECN mode but then subsequently\n      sends a SYN or receives a SYN/ACK with (AE,CWR,ECE) = (0,0,0), it\n      is still allowed to set ECT on packets for the rest of the\n      connection.  Note that this rule is different to that of a Server\n      in an equivalent position (Section 3.1.5 explains).\n\n   *  Having entered AccECN mode, in general a TCP Client commits to\n      respond to any incoming congestion feedback, whether or not it\n      sets ECT on outgoing packets (for rationale and some exceptions\n      see Section 3.2.2.3, Section 3.2.2.4);\n\n   *  Having entered AccECN mode, a TCP Client commits to using AccECN\n      to feed back the IP-ECN field in incoming packets for the rest of\n      the connection, as specified in Section 3.2, even if it is not\n      itself setting ECT on outgoing packets.\n\n\n3.1.4.2. Retransmitted SYN/ACKs\n\n   A TCP Server might send multiple SYN/ACKs indicating different\n   feedback modes.  For instance, when falling back to sending a SYN/ACK\n   with (AE,CWR,ECE) = (0,0,0) after previous AccECN SYN/ACKs have timed\n   out (Section 3.2.3.2.2); or to acknowledge different retransmissions\n   of the SYN (Section 3.1.4.1).\n\n   All fall-back strategies will need to follow all the normative rules\n   in Section 3.1.5, which concern behaviour when SYNs or SYN/ACKs\n   negotiating different types of feedback are sent within the same\n   connection, including the possibility that they arrive out of order.\n   As examples, the following non-normative bullets call out those rules\n   from Section 3.1.5 that apply to the above fall-back strategies:\n   *  An AccECN-capable TCP Server enters the feedback mode appropriate\n      to the first SYN it receives using Table 2, and it does not switch\n      to a different mode, whatever other SYNs it might receive and\n      whatever SYN/ACKs it might send;\n\n   *  if a TCP Server in AccECN mode receives a SYN with (AE,CWR,ECE) =\n      (0,0,0), it preferably acknowledges it first using an AccECN SYN/\n      ACK, but it can retry using a SYN/ACK with (AE,CWR,ECE) = (0,0,0);\n\n   *  If a TCP Server in AccECN mode sends multiple AccECN SYN/ACKs, it\n      uses the TCP-ECN flags in each SYN/ACK to feed back the IP-ECN\n      field on the latest SYN to have arrived;\n\n   *  If a TCP Server enters AccECN mode then subsequently sends a SYN/\n      ACK or receives a SYN with (AE,CWR,ECE) = (0,0,0), it is\n      prohibited from setting ECT on any packet for the rest of the\n      connection;\n\n   *  Having entered AccECN mode, in general a TCP Server commits to\n      respond to any incoming congestion feedback, whether or not it\n      sets ECT on outgoing packets (for rationale and some exceptions\n      see Section 3.2.2.3, Section 3.2.2.4);\n\n   *  Having entered AccECN mode, a TCP Server commits to using AccECN\n      to feed back the IP-ECN field in incoming packets for the rest of\n      the connection, as specified in Section 3.2, even if it is not\n      itself setting ECT on outgoing packets.\n\n\n\n3.1.5. Implications of AccECN Mode\n\n\n\n   Section 3.1.1 describes the only ways that a host can enter AccECN\n   mode, whether as a Client or as a Server.\n\n   An implementation that supports AccECN has the rights and obligations\n   concerning the use of ECN defined below, which update those in Section 6.1.1 of [RFC3168].  This section uses the following\n   definitions:\n\n   'During the handshake':  The connection states prior to\n      synchronization;\n\n   'Valid SYN':  A SYN that has the same port numbers and the same ISN\n      as the SYN that first caused the Server to open the connection.\n      An 'Acceptable' packet is defined in Section 1.3.\n\n   Handling SYNs or SYN/ACKs of multiple types (e.g., fall-back):\n\n   *  Any implementation that supports AccECN:\n      -  MUST NOT switch into a different feedback mode to the one it\n         first entered according to Table 2, no matter whether it\n         subsequently receives valid SYNs or Acceptable SYN/ACKs of\n         different types.\n\n      -  SHOULD ignore the TCP-ECN flags in SYNs or SYN/ACKs that are\n         received after the implementation reaches the Established\n         state, in line with the general TCP approach [RFC9293];\n\n         Reason: Reaching established state implies that at least one\n         SYN and one SYN/ACK have successfully been delivered.  And all\n         the rules for handshake fall-back are designed to work based on\n         those packets that successfully traverse the path, whatever\n         other handshake packets are lost or delayed.\n\n      -  MUST NOT send a 'Classic' ECN-setup SYN [RFC3168] with\n         (AE,CWR,ECE) = (0,1,1) and a SYN with (AE,CWR,ECE) = (1,1,1)\n         requesting AccECN feedback within the same connection;\n\n      -  MUST NOT send a 'Classic' ECN-setup SYN/ACK [RFC3168] with\n         (AE,CWR,ECE) = (0,0,1) and a SYN/ACK agreeing to use AccECN\n         feedback within the same connection;\n\n      -  MUST reset the connection with a RST packet, if it receives a\n         'Classic' ECN-setup SYN with (AE,CWR,ECE) = (0,1,1) and a SYN\n         requesting AccECN feedback during the same handshake;\n\n      -  MUST reset the connection with a RST packet, if it receives\n         'Classic' ECN-setup SYN/ACK with (AE,CWR,ECE) = (0,0,1) and a\n         SYN/ACK agreeing to use AccECN feedback during the same\n         handshake;\n\n      The last four rules are necessary because, if one peer were to\n      negotiate the feedback mode in two different types of handshake,\n      it would not be possible for the other peer to know for certain\n      which handshake packet(s) the other end had eventually received or\n      in which order it received them.  So, in the absence of these\n      rules, the two peers could end up using different ECN feedback\n      modes without knowing it.\n\n   *  A host in AccECN mode that is feeding back the IP-ECN field on a\n      SYN or SYN/ACK:\n\n      -  MUST feed back the IP-ECN field on the latest valid SYN or\n         acceptable SYN/ACK to arrive.\n\n   *  A TCP Server already in AccECN mode:\n      -  SHOULD acknowledge a valid SYN arriving with (AE,CWR,ECE) =\n         (0,0,0) by emitting an AccECN SYN/ACK (with the appropriate\n         combination of TCP-ECN flags to feed back the IP-ECN field of\n         this latest SYN);\n\n      -  MAY acknowledge a valid SYN arriving with (AE,CWR,ECE) =\n         (0,0,0) by sending a SYN/ACK with (AE,CWR,ECE) = (0,0,0);\n\n      Rationale: When a SYN arrives with (AE,CWR,ECE) = (0,0,0) at a TCP\n      Server that is already in AccECN mode, it implies that the TCP\n      Client had probably not received the previous AccECN SYN/ACK\n      emitted by the TCP Server.  Therefore, the first bullet recommends\n      attempting at least one more AccECN SYN/ACK.  Nonetheless, the\n      second bullet recognizes that the Server might eventually need to\n      fall back to a non-ECN SYN/ACK.  In either case, the TCP Server\n      remains in AccECN feedback mode (according to the earlier\n      requirement not to switch modes).\n\n   *  An AccECN-capable TCP Server already in Not ECN mode:\n\n      -  SHOULD respond to any subsequent valid SYN using a SYN/ACK with\n         (AE,CWR,ECE) = (0,0,0), even if the SYN is offering to\n         negotiate Classic ECN or AccECN feedback mode;\n\n         Rationale: There would be no point in the Server offering any\n         type of ECN feedback, because the Client will not be using ECN.\n         However, there is no interoperability reason to make this rule\n         mandatory.\n\n   If for any reason a host is not willing to provide ECN feedback on a\n   particular TCP connection, it SHOULD clear the AE, CWR and ECE flags\n   in all SYN and/or SYN/ACK packets that it sends.\n\n   Sending ECT:\n\n   *  Any implementation that supports AccECN:\n\n      -  MUST NOT set ECT if it is in Not ECN feedback mode.\n\n      A Data Sender in AccECN mode:\n\n      -  SHOULD set an ECT codepoint in the IP header of packets to\n         indicate to the network that the transport is capable and\n         willing to participate in ECN for this packet;\n\n      -  MAY not set ECT on any packet (for instance if it has reason to\n         believe such a packet would be blocked);\n      A TCP Server in AccECN mode:\n\n      -  MUST NOT set ECT on any packet for the rest of the connection,\n         if it has received or sent at least one valid SYN or Acceptable\n         SYN/ACK with (AE,CWR,ECE) = (0,0,0) during the handshake.\n\n         This rule solely applies to a Server because, when a Server\n         enters AccECN mode it doesn't know for sure whether the Client\n         will end up in AccECN mode.  But when a Client enters AccECN\n         mode, it can be certain that the Server is already in AccECN\n         feedback mode.\n\n   Congestion response:\n\n   *  A host in AccECN mode:\n\n      -  is obliged to respond appropriately to AccECN feedback that\n         indicates there were ECN marks on packets it had previously\n         sent, where 'appropriately' is defined in Section 6.1 of\n         [RFC3168] and updated by Sections 2.1 and 4.1 of [RFC8311];\n\n      -  is still obliged to respond appropriately to congestion\n         feedback, even when it is solely sending non-ECN-capable\n         packets (for rationale, some examples and some exceptions see Section 3.2.2.3, Section 3.2.2.4).\n\n      -  is still obliged to respond appropriately to congestion\n         feedback, even if it has sent or received a SYN or SYN/ACK\n         packet with (AE,CWR,ECE) = (0,0,0) during the handshake;\n\n      -  MUST NOT set CWR to indicate that it has received and responded\n         to indications of congestion.\n\n         For the avoidance of doubt, this is unlike an RFC 3168 data\n         sender and this does not preclude the Data Sender from setting\n         the bits of the ACE counter field, which includes an overloaded\n         use of the same bit.\n\n   Receiving ECT:\n\n   *  A host in AccECN mode:\n\n      -  MUST feed back the information in the IP-ECN field of incoming\n         packets using Accurate ECN feedback, as specified in Section 3.2. \n         For the avoidance of doubt, this requirement stands even if the\n         AccECN host has also sent or received a SYN or SYN/ACK with\n         (AE,CWR,ECE) = (0,0,0).  Reason: Such a SYN or SYN/ACK implies\n         some form of packet mangling might be present.  Even if the\n         remote peer is not setting ECT, it could still be set\n         erroneously by packet mangling at the IP layer (see Section 3.2.2.3).  In such cases, the Data Sender is best\n         placed to decide whether ECN markings are valid, but it can\n         only do that if the Data Receiver mechanistically feeds back\n         any ECN markings.  This approach will not lead to TCP Options\n         being generated unnecessarily if the recommended simple scheme\n         in Section 3.2.3.3 is used, because no byte counters will\n         change if no packets are set to ECT.\n\n      -  MUST NOT use reception of packets with ECT set in the IP-ECN\n         field as an implicit signal that the peer is ECN-capable.\n\n         Reason: ECT at the IP layer does not explicitly confirm the\n         peer has the correct ECN feedback logic, because the packets\n         could have been mangled at the IP layer.\n\n\n\n3.2. AccECN Feedback\n\n   Each Data Receiver of each half connection maintains four counters,\n   r.cep, r.ceb, r.e0b and r.e1b:\n\n   *  The Data Receiver MUST increment the CE packet counter (r.cep),\n      for every Acceptable packet that it receives with the CE code\n      point in the IP ECN field, including CE marked control packets and\n      retransmissions but excluding CE on SYN packets (SYN=1; ACK=0).\n\n   *  A Data Receiver that supports sending of AccECN TCP Options MUST\n      increment the r.ceb, r.e0b or r.e1b byte counters by the number of\n      TCP payload octets in Acceptable packets marked with the CE,\n      ECT(0) and ECT(1) codepoint in their IP-ECN field, including any\n      payload octets on control packets and retransmissions, but not\n      including any payload octets on SYN packets (SYN=1; ACK=0).\n\n   Each Data Sender of each half connection maintains four counters,\n   s.cep, s.ceb, s.e0b and s.e1b intended to track the equivalent\n   counters at the Data Receiver.\n\n   A Data Receiver feeds back the CE packet counter using the Accurate\n   ECN (ACE) field, as explained in Section 3.2.2.  And it optionally\n   feeds back all the byte counters using the AccECN TCP Option, as\n   specified in Section 3.2.3. \n   Whenever a Data Receiver feeds back the value of any counter, it MUST\n   report the most recent value, no matter whether it is in a pure ACK,\n   or an ACK piggybacked on a packet used by the other half-connection,\n   whether new payload data or a retransmission.  Therefore the feedback\n   piggybacked on a retransmitted packet is unlikely to be the same as\n   the feedback on the original packet.\n\n3.2.1. Initialization of Feedback Counters\n\n   When a host first enters AccECN mode, in its role as a Data Receiver\n   it initializes its counters to r.cep = 5, r.e0b = r.e1b = 1 and r.ceb\n   = 0,\n\n   Non-zero initial values are used to support a stateless handshake\n   (see Section 5.1) and to be distinct from cases where the fields are\n   incorrectly zeroed (e.g., by middleboxes - see Section 3.2.3.2.4).\n\n   When a host enters AccECN mode, in its role as a Data Sender it\n   initializes its counters to s.cep = 5, s.e0b = s.e1b = 1 and s.ceb =\n   0.\n\n\n3.2.2. The ACE Field\n\n   After AccECN has been negotiated on the SYN and SYN/ACK, both hosts\n   overload the three TCP flags (AE, CWR and ECE) in the main TCP header\n   as one 3-bit field.  Then the field is given a new name, ACE, as\n   shown in Figure 3.\n\n\n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           |           | U | A | P | R | S | F |\n     | Header Length | Reserved  |    ACE    | R | C | S | S | Y | I |\n     |               |           |           | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 3: Definition of the ACE field within bytes 13 and 14 of\n        the TCP Header (when AccECN has been negotiated and SYN=0).\n\n   The original definition of these three flags in the TCP header,\n   including the addition of support for the ECN Nonce, is shown for\n   comparison in Figure 1.  This specification does not rename these\n   three TCP flags to ACE unconditionally; it merely overloads them with\n   another name and definition once an AccECN connection has been\n   established. \n   With one exception (Section 3.2.2.1), a host with both of its half-\n   connections in AccECN mode MUST interpret the AE, CWR and ECE flags\n   as the 3-bit ACE counter on a segment with the SYN flag cleared\n   (SYN=0).  On such a packet, a Data Receiver MUST encode the three\n   least significant bits of its r.cep counter into the ACE field that\n   it feeds back to the Data Sender.  The least significant bit is at\n   bit offset 9 in Figure 3.  A host MUST NOT interpret the 3 flags as a\n   3-bit ACE field on any segment with SYN=1 (whether ACK is 0 or 1), or\n   if AccECN negotiation is incomplete or has not succeeded.\n\n   Both parts of each of these conditions are equally important.  For\n   instance, even if AccECN negotiation has been successful, the ACE\n   field is not defined on any segments with SYN=1 (e.g., a\n   retransmission of an unacknowledged SYN/ACK, or when both ends send\n   SYN/ACKs after AccECN support has been successfully negotiated during\n   a simultaneous open).\n\n3.2.2.1. ACE Field on the ACK of the SYN/ACK\n\n   A TCP Client (A) in AccECN mode MUST feed back which of the 4\n   possible values of the IP-ECN field was on the SYN/ACK by writing it\n   into the ACE field of a pure ACK with no SACK blocks using the binary\n   encoding in Table 3 (which is the same as that used on the SYN/ACK in\n   Table 2).  This shall be called the handshake encoding of the ACE\n   field, and it is the only exception to the rule that the ACE field\n   carries the 3 least significant bits of the r.cep counter on packets\n   with SYN=0.\n\n   Normally, a TCP Client acknowledges a SYN/ACK with an ACK that\n   satisfies the above conditions anyway (SYN=0, no data, no SACK\n   blocks).  If an AccECN TCP Client intends to acknowledge the SYN/ACK\n   with a packet that does not satisfy these conditions (e.g., it has\n   data to include on the ACK), it SHOULD first send a pure ACK that\n   does satisfy these conditions (see Section 5.2), so that it can feed\n   back which of the four values of the IP-ECN field arrived on the SYN/\n   ACK.  A valid exception to this \"SHOULD\" would be where the\n   implementation will only be used in an environment where mangling of\n   the ECN field is unlikely.\n\n   The TCP Client MUST also use the handshake encoding for the pure ACK\n   of any retransmitted SYN/ACK that confirms that the TCP Server\n   supports AccECN.  The procedure for the TCP Server to follow if the\n   final ACK of the handshake does not arrive before its retransmission\n   timer expires is given in Section 3.1.4.2. \n        +==================+================+=====================+\n        | IP-ECN codepoint | ACE on pure    | r.cep of TCP Client |\n        | on SYN/ACK       | ACK of SYN/ACK | in AccECN mode      |\n        +==================+================+=====================+\n        | Not-ECT          | 0b010          | 5                   |\n        +------------------+----------------+---------------------+\n        | ECT(1)           | 0b011          | 5                   |\n        +------------------+----------------+---------------------+\n        | ECT(0)           | 0b100          | 5                   |\n        +------------------+----------------+---------------------+\n        | CE               | 0b110          | 6                   |\n        +------------------+----------------+---------------------+\n\n            Table 3: The encoding of the ACE field in the ACK of\n             the SYN-ACK to reflect the SYN-ACK's IP-ECN field\n\n   When an AccECN Server in SYN-RCVD state receives a pure ACK with\n   SYN=0 and no SACK blocks, instead of treating the ACE field as a\n   counter, it MUST infer the meaning of each possible value of the ACE\n   field from Table 4, which also shows the value that an AccECN Server\n   MUST set s.cep to as a result.\n\n   Given this encoding of the ACE field on the ACK of a SYN/ACK is\n   exceptional, an AccECN Server using large receive offload (LRO) might\n   prefer to disable LRO until such an ACK has transitioned it out of\n   SYN-RCVD state. \n      +============+==========================+=====================+\n      | ACE on ACK | IP-ECN codepoint on SYN/ | s.cep of TCP Server |\n      | of SYN/ACK | ACK inferred by Server   | in AccECN mode      |\n      +============+==========================+=====================+\n      | 0b000      | {Notes 1, 3}             | Disable s.cep       |\n      +------------+--------------------------+---------------------+\n      | 0b001      | {Notes 2, 3}             | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b010      | Not-ECT                  | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b011      | ECT(1)                   | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b100      | ECT(0)                   | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b101      | Currently Unused {Note   | 5                   |\n      |            | 2}                       |                     |\n      +------------+--------------------------+---------------------+\n      | 0b110      | CE                       | 6                   |\n      +------------+--------------------------+---------------------+\n      | 0b111      | Currently Unused {Note   | 5                   |\n      |            | 2}                       |                     |\n      +------------+--------------------------+---------------------+\n\n        Table 4: Meaning of the ACE field on the ACK of the SYN/ACK\n\n   {Note 1}: If the Server is in AccECN mode and in SYN-RCVD state, and\n   if it receives a value of zero on a pure ACK with SYN=0 and no SACK\n   blocks, for the rest of the connection the Server MUST NOT set ECT on\n   outgoing packets and MUST NOT respond to AccECN feedback.\n   Nonetheless, as a Data Receiver it MUST NOT disable AccECN feedback.\n\n   Any of the circumstances below could cause a value of zero but,\n   whatever the cause, the actions above would be the appropriate\n   response:\n\n   *  The TCP Client has somehow entered No ECN feedback mode (most\n      likely if the Server received a SYN or sent a SYN/ACK with\n      (AE,CWR,ECE) = (0,0,0) after entering AccECN mode, but possible\n      even if it didn't);\n\n   *  The TCP Client genuinely might be in AccECN mode, but its count of\n      received CE marks might have caused the ACE field to wrap to zero.\n      This is highly unlikely, but not impossible because the Server\n      might have already sent multiple packets while still in SYN-RCVD\n      state, e.g., using TFO (see Section 5.2) and some might have been\n      CE-marked.  Then ACE on the first ACK seen by the Server might be\n      zero, due to previous ACKs experiencing an unfortunate pattern of\n      loss or delay. \n   *  Some form of non-compliance at the TCP Client or on the path (see Section 3.2.2.4).\n\n   {Note 2}: If the Server is in AccECN mode, these values are Currently\n   Unused but the AccECN Server's behaviour is still defined for forward\n   compatibility.  Then the designer of a future protocol can know for\n   certain what AccECN Servers will do with these codepoints.\n\n   {Note 3}: In the case where a Server that implements AccECN is also\n   using a stateless handshake (termed a SYN cookie) it will not\n   remember whether it entered AccECN mode.  The values 0b000 or 0b001\n   will remind it that it did not enter AccECN mode, because AccECN does\n   not use them (see Section 5.1 for details).  If a Server that uses a\n   stateless handshake and implements AccECN receives either of these\n   two values in the ACK, its action is implementation-dependent and\n   outside the scope of this document.  It will certainly not take the\n   action in the third column because, after it receives either of these\n   values, it is not in AccECN mode.  In example, it will not disable\n   ECN (at least not just because ACE is 0b000) and it will not set\n   s.cep.\n\n\n3.2.2.2. Encoding and Decoding Feedback in the ACE Field\n\n   Whenever the Data Receiver sends an ACK with SYN=0 (with or without\n   data), unless the handshake encoding in Section 3.2.2.1 applies, the\n   Data Receiver MUST encode the least significant 3 bits of its r.cep\n   counter into the ACE field (see Appendix A.2).\n\n   Whenever the Data Sender receives an ACK with SYN=0 (with or without\n   data), it first checks whether it has already been superseded\n   (defined in Appendix A.1) by another ACK in which case it ignores the\n   ECN feedback.  If the ACK has not been superseded, and if the special\n   handshake encoding in Section 3.2.2.1 does not apply, the Data Sender\n   decodes the ACE field as follows (see Appendix A.2 for examples).\n\n   *  It takes the least significant 3 bits of its local s.cep counter\n      and subtracts them from the incoming ACE counter to work out the\n      minimum positive increment it could apply to s.cep (assuming the\n      ACE field only wrapped at most once).\n\n   *  It then follows the safety procedures in Section 3.2.2.5.2 to\n      calculate or estimate how many packets the ACK could have\n      acknowledged under the prevailing conditions to determine whether\n      the ACE field might have wrapped more than once.\n\n   The encode/decode procedures during the three-way handshake are\n   exceptions to the general rules given so far, so they are spelled out\n   step by step below for clarity:\n   *  If a TCP Server in AccECN mode receives a CE mark in the IP-ECN\n      field of a SYN (SYN=1, ACK=0), it MUST NOT increment r.cep (it\n      remains at its initial value of 5).\n\n      Reason: It would be redundant for the Server to include CE-marked\n      SYNs in its r.cep counter, because it already reliably delivers\n      feedback of any CE marking using the encoding in the top block of\n      Table 2 in the SYN/ACK.  This also ensures that, when the Server\n      starts using the ACE field, it has not unnecessarily consumed more\n      than one initial value, given they can be used to negotiate\n      variants of the AccECN protocol (see Appendix B.3).\n\n   *  If a TCP Client in AccECN mode receives CE feedback in the TCP\n      flags of a SYN/ACK, it MUST NOT increment s.cep (it remains at its\n      initial value of 5), so that it stays in step with r.cep on the\n      Server.  Nonetheless, the TCP Client still triggers the congestion\n      control actions necessary to respond to the CE feedback.\n\n   *  If a TCP Client in AccECN mode receives a CE mark in the IP-ECN\n      field of a SYN/ACK, it MUST increment r.cep, but no more than once\n      no matter how many CE-marked SYN/ACKs it receives\n      (i.e., incremented from 5 to 6, but no further).\n\n      Reason: Incrementing r.cep ensures the Client will eventually\n      deliver any CE marking to the Server reliably when it starts using\n      the ACE field.  Even though the Client also feeds back any CE\n      marking on the ACK of the SYN/ACK using the encoding in Table 3,\n      this ACK is not delivered reliably, so it can be considered as a\n      timely notification that is redundant but unreliable.  The Client\n      does not increment r.cep more than once, because the Server can\n      only increment s.cep once (see next bullet).  Also, this limits\n      the unnecessarily consumed initial values of the ACE field to two.\n\n   *  If a TCP Server in AccECN mode and in SYN-RCVD state receives CE\n      feedback in the TCP flags of a pure ACK with no SACK blocks, it\n      MUST increment s.cep (from 5 to 6).  The TCP Server then triggers\n      the congestion control actions necessary to respond to the CE\n      feedback.\n\n      Reasoning: The TCP Server can only increment s.cep once, because\n      the first ACK it receives will cause it to transition out of SYN-\n      RCVD state.  The Server's congestion response would be no\n      different even if it could receive feedback of more than one CE-\n      marked SYN/ACK.\n\n      Once the TCP Server transitions to ESTABLISHED state, it might\n      later receive other pure ACK(s) with the handshake encoding in the\n      ACE field.  A Server MAY implement a test for such a case, but it \n      is not required.  Therefore, once in the ESTABLISHED state, it\n      will be sufficient for the Server to consider the ACE field to be\n      encoded as the normal ACE counter on all packets with SYN=0.\n\n      Reasoning: Such ACKs will be quite unusual, e.g., a SYN/ACK (or\n      ACK of the SYN/ACK) that is delayed for longer than the Server's\n      retransmission timeout; or packet duplication by the network.  And\n      the impact of any error in the feedback on such ACKs will only be\n      temporary.\n\n\n3.2.2.3. Testing for Mangling of the IP/ECN Field\n\n   *  TCP Client side:\n\n      The value of the TCP-ECN flags on the SYN/ACK indicates the value\n      of the IP-ECN field when the SYN arrived at the Server.  The TCP\n      Client can compare this with how it originally set the IP-ECN\n      field on the SYN.  If this comparison implies an invalid\n      transition (defined below) of the IP-ECN field, for the remainder\n      of the half-connection the Client is advised to send non-ECN-\n      capable packets, but it still ought to respond to any feedback of\n      CE markings (explained below).  However, the TCP Client MUST\n      remain in the AccECN feedback mode and it MUST continue to feed\n      back any ECN markings on arriving packets (in its role as Data\n      Receiver).\n\n   *  TCP Server side:\n\n      The value of the ACE field on the last ACK of the three-way\n      handshake indicates the value of the IP-ECN field when the SYN/ACK\n      arrived at the TCP Client.  The Server can compare this with how\n      it originally set the IP-ECN field on the SYN/ACK.  If this\n      comparison implies an invalid transition of the IP-ECN field, for\n      the remainder of the half-connection the Server is advised to send\n      non-ECN-capable packets, but it still ought to respond to any\n      feedback of CE markings (explained below).  However, the Server\n      MUST remain in the AccECN feedback mode and it MUST continue to\n      feed back any ECN markings on arriving packets (in its role as\n      Data Receiver).\n\n   If a Data Sender in AccECN mode starts sending non-ECN-capable\n   packets because it has detected mangling, it is still advised to\n   respond to CE feedback.  Reason: any CE-marking arriving at the Data\n   Receiver could be due to something early in the path mangling the\n   non-ECN-capable IP-ECN field into an ECN-capable codepoint and then,\n   later in the path, a network bottleneck might be applying CE-markings\n   to indicate genuine congestion.  This argument applies whether the\n   handshake packet originally sent by the TCP Client or Server was non-\n   ECN-capable or ECN-capable because, in either case, an unsafe\n   transition could imply that non-ECN-capable packets later in the\n   connection might get mangled.\n\n   Once a Data Sender has entered AccECN mode it is advised to check\n   whether it is receiving continuous feedback of CE.  Specifying\n   exactly how to do this is beyond the scope of the present\n   specification, but the sender might check whether the feedback for\n   every packet it sends for the first three or four rounds indicates\n   CE-marking.  If continuous CE-marking is detected, for the remainder\n   of the half-connection, the Data Sender ought to send non-ECN-capable\n   packets and it is advised not to respond to any feedback of CE\n   markings.  The Data Sender might occasionally test whether it can\n   resume sending ECN-capable packets.\n\n   The above advice on switching to sending non-ECN-capable packets but\n   still responding to CE-markings unless they become continuous is not\n   stated normatively (in capitals), because the best strategy might\n   depend on experience of the most likely types of mangling, which can\n   only be known at the time of deployment.  The same is true for other\n   forms of mangling (or resumption of expected marking) during later\n   stages of a connection.\n\n   As always, once a host has entered AccECN mode, it follows the\n   general mandatory requirements (Section 3.1.5) to remain in the same\n   feedback mode and to continue feeding back any ECN markings on\n   arriving packets using AccECN feedback.  This follows the general\n   approach where an AccECN Data Receiver mechanistically reflects\n   whatever it receives (Section 2.5).\n\n   The ACK of the SYN/ACK is not reliably delivered (nonetheless, the\n   count of CE marks is still eventually delivered reliably).  If this\n   ACK does not arrive, the Server is advised to continue to send ECN-\n   capable packets without having tested for mangling of the IP-ECN\n   field on the SYN/ACK.\n\n   All the fall-back behaviours in this section are necessary in case\n   mangling of the IP-ECN field is asymmetric, which is currently common\n   over some mobile networks [Mandalari18].  Then one end might see no\n   unsafe transition and continue sending ECN-capable packets, while the\n   other end sees an unsafe transition and stops sending ECN-capable\n   packets.\n\n   Invalid transitions of the IP-ECN field are defined in section 18 of\n   the Classic ECN specification [RFC3168] and repeated here for\n   convenience:\n\n   *  the not-ECT codepoint changes;\n   *  either ECT codepoint transitions to not-ECT;\n\n   *  the CE codepoint changes. RFC 3168 says that a router that changes ECT to not-ECT is invalid\n   but safe.  However, from a host's viewpoint, this transition is\n   unsafe because it could be the result of two transitions at different\n   routers on the path: ECT to CE (safe) then CE to not-ECT (unsafe).\n   This scenario could well happen where an ECN-enabled home router\n   congests its upstream mobile broadband bottleneck link, then the\n   ingress to the mobile network clears the ECN field [Mandalari18].\n\n\n3.2.2.4. Testing for Zeroing of the ACE Field\n\n\n\n   Section 3.2.2 required the Data Receiver to initialize the r.cep\n   counter to a non-zero value.  Therefore, in either direction the\n   initial value of the ACE counter ought to be non-zero.\n\n   This section does not concern the case where the ACE field is zero\n   when the handshake encoding has been used on the ACK of the SYN/ACK\n   under the carefully worded conditions in Section 3.2.2.1.\n\n   If AccECN has been successfully negotiated, the Data Sender MAY check\n   the value of the ACE counter in the first feedback packet (with or\n   without data) that arrives after the three-way handshake.  If the\n   value of this ACE field is found to be zero (0b000), for the\n   remainder of the half-connection the Data Sender ought to send non-\n   ECN-capable packets and it is advised not to respond to any feedback\n   of CE markings.\n\n   Reason: the symptoms imply any or all of the following:\n\n   *  the remote peer has somehow entered Not ECN feedback mode;\n\n   *  a broken remote TCP implementation;\n\n   *  potential mangling of the ECN fields in the TCP headers (although\n      unlikely given they clearly survived during the handshake).\n\n   This advice is not stated normatively (in capitals), because the best\n   strategy might depend on experience of the most likely scenarios,\n   which can only be known at the time of deployment.\n\n   Note that a host in AccECN mode MUST continue to provide Accurate ECN\n   feedback to its peer, even if it is no longer sending ECT itself over\n   the other half connection. \n   If reordering occurs, the first feedback packet that arrives will not\n   necessarily be the same as the first packet in sequence order.  The\n   test has been specified loosely like this to simplify implementation,\n   and because it would not have been any more precise to have specified\n   the first packet in sequence order, which would not necessarily be\n   the first ACE counter that the Data Receiver fed back anyway, given\n   it might have been a retransmission.\n\n   The possibility of re-ordering means that there is a small chance\n   that the ACE field on the first packet to arrive is genuinely zero\n   (without middlebox interference).  This would cause a host to\n   unnecessarily disable ECN for a half connection.  Therefore, in\n   environments where there is no evidence of the ACE field being\n   zeroed, implementations MAY skip this test.\n\n   Note that the Data Sender MUST NOT test whether the arriving counter\n   in the initial ACE field has been initialized to a specific valid\n   value - the above check solely tests whether the ACE fields have been\n   incorrectly zeroed.  This allows hosts to use different initial\n   values as an additional signalling channel in future.\n\n\n3.2.2.5. Safety against Ambiguity of the ACE Field\n\n   If too many CE-marked segments are acknowledged at once, or if a long\n   run of ACKs is lost or thinned out, the 3-bit counter in the ACE\n   field might have cycled between two ACKs arriving at the Data Sender.\n   The following safety procedures minimize this ambiguity.\n\n3.2.2.5.1. Packet Receiver Safety Procedures\n\n   The following rules define when the receiver of a packet in AccECN\n   mode emits an ACK:\n\n   Change-Triggered ACKs:  An AccECN Data Receiver SHOULD emit an ACK\n      whenever a data packet marked CE arrives after the previous packet\n      was not CE.\n\n      Even though this rule is stated as a \"SHOULD\", it is important for\n      a transition to trigger an ACK if at all possible, The only valid\n      exception to this rule is given below these bullets.\n\n      For the avoidance of doubt, this rule is deliberately worded to\n      apply solely when _data_ packets arrive, but the comparison with\n      the previous packet includes any packet, not just data packets.\n\n   Increment-Triggered ACKs:  An AccECN receiver of a packet MUST emit \n      an ACK if 'n' CE marks have arrived since the previous ACK.  If\n      there is unacknowledged data at the receiver, 'n' SHOULD be 2.  If\n      there is no unacknowledged data at the receiver, 'n' SHOULD be 3\n      and MUST be no less than 3.  In either case, 'n' MUST be no\n      greater than 7.\n\n   The above rules for when to send an ACK are designed to be\n   complemented by those in Section 3.2.3.3, which concern whether an\n   AccECN TCP Option ought to be included on ACKs.\n\n   If the arrivals of a number of data packets are all processed as one\n   event, e.g., using large receive offload (LRO) or generic receive\n   offload (GRO), both the above rules SHOULD be interpreted as\n   requiring multiple ACKs to be emitted back-to-back (for each\n   transition and for each sequence of 'n' CE marks).  If this is\n   problematic for high performance, either rule can be interpreted as\n   requiring just a single ACK at the end of the whole receive event.\n\n   Even if a number of data packets do not arrive as one event, the\n   'Change-Triggered ACKs' rule could sometimes cause the ACK rate to be\n   problematic for high performance (although high performance protocols\n   such as DCTCP already successfully use change-triggered ACKs).  The\n   rationale for change-triggered ACKs is so that the Data Sender can\n   rely on them to detect queue growth as soon as possible, particularly\n   at the start of a flow.  The approach can lead to some additional\n   ACKs but it feeds back the timing and the order in which ECN marks\n   are received with minimal additional complexity.  If CE marks are\n   infrequent, as is the case for most Active Queue Managment (AQM)\n   packet schedulers at the time of writing, or there are multiple marks\n   in a row, the additional load will be low.  However, marking patterns\n   with numerous non-contiguous CE marks could increase the load\n   significantly.  One possible compromise would be for the receiver to\n   heuristically detect whether the sender is in slow-start, then to\n   implement change-triggered ACKs while the sender is in slow-start,\n   and offload otherwise.\n\n   In a scenario where both endpoints support AccECN, if host B has\n   chosen to use ECN-capable pure ACKs (as allowed in [RFC8311]\n   experiments) and enough of these ACKs become CE-marked, then the\n   'Increment-Triggered ACKs' rule ensures that its peer (host A) gives\n   B sufficient feedback about this congestion on the ACKs from B to A.\n   Normally, for instance in a unidirectional data scenario from host A\n   to B, the Data Sender (A) can piggyback that feedback on its data.\n   But if A stops sending data, the second part of the 'Increment-\n   Triggered ACKs' rule requires A to emit a pure ACK for at least every\n   third CE-marked incoming ACK over the subsequent round trip. \n   Although TCP normally only ACKs data segments, in this case the\n   increment-triggered ACK rule makes it mandatory for A to emit ACKs of\n   ACKs.  This is justifiable because the ACKs in this case are ECN-\n   capable and so, even though the ACKs of these ACKs do not acknowledge\n   new data, they feed back new congestion state (useful in case B\n   starts sending).  The minimum of 3 for 'n' in this case ensures that,\n   even if A also uses ECN-capable pure ACKs, and even if there is\n   pathological congestion in both directions, any resulting ping-pong\n   of ACKs will be rapidly damped.\n\n   In the above bidirectional scenario, incoming ACKs of ACKs could be\n   mistaken for duplicate ACKs.  But ACKs of ACKs can be distinguished\n   from duplicate ACKs because they do not contain any SACK blocks even\n   when SACK has been negotiated.  It is outside the scope of this\n   AccECN specification to normatively specify this additional test for\n   DupACKs, because ACKs of ACKs can only arise if the original ACKs are\n   ECN-capable.  Instead any specification that allows ECN-capable pure\n   ACKs MUST make sending ACKs of ACKs conditional on measures to\n   distinguish ACKs of ACKs from DupACKs (see for example\n   [I-D.ietf-tcpm-generalized-ecn ]).  All that is necessary here is to\n   require that these ACKs of ACKs MUST NOT contain any SACK blocks\n   (which would normally not happen anyway).\n\n\n3.2.2.5.2. Data Sender Safety Procedures\n\n   If the Data Sender has not received AccECN TCP Options to give it\n   more dependable information, and it detects that the ACE field could\n   have cycled, it SHOULD deem whether it cycled by taking the safest\n   likely case under the prevailing conditions.  It can detect if the\n   counter could have cycled by using the jump in the acknowledgement\n   number since the last ACK to calculate or estimate how many segments\n   could have been acknowledged.  An example algorithm to implement this\n   policy is given in Appendix A.2.  An implementation MAY use an\n   alternative algorithm as long as it satisfies the requirements in\n   this subsection.\n\n   If missing acknowledgement numbers arrive later (reordering) and\n   prove that the counter did not cycle, the Data Sender MAY attempt to\n   neutralize the effect of any action it took based on a conservative\n   assumption that it later found to be incorrect.\n\n   The Data Sender can estimate how many packets (of any marking) an ACK\n   acknowledges.  If the ACE counter on an ACK seems to imply that the\n   minimum number of newly CE-marked packets is greater than the number\n   of newly acknowledged packets, the Data Sender SHOULD consider the\n   ACE counter to be correct (and its count of control packets to be\n   incomplete), unless it can be sure that it is counting all control\n   packets correctly. \n\n\n\n\n\n\n\n\n3.2.3. The AccECN Option\n\n   Two alternative AccECN Options are defined as shown in Figure 4.  The\n   initial 'E' of each field name stands for 'Echo'.\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Kind = 172   |  Length = 11  |          EE0B field           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | EE0B (cont'd) |           ECEB field                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                  EE1B field                   |             Order 0\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Kind = 174   |  Length = 11  |          EE1B field           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | EE1B (cont'd) |           ECEB field                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                  EE0B field                   |             Order 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n              Figure 4: The Two Alternative AccECN TCP Options\n\n   Figure 4 shows two option field orders; order 0 and order 1.  They\n   both consists of three 24-bit fields.  Order 0 provides the 24 least\n   significant bits of the r.e0b, r.ceb and r.e1b counters,\n   respectively.  Order 1 provides the same fields, but in the opposite\n   order.  On each packet, the Data Receiver can use whichever order is\n   more efficient.  In either case, the bytes within the fields are in\n   network byte order (big-endian).\n\n   The choice to use three bytes (24 bits) fields in the options was\n   made to strike a balance between TCP option space usage, and the\n   required fidelity of the counters to accomodate typical scenarios\n   such as hardware TCP segmentation offloading (TSO), and periods where\n   no option may be transmitted (e.g., SACK loss recovery).  Providing\n   only 2 bytes (16 bits) for these counters could easily roll over\n   within a single TSO transmission or large/generic receive offload\n   (LRO/GRO) event.  Having two distinct orderings further allows the\n   transmission of the most pertinent changes in an abbreviated option\n   (see below). \n   When a Data Receiver sends an AccECN Option, it MUST set the Kind\n   field to 172 if using Order 0, or to 174 if using Order 1.  These two\n   new TCP Option Kinds are registered in Section 7 and called\n   respectively AccECN0 and AccECN1.\n\n   Note that there is no field to feed back Not-ECT bytes.  Nonetheless\n   an algorithm for the Data Sender to calculate the number of payload\n   bytes received as Not-ECT is given in Appendix A.4.\n\n   Whenever a Data Receiver sends an AccECN Option, the rules in Section 3.2.3.3 allow it to omit unchanged fields from the tail of\n   the option, to help cope with option space limitations, as long as it\n   preserves the order of the remaining fields and includes any field\n   that has changed.  The length field MUST indicate which fields are\n   present as follows:\n\n             +========+==================+==================+\n             | Length | Order 0          | Order 1          |\n             +========+==================+==================+\n             | 11     | EE0B, ECEB, EE1B | EE1B, ECEB, EE0B |\n             +--------+------------------+------------------+\n             | 8      | EE0B, ECEB       | EE1B, ECEB       |\n             +--------+------------------+------------------+\n             | 5      | EE0B             | EE1B             |\n             +--------+------------------+------------------+\n             | 2      | (empty)          | (empty)          |\n             +--------+------------------+------------------+\n\n                  Table 5: Fields included in AccECN TCP\n                     Options of each length and order\n\n   The empty option of Length=2 is provided to allow for a case where an\n   AccECN Option has to be sent (e.g., on the SYN/ACK to test the path),\n   but there is very limited space for the option.\n\n   All implementations of a Data Sender that read any AccECN Option MUST\n   be able to read AccECN Options of any of the above lengths.  For\n   forward compatibility, if the AccECN Option is of any other length,\n   implementations MUST use those whole 3-octet fields that fit within\n   the length and ignore the remainder of the option, treating it as\n   padding.\n\n   AccECN Options have to be optional to implement, because both sender\n   and receiver have to be able to cope without options anyway - in\n   cases where they do not traverse a network path.  It is RECOMMENDED\n   to implement both sending and receiving of AccECN Options.  Support\n   for AccECN Options is particularly valuable over paths that introduce\n   a high degree of ACK filtering, where the 3-bit ACE counter alone \n   might sometimes be insufficient, when it is ambiguous whether it has\n   wrapped.  If sending of AccECN Options is implemented, the fall-backs\n   described in this document will need to be implemented as well\n   (unless solely for a controlled environment where path traversal is\n   not considered a problem).  Even if a developer does not implement\n   logic to understand received AccECN Options, it is RECOMMENDED that\n   they implement logic to send AccECN Options.  Otherwise, those remote\n   peers that implement the receiving logic will still be excluded from\n   congestion feedback that is robust against the increasingly\n   aggressive ACK filtering in the Internet.  The logic to send AccECN\n   Options is the simpler to implement of the two sides.\n\n   If a Data Receiver intends to send an AccECN Option at any time\n   during the rest of the connection it is RECOMMENDED to also test path\n   traversal of the AccECN Option as specified in Section 3.2.3.2.\n\n3.2.3.1. Encoding and Decoding Feedback in the AccECN Option Fields\n\n   Whenever the Data Receiver includes any of the counter fields (ECEB,\n   EE0B, EE1B) in an AccECN Option, it MUST encode the 24 least\n   significant bits of the current value of the associated counter into\n   the field (respectively r.ceb, r.e0b, r.e1b).\n\n   Whenever the Data Sender receives an ACK carrying an AccECN Option,\n   it first checks whether the ACK has already been superseded by\n   another ACK in which case it ignores the ECN feedback.  If the ACK\n   has not been superseded, the Data Sender normally decodes the fields\n   in the AccECN Option as follows.  For each field, it takes the least\n   significant 24 bits of its associated local counter (s.ceb, s.e0b or\n   s.e1b) and subtracts them from the counter in the associated field of\n   the incoming AccECN Option (respectively ECEB, EE0B, EE1B), to work\n   out the minimum positive increment it could apply to s.ceb, s.e0b or\n   s.e1b (assuming the field in the option only wrapped at most once). Appendix A.1 gives an example algorithm for the Data Receiver to\n   encode its byte counters into an AccECN Option, and for the Data\n   Sender to decode the AccECN Option fields into its byte counters.\n\n   Note that, as specified in Section 3.2, any data on the SYN (SYN=1,\n   ACK=0) is not included in any of the byte counters held locally for\n   each ECN marking nor in an AccECN Option on the wire.\n\n\n3.2.3.2. Path Traversal of the AccECN Option\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.2.3.2.1. Testing the AccECN Option during the Handshake\n\n   The TCP Client MUST NOT include an AccECN TCP Option on the SYN.  If\n   there is somehow an AccECN Option on a SYN, it MUST be ignored when\n   forwarded or received.\n\n   A TCP Server that confirms its support for AccECN (in response to an\n   AccECN SYN from the Client as described in Section 3.1) SHOULD\n   include an AccECN TCP Option on the SYN/ACK.\n\n   A TCP Client that has successfully negotiated AccECN SHOULD include\n   an AccECN Option in the first ACK at the end of the three-way\n   handshake.  However, this first ACK is not delivered reliably, so the\n   TCP Client SHOULD also include an AccECN Option on the first data\n   segment it sends (if it ever sends one).\n\n   A host MAY omit an AccECN Option in any of the above three cases due\n   to insufficient option space or if it has cached knowledge that the\n   packet would be likely to be blocked on the path to the other host if\n   it included an AccECN Option.\n\n\n3.2.3.2.2. Testing for Loss of Packets Carrying the AccECN Option\n\n   If the TCP Server has not received an ACK to acknowledge its SYN/ACK\n   after the normal TCP timeout or it receives a second SYN with a\n   request for AccECN support, then either the SYN/ACK might just have\n   been lost, e.g., due to congestion, or a middlebox might be blocking\n   AccECN Options.  To expedite connection setup in deployment scenarios\n   where AccECN path traversal might be problematic, the TCP Server\n   SHOULD retransmit the SYN/ACK, but with no AccECN Option.  If this\n   retransmission times out, to expedite connection setup, the TCP\n   Server SHOULD retransmit the SYN/ACK with (AE,CWR,ECE) = (0,0,0) and\n   no AccECN Option, but it remains in AccECN feedback mode (per Section 3.1.5).\n\n      |  Note that a retransmitted AccECN SYN/ACK will not necessarily\n      |  have the same TCP-ECN flags as the original SYN/ACK, because it\n      |  feeds back the IP-ECN field of the latest SYN to have arrived\n      |  (by the rule in Section 3.1.5).\n\n   The above fall-back approach limits any interference by middleboxes\n   that might drop packets with unknown options, even though it is more\n   likely that SYN/ACK loss is due to congestion.  The TCP Server MAY\n   try to send another packet with an AccECN Option at a later point\n   during the connection but it ought to monitor if that packet got lost\n   as well, in which case it SHOULD disable the sending of AccECN\n   Options for this half-connection. \n   Implementers MAY use other fall-back strategies if they are found to\n   be more effective (e.g., retrying an AccECN Option for a second time\n   before fall-back - most appropriate during high levels of\n   congestion).  However, other fall-back strategies will need to follow\n   all the rules in Section 3.1.5, which concern behaviour when SYNs or\n   SYN/ACKs negotiating different types of feedback have been sent\n   within the same connection.\n\n   Further it might make sense to also remove any other new or\n   experimental fields or options on the SYN/ACK, although the required\n   behaviour will depend on the specification of the other option(s) and\n   on any attempt to co-ordinate fall-back between different modules of\n   the stack.\n\n   If the TCP Client detects that the first data segment it sent with an\n   AccECN Option was lost, in deployment scenarios where AccECN path\n   traversal might be problematic, it SHOULD fall back to no AccECN\n   Option on the retransmission.  Again, implementers MAY use other\n   fall-back strategies such as attempting to retransmit a second\n   segment with an AccECN Option before fall-back, and/or caching\n   whether AccECN Options are blocked for subsequent connections.\n   [RFC9040] further discusses caching of TCP parameters and status\n   information.\n\n   If a middlebox is dropping packets with options it does not\n   recognize, a host that is sending little or no data but mostly pure\n   ACKs will not inherently detect such losses.  Such a host MAY detect\n   loss of ACKs carrying the AccECN Option by detecting whether the\n   acknowledged data always reappears as a retransmission.  In such\n   cases, the host SHOULD disable the sending of the AccECN Option for\n   this half-connection.\n\n   If a host falls back to not sending AccECN Options, it will continue\n   to process any incoming AccECN Options as normal.\n\n   Either host MAY include AccECN Options in a subsequent segment or\n   segments to retest whether AccECN Options can traverse the path.\n\n   Similarly, an AccECN endpoint MAY separately memorize which data\n   packets carried an AccECN Option and disable the sending of AccECN\n   Options if the loss probability of those packets is significantly\n   higher than that of all other data packets in the same connection. \n\n\n\n\n\n\n3.2.3.2.3. Testing for Absence of the AccECN Option\n\n   If the TCP Client has successfully negotiated AccECN but does not\n   receive an AccECN Option on the SYN/ACK (e.g., because is has been\n   stripped by a middlebox or not sent by the Server), the Client\n   switches into a mode that assumes that the AccECN Option is not\n   available for this half connection.\n\n   Similarly, if the TCP Server has successfully negotiated AccECN but\n   does not receive an AccECN Option on the first segment that\n   acknowledges sequence space at least covering the ISN, it switches\n   into a mode that assumes that the AccECN Option is not available for\n   this half connection.\n\n   While a host is in this mode that assumes incoming AccECN Options are\n   not available, it MUST adopt the conservative interpretation of the\n   ACE field discussed in Section 3.2.2.5.  However, it cannot make any\n   assumption about support of outgoing AccECN Options on the other half\n   connection, so it SHOULD continue to send AccECN Options itself\n   (unless it has established that sending AccECN Options is causing\n   packets to be blocked as in Section 3.2.3.2.2).\n\n   If a host is in the mode that assumes incoming AccECN Options are not\n   available, but it receives an AccECN Option at any later point during\n   the connection, this clearly indicates that AccECN Options are no\n   longer blocked on the respective path, and the AccECN endpoint MAY\n   switch out of the mode that assumes AccECN Options are not available\n   for this half connection.\n\n\n3.2.3.2.4. Test for Zeroing of the AccECN Option\n\n   For a related test for invalid initialization of the ACE field, see Section 3.2.2.4\n\n   Section 3.2.1 required the Data Receiver to initialize the r.e0b and\n   r.e1b counters to a non-zero value.  Therefore, in either direction\n   the initial value of the EE0B field or EE1B field in an AccECN Option\n   (if one exists) ought to be non-zero.  If AccECN has been negotiated:\n\n   *  the TCP Server MAY check that the initial value of the EE0B field\n      or the EE1B field is non-zero in the first segment that\n      acknowledges sequence space that at least covers the ISN plus 1.\n      If it runs a test and either initial value is zero, the Server\n      will switch into a mode that ignores AccECN Options for this half\n      connection. \n   *  the TCP Client MAY check the initial value of the EE0B field or\n      the EE1B field is non-zero on the SYN/ACK.  If it runs a test and\n      either initial value is zero, the Client will switch into a mode\n      that ignores AccECN Options for this half connection.\n\n   While a host is in the mode that ignores AccECN Options it MUST adopt\n   the conservative interpretation of the ACE field discussed in Section 3.2.2.5.\n\n   Note that the Data Sender MUST NOT test whether the arriving byte\n   counters in an initial AccECN Option have been initialized to\n   specific valid values - the above checks solely test whether these\n   fields have been incorrectly zeroed.  This allows hosts to use\n   different initial values as an additional signalling channel in\n   future.  Also note that the initial value of either field might be\n   greater than its expected initial value, because the counters might\n   already have been incremented.  Nonetheless, the initial values of\n   the counters have been chosen so that they cannot wrap to zero on\n   these initial segments.\n\n\n3.2.3.2.5. Consistency between AccECN Feedback Fields\n\n   When AccECN Options are available they ought to provide more\n   unambiguous feedback.  However, they supplement but do not replace\n   the ACE field.  An endpoint using AccECN feedback MUST always\n   reconcile the information provided in the ACE field with that in any\n   AccECN Option, so that the state of the ACE-related packet counter\n   can be relied on if future feedback does not carry an AccECN Option.\n\n   If an AccECN Option is present, the s.cep counter might increase more\n   than expected from the increase of the s.ceb counter (e.g., due to a\n   CE-marked control packet).  The sender's response to such a situation\n   is out of scope, and needs to be dealt with in a specification that\n   uses ECN-capable control packets.  Theoretically, this situation\n   could also occur if a middlebox mangled an AccECN Option but not the\n   ACE field.  However, the Data Sender has to assume that the integrity\n   of AccECN Options is sound, based on the above test of the well-known\n   initial values and optionally other integrity tests (Section 5.3).\n\n   If either endpoint detects that the s.ceb counter has increased but\n   the s.cep has not (and by testing ACK coverage it is certain how much\n   the ACE field has wrapped), and if there is no explanation other than\n   an invalid protocol transition due to some form of feedback mangling,\n   the Data Sender MUST disable sending ECN-capable packets for the\n   remainder of the half-connection by setting the IP-ECN field in all\n   subsequent packets to Not-ECT. \n\n\n\n\n\n\n\n3.2.3.3. Usage of the AccECN TCP Option\n\n   If a Data Receiver in AccECN mode intends to use AccECN TCP Options\n   to provide feedback, the rules below determine when it includes an\n   AccECN TCP Option, and which fields to include, given other options\n   might be competing for limited option space:\n\n   Importance of Congestion Control:  AccECN is for congestion control,\n      which implementations SHOULD generally prioritize over other TCP\n      options when there is insufficient space for all the options in\n      use.\n\n      If SACK has been negotiated [RFC2018], and the smallest\n      recommended AccECN Option would leave insufficient space for two\n      SACK blocks on a particular ACK, the Data Receiver MUST give\n      precedence to the SACK option (total 18 octets), because loss\n      feedback is more critical.\n\n   Recommended Simple Scheme:  The Data Receiver SHOULD include an\n      AccECN TCP Option on every scheduled ACK if any byte counter has\n      incremented since the last ACK.  Whenever possible, it SHOULD\n      include a field for every byte counter that has changed at some\n      time during the connection (see examples later).\n\n      A scheduled ACK means an ACK that the Data Receiver would send by\n      its regular delayed ACK rules.  Recall that Section 1.3 defines an\n      'ACK' as either with data payload or without.  But the above rule\n      is worded so that, in the common case when most of the data is\n      from a Server to a Client, the Server only includes an AccECN TCP\n      Option while it is acknowledging data from the Client.\n\n   When available TCP option space is limited on particular packets, the\n   recommended scheme will need to include compromises.  To guide the\n   implementer the rules below are ranked in order of importance, but\n   the final decision has to be implementation-dependent, because\n   tradeoffs will alter as new TCP options are defined and new use-cases\n   arise.\n\n   Necessary Option Length:  When TCP option space is limited, an AccECN\n      TCP option MAY be truncated to omit one or two fields from the end\n      of the option, as indicated by the permitted variants listed in\n      Table 5, provided that the counter(s) that have changed since the\n      previous AccECN TCP option are not omitted.\n\n      If there is insufficient space to include an AccECN TCP option\n      containing the counter(s) that have changed since the previous\n      AccECN TCP option, then the entire AccECN TCP option MUST be\n      omitted. (see Section 3.2.3);\n   Change-Triggered AccECN TCP Options:  If an arriving packet\n      increments a different byte counter to that incremented by the\n      previous packet, the Data Receiver SHOULD feed it back in an\n      AccECN Option on the next scheduled ACK.\n\n      For the avoidance of doubt, this rule does not concern the arrival\n      of control packets with no payload, because they cannot alter any\n      byte counters.\n\n   Continual Repetition:  Otherwise, if arriving packets continue to\n      increment the same byte counter:\n\n      *  the Data Receiver SHOULD include a counter that has continued\n         to increment on the next scheduled ACK following a change-\n         triggered AccECN TCP Option;\n\n      *  while the same counter continues to increment, it SHOULD\n         include the counter every n ACKs as consistently as possible,\n         where n can be chosen by the implementer;\n\n      *  It SHOULD always include an AccECN Option if the r.ceb counter\n         is incrementing and it MAY include an AccECN Option if r.ec0b\n         or r.ec1b is incrementing\n\n      *  It SHOULD include each counter at least once for every 2^22\n         bytes incremented to prevent overflow during continual\n         repetition.\n\n   The above rules complement those in Section 3.2.2.5, which determine\n   when to generate an ACK irrespective of whether an AccECN TCP Option\n   is to be included.\n\n   The recommended scheme is intended as a simple way to ensure that all\n   the relevant byte counters will be carried on any ACK that reaches\n   the Data Sender, no matter how many pure ACKs are filtered or\n   coalesced along the network path, and without consuming the space\n   available for payload data with counter field(s) that have never\n   changed.\n\n   As an example of the recommended scheme, if ECT(0) is the only\n   codepoint that has ever arrived in the IP-ECN field, the Data\n   Receiver will feed back an AccECN0 TCP Option with only the EE0B\n   field on every packet that acknowledges new data.  However, as soon\n   as even one CE-marked packet arrives, on every packet that\n   acknowledges new data it will start to include an option with two\n   fields, EE0B and ECEB.  As a second example, if the first packet to\n   arrive happens to be CE-marked, the Data Receiver will have to\n   arbitrarily choose whether to precede the ECEB field with an EE0B \n   field or an EE1B field.  If it chooses, say, EEB0 but it turns out\n   never to receive ECT(0), it can start sending EE1B and ECEB instead -\n   it does not have to include the EE0B field if the r.e0b counter has\n   never changed during the connection.\n\n   With the recommended scheme, if the data sending direction switches\n   during a connection, there can be cases where the AccECN TCP Option\n   that is meant to feed back the counter values at the end of a volley\n   in one direction never reaches the other peer, due to packet loss.\n   ACE feedback ought to be sufficient to fill this gap, given accurate\n   feedback becomes moot after data transmission has paused. Appendix A.3 gives an example algorithm to estimate the number of\n   marked bytes from the ACE field alone, if AccECN Options are not\n   available.\n\n   If a host has determined that segments with AccECN Options always\n   seem to be discarded somewhere along the path, it is no longer\n   obliged to follow any of the rules in this section.\n\n\n\n\n3.3. AccECN Compliance Requirements for TCP Proxies, Offload Engines\n\n\n      and other Middleboxes    Given AccECN alters the TCP protocol on the wire, this section\n   specifies new requirements on certain networking equipment that\n   forwards TCP and inspects TCP header information.\n\n3.3.1. Requirements for TCP Proxies\n\n   A large class of middleboxes split TCP connections.  Such a middlebox\n   would be compliant with the AccECN protocol if the TCP implementation\n   on each side complied with the present AccECN specification and each\n   side negotiated AccECN independently of the other side.\n\n\n3.3.2. Requirements for Transparent Middleboxes and TCP Normalizers\n\n   Another large class of middleboxes intervenes to some degree at the\n   transport layer, but attempts to be transparent (invisible) to the\n   end-to-end connection.  A subset of this class of middleboxes\n   attempts to `normalize' the TCP wire protocol by checking that all\n   values in header fields comply with a rather narrow interpretation of\n   the TCP specifications that is also not always up to date.\n\n   A middlebox that is not normalizing the TCP protocol and does not\n   itself act as a back-to-back pair of TCP endpoints (i.e., a middlebox\n   that intends to be transparent or invisible at the transport layer)\n   ought to forward AccECN TCP Options unaltered, whether or not the\n   length value matches one of those specified in Section 3.2.3, and \n   whether or not the initial values of the byte-counter fields match\n   those in Section 3.2.1.  This is because blocking apparently invalid\n   values prevents the standardized set of values being extended in\n   future (such outdated normalizers would block updated hosts from\n   using the extended AccECN standard).\n\n   A TCP normalizer is likely to block or alter an AccECN TCP Option if\n   the length value or the initial values of its byte-counter fields do\n   not match one of those specified in Section 3.2.3 or Section 3.2.1.\n   However, to comply with the present AccECN specification, a middlebox\n   MUST NOT change the ACE field; or those fields of an AccECN Option\n   that are currently specified in Section 3.2.3; or any AccECN field\n   covered by integrity protection (e.g., [RFC5925]).\n\n\n3.3.3. Requirements for TCP ACK Filtering\n\n\n\n   Section 5.2.1 of BCP 69 [RFC3449] gives best current practice on\n   filtering (aka. thinning or coalescing) of pure TCP ACKs.  It advises\n   that filtering ACKs carrying ECN feedback ought to preserve the\n   correct operation of ECN feedback.  As the present specification\n   updates the operation of ECN feedback, this section discusses how an\n   ACK filter might preserve correct operation of AccECN feedback as\n   well.\n\n   The problem divides into two parts: determining if an ACK is part of\n   a connection that is using AccECN and then preserving the correct\n   operation of AccECN feedback:\n\n   *  To determine whether a pure TCP ACK is part of an AccECN\n      connection without resorting to connection tracking and per-flow\n      state, a useful heuristic would be to check for a non-zero ECN\n      field at the IP layer (because the ECN++ experiment only allows\n      TCP pure ACKs to be ECN-capable if AccECN has been negotiated\n      [I-D.ietf-tcpm-generalized-ecn ]).  This heuristic is simple and\n      stateless.  However, it might omit some AccECN ACKs, because\n      AccECN can be used without ECN++ and even if it is, ECN++ does not\n      have to make pure ACKs ECN-capable - only deployment experience\n      will tell.  Also, TCP ACKs might be ECN-capable owing to some\n      scheme other than AccECN, e.g., [RFC5690] or some future standards\n      action.  Again, only deployment experience will tell.\n\n   *  The main concern with preserving correct AccECN operation involves\n      leaving enough ACKs for the Data Sender to work out whether the\n      3-bit ACE field has wrapped.  In the worst case, in feedback about\n      a run of received packets that were all ECN-marked, the ACE field\n      will wrap every 8 acknowledged packets.  ACE field wrap might be\n      of less concern if packets also carry AccECN TCP Options.\n      However, note that logic to read an AccECN TCP Option is optional \n      to implement (albeit recommended \u2014 see Section 3.2.3).  So one end\n      writing an AccECN TCP Option into a packet does not necessarily\n      imply that the other end will read it.\n\n   Note that the present specification of AccECN in TCP does not presume\n   to rely on any of the above ACK filtering behaviour in the network,\n   because it has to be robust against pre-existing network nodes that\n   do not distinguish AccECN ACKs, and robust against ACK loss during\n   overload more generally.\n\n\n3.3.4. Requirements for TCP Segmentation Offload and Large Receive\n\n\n        Offload    Hardware to offload certain TCP processing represents another large\n   class of middleboxes (even though it is often a function of a host's\n   network interface and rarely in its own 'box').\n\n   Offloading can happen in the transmit path, usually referred to as\n   TCP Segmentation Offload (TSO), and the receive path where it is\n   called Large Receive Offload (LRO).\n\n   In the transmit direction, with AccECN, all segments created from the\n   same super-segment should retain the same ACE field, which should\n   make TSO straighforward.\n\n   However, with TSO hardware that supports [RFC3168], the CWR bit is\n   usually masked out on the middle and last segment.  If applied to an\n   AccECN segment, this would change the ACE field, and would be\n   interpreted as having received numerous CE marks in the receive\n   direction.  Therefore, currently available TSO hardware with\n   [RFC3168] support may need some minor driver changes, to adjust the\n   bitmask for the first, middle and last segment processed with TSO.\n\n   Initially, when Classic ECN [RFC3168] and Accurate ECN flows coexist\n   on the same offloading engine, the host software may need to work\n   around incompatibilities (e.g., when only global configurable TSO TCP\n   Flag bitmasks are available), otherwise this would cause some issues.\n\n   One way around this could be to only negotiate for Accurate ECN, but\n   not offer a fall back to [RFC3168] ECN.  Another way could be to\n   allow TSO only as long as the CWR flag in the TCP header is not set -\n   at the cost of more processing overhead while the ACE field has this\n   bit set.\n\n   For LRO in the receive direction, a different issue may get exposed\n   with [RFC3168] ECN supporting hardware. \n   The ACE field changes with every received CE marking, so today's\n   receive offloading could lead to many interrupts in high congestion\n   situations.  Although that would be useful (because congestion\n   information is received sooner), it could also significantly increase\n   processor load, particularly in scenarios such as DCTCP or L4S where\n   the marking rate is generally higher.\n\n   Current offload hardware ejects a segment from the coalescing process\n   whenever the TCP ECN flags change.  In data centres it has been\n   fortunate for this offload hardware that DCTCP-style feedback changes\n   less often when there are long sequences of CE marks, which is more\n   common with a step marking threshold (but less likely the more short\n   flows are in the mix).  The ACE counter approach has been designed so\n   that coalescing can continue over arbitrary patterns of marking and\n   only needs to stop when the counter wraps.  Nonetheless, until the\n   particular offload hardware in use implements this more efficient\n   approach, it is likely to be more efficient for AccECN connections to\n   implement this counter-style logic using software segmentation\n   offload.\n\n   ECN encodes a varying signal in the ACK stream, so it is inevitable\n   that offload hardware will ultimately need to handle any form of ECN\n   feedback exceptionally.  The ACE field has been designed as a counter\n   so that it is straightforward for offload hardware to pass on the\n   highest counter, and to push a segment from its cache before the\n   counter wraps.  The purpose of working towards standardized TCP ECN\n   feedback is to reduce the risk for hardware developers, who would\n   otherwise have to guess which scheme is likely to become dominant.\n\n   The above process has been designed to enable a continuing\n   incremental deployment path - to more highly dynamic congestion\n   control.  Once offload hardware supports AccECN, it will be able to\n   coalesce efficiently for any sequence of marks, instead of relying\n   for efficiency on the long marking sequences from step marking.  In\n   the next stage, marking can evolve from a step to a ramp function.\n   That in turn will allow host congestion control algorithms to respond\n   faster to dynamics, while being backwards compatible with existing\n   host algorithms.\n\n\n\n4. Updates to RFC 3168\n\n   This section clarifies which parts of RFC3168 are updated and maps\n   them to the sections of the present AccECN specification that update\n   them:\n\n   *  The whole of \"6.1.1 TCP Initialization\" of [RFC3168] is updated by Section 3.1 of the present specification. \n   *  In \"6.1.2.  The TCP Sender\" of [RFC3168], all mentions of a\n      congestion response to an ECN-Echo (ECE) ACK packet are updated by Section 3.2 of the present specification to mean an increment to\n      the sender's count of CE-marked packets, s.cep.  And the\n      requirements to set the CWR flag no longer apply, as specified in Section 3.1.5 of the present specification.  Otherwise, the\n      remaining requirements in \"6.1.2.  The TCP Sender\" still stand.\n\n      It will be noted that RFC 8311 already updates, or potentially\n      updates, a number of the requirements in \"6.1.2.  The TCP Sender\". Section 6.1.2 of RFC 3168 extended standard TCP congestion control\n      [RFC5681] to cover ECN marking as well as packet drop.  Whereas,RFC 8311 enables experimentation with alternative responses to ECN\n      marking, if specified for instance by an experimental RFC on the\n      IETF document stream.  RFC 8311 also strengthened the statement\n      that \"ECT(0) SHOULD be used\" to a \"MUST\" (see [RFC8311] for the\n      details).\n\n   *  The whole of \"6.1.3.  The TCP Receiver\" of [RFC3168] is updated by Section 3.2 of the present specification, with the exception of\n      the last paragraph (about congestion response to drop and ECN in\n      the same round trip), which still stands.  Incidentally, this last\n      paragraph is in the wrong section, because it relates to \"TCP\n      Sender\" behaviour.\n\n   *  The following text within \"6.1.5.  Retransmitted TCP packets\":\n\n         \"the TCP data receiver SHOULD ignore the ECN field on arriving\n         data packets that are outside of the receiver's current\n         window.\"\n\n      is updated by more stringent acceptability tests for any packet\n      (not just data packets) in the present specification.\n      Specifically, in the normative specification of AccECN (Section 3)\n      only 'Acceptable' packets contribute to the ECN counters at the\n      AccECN receiver and Section 1.3 defines an Acceptable packet as\n      one that passes acceptability tests equivalent in strength to\n      those in both [RFC9293] and [RFC5961].\n\n   *  Sections 5.2, 6.1.1, 6.1.4, 6.1.5 and 6.1.6 of [RFC3168] prohibit\n      use of ECN on TCP control packets and retransmissions.  The\n      present specification does not update that aspect of RFC 3168, but\n      it does say what feedback an AccECN Data Receiver ought to provide\n      if it receives an ECN-capable control packet or retransmission.\n      This ensures AccECN is forward compatible with any future scheme\n      that allows ECN on these packets, as provided for in section 4.3\n      of [RFC8311] and as proposed in [I-D.ietf-tcpm-generalized-ecn ]. \n\n\n\n\n\n5. Interaction with TCP Variants\n\n   This section is informative, not normative.\n\n5.1. Compatibility with SYN Cookies\n\n   A TCP Server can use SYN Cookies (see Appendix A of [RFC4987]) to\n   protect itself from SYN flooding attacks.  It places minimal commonly\n   used connection state in the SYN/ACK, and deliberately does not hold\n   any state while waiting for the subsequent ACK (e.g., it closes the\n   thread).  Therefore it cannot record the fact that it entered AccECN\n   mode for both half-connections.  Indeed, it cannot even remember\n   whether it negotiated the use of Classic ECN [RFC3168].\n\n   Nonetheless, such a Server can determine that it negotiated AccECN as\n   follows.  If a TCP Server using SYN Cookies supports AccECN and if it\n   receives a pure ACK that acknowledges an ISN that is a valid SYN\n   cookie, and if the ACK contains an ACE field with the value 0b010 to\n   0b111 (decimal 2 to 7), the Server can infer the first two stages of\n   the handshake:\n\n   *  the TCP Client has to have requested AccECN support on the SYN;\n\n   *  then, even though the Server kept no state, it has to have\n      confirmed that it supported AccECN.\n\n   Therefore the Server can switch itself into AccECN mode, and continue\n   as if it had never forgotten that it switched itself into AccECN mode\n   earlier.\n\n   If the pure ACK that acknowledges a SYN cookie contains an ACE field\n   with the value 0b000 or 0b001, these values indicate that the TCP\n   Client did not request support for AccECN and therefore the Server\n   does not enter AccECN mode for this connection.  Further, 0b001 on\n   the ACK implies that the Server sent an ECN-capable SYN/ACK, which\n   was marked CE in the network, and the non-AccECN TCP Client fed this\n   back by setting ECE on the ACK of the SYN/ACK.\n\n\n5.2. Compatibility with TCP Experiments and Common TCP Options\n\n   AccECN is compatible (at least on paper) with the most commonly used\n   TCP options: MSS, time-stamp, window scaling, SACK and TCP-AO.  It is\n   also compatible with Multipath TCP (MPTCP [RFC8684]) and the\n   experimental TCP option TCP Fast Open (TFO [RFC7413]).  AccECN is\n   friendly to all these protocols, because space for TCP options is\n   particularly scarce on the SYN, where AccECN consumes zero additional\n   header space. \n   When option space is under pressure from other options,Section 3.2.3.3 provides guidance on how important it is to send an\n   AccECN Option relative to other options, and which fields are more\n   important to include.\n\n   Implementers of TFO need to take careful note of the recommendation\n   in Section 3.2.2.1.  That section recommends that, if the TCP Client\n   has successfully negotiated AccECN, when acknowledging the SYN/ACK,\n   even if it has data to send, it sends a pure ACK immediately before\n   the data.  Then it can reflect the IP-ECN field of the SYN/ACK on\n   this pure ACK, which allows the Server to detect ECN mangling.  Note\n   that, as specified in Section 3.2, any data on the SYN (SYN=1, ACK=0)\n   is not included in any of the byte counters held locally for each ECN\n   marking, nor in the AccECN Option on the wire.\n\n   AccECN feedback is compatible with the ECN++\n   [I-D.ietf-tcpm-generalized-ecn ] experiment, which allows TCP control\n   packets and retransmissions to be ECN-capable ([RFC3168] was updated\n   by [RFC8311] to permit such experiments).  AccECN is likely to\n   inherently support any experiment with ECN-capable packets, because\n   it feeds back the contents of the ECN field mechanistically, without\n   judging whether a packet ought to use the ECN capability or not\n   (Section 2.5).  This specification does not discuss implementing\n   AccECN alongside [RFC5562], which was an earlier experimental\n   protocol with narrower scope than ECN++ and a 5-way handshake.\n\n\n5.3. Compatibility with Feedback Integrity Mechanisms\n\n   Three alternative mechanisms are available to assure the integrity of\n   ECN and/or loss signals.  AccECN is compatible with any of these\n   approaches:\n\n   *  The Data Sender can test the integrity of the receiver's ECN (or\n      loss) feedback by occasionally setting the IP-ECN field to a value\n      normally only set by the network (and/or deliberately leaving a\n      sequence number gap).  Then it can test whether the Data\n      Receiver's feedback faithfully reports what it expects (similar to\n      paragraph 2 of Section 20.2 of [RFC3168]).  Unlike the ECN Nonce\n      [RFC3540], this approach does not waste the ECT(1) codepoint in\n      the IP header, it does not require standardization and it does not\n      rely on misbehaving receivers volunteering to reveal feedback\n      information that allows them to be detected.  However, setting the\n      CE mark by the sender might conceal actual congestion feedback\n      from the network and therefore ought to only be done sparingly.\n\n   *  Networks generate congestion signals when they are becoming\n      congested, so networks are more likely than Data Senders to be\n      concerned about the integrity of the receiver's feedback of these \n      signals.  A network can enforce a congestion response to its ECN\n      markings (or packet losses) using congestion exposure (ConEx)\n      audit [RFC7713].  Whether the receiver or a downstream network is\n      suppressing congestion feedback or the sender is unresponsive to\n      the feedback, or both, ConEx audit can neutralize any advantage\n      that any of these three parties would otherwise gain.\n\n      ConEx is an experimental change to the Data Sender that would be\n      most useful when combined with AccECN.  Without AccECN, the ConEx\n      behaviour of a Data Sender would have to be more conservative than\n      would be necessary if it had the accurate feedback of AccECN.\n\n   *  The standards track TCP authentication option (TCP-AO [RFC5925])\n      can be used to detect any tampering with AccECN feedback between\n      the Data Receiver and the Data Sender (whether malicious or\n      accidental).  The AccECN fields are immutable end-to-end, so they\n      are amenable to TCP-AO protection, which covers TCP options by\n      default.  However, TCP-AO is often too brittle to use on many end-\n      to-end paths, where middleboxes can make verification fail in\n      their attempts to improve performance or security, e.g., Network\n      Address (and Port) Translation (NAT/NAPT), resegmentation or\n      shifting the sequence space.\n\n\n6. Summary: Protocol Properties\n\n   This section is informative not normative.  It describes how well the\n   protocol satisfies the agreed requirements for a more Accurate ECN\n   feedback protocol [RFC7560].\n\n   Accuracy:  From each ACK, the Data Sender can infer the number of new\n      CE marked segments since the previous ACK.  This provides better\n      accuracy on CE feedback than Classic ECN.  In addition if an\n      AccECN Option is present (not blocked by the network path) the\n      number of bytes marked with CE, ECT(1) and ECT(0) are provided.\n\n   Overhead:  The AccECN scheme is divided into two parts.  The\n      essential feedback part reuses the 3 flags already assigned to ECN\n      in the TCP header.  The supplementary feedback part adds an\n      additional TCP option consuming up to 11 bytes.  However, no TCP\n      option space is consumed in the SYN.\n\n   Ordering:  The order in which marks arrive at the Data Receiver is\n      preserved in AccECN feedback, because the Data Receiver is\n      expected to send an ACK immediately whenever a different mark\n      arrives.\n\n   Timeliness:  While the same ECN markings are arriving continually at \n      the Data Receiver, it can defer ACKs as TCP does normally, but it\n      will immediately send an ACK as soon as a different ECN marking\n      arrives.\n\n   Timeliness vs Overhead:  Change-Triggered ACKs are intended to enable\n      latency-sensitive uses of ECN feedback by capturing the timing of\n      transitions but not wasting resources while the state of the\n      signalling system is stable.  Within the constraints of the\n      change-triggered ACK rules, the receiver can control how\n      frequently it sends AccECN TCP Options and therefore to some\n      extent it can control the overhead induced by AccECN.\n\n   Resilience:  All information is provided based on counters.\n      Therefore if ACKs are lost, the counters on the first ACK\n      following the losses allows the Data Sender to immediately recover\n      the number of the ECN markings that it missed.  And if data or\n      ACKs are reordered, stale congestion information can be identified\n      and ignored.\n\n   Resilience against Bias:  Because feedback is based on repetition of\n      counters, random losses do not remove any information, they only\n      delay it.  Therefore, even though some ACKs are change-triggered,\n      random losses will not alter the proportions of the different ECN\n      markings in the feedback.\n\n   Resilience vs Overhead:  If space is limited in some segments\n      (e.g., because more options are needed on some segments, such as\n      the SACK option after loss), the Data Receiver can send AccECN\n      Options less frequently or truncate fields that have not changed,\n      usually down to as little as 5 bytes.\n\n   Resilience vs Timeliness and Ordering:  Ordering information and the\n      timing of transitions cannot be communicated in three cases: i)\n      during ACK loss; ii) if something on the path strips AccECN\n      Options; or iii) if the Data Receiver is unable to support Change-\n      Triggered ACKs.  Following ACK reordering, the Data Sender can\n      reconstruct the order in which feedback was sent, but not until\n      all the missing feedback has arrived.\n\n   Complexity:  An AccECN implementation solely involves simple counter\n      increments, some modulo arithmetic to communicate the least\n      significant bits and allow for wrap, and some heuristics for\n      safety against fields cycling due to prolonged periods of ACK\n      loss.  Each host needs to maintain eight additional counters.  The\n      hosts have to apply some additional tests to detect tampering by\n      middleboxes, but in general the protocol is simple to understand,\n      simple to implement and requires few cycles per packet to execute. \n   Integrity:  AccECN is compatible with at least three approaches that\n      can assure the integrity of ECN feedback.  If AccECN Options are\n      stripped the resolution of the feedback is degraded, but the\n      integrity of this degraded feedback can still be assured.\n\n   Backward Compatibility:  If only one endpoint supports the AccECN\n      scheme, it will fall-back to the most advanced ECN feedback scheme\n      supported by the other end.\n\n      If AccECN Options are stripped by a middlebox, AccECN still\n      provides basic congestion feedback in the ACE field.  Further,\n      AccECN can be used to detect mangling of the IP ECN field;\n      mangling of the TCP ECN flags; blocking of ECT-marked segments;\n      and blocking of segments carrying an AccECN Option.  It can detect\n      these conditions during TCP's three-way handshake so that it can\n      fall back to operation without ECN and/or operation without AccECN\n      Options.\n\n   Forward Compatibility:  The behaviour of endpoints and middleboxes is\n      carefully defined for all reserved or currently unused codepoints\n      in the scheme.  Then, the designers of security devices can\n      understand which currently unused values might appear in future.\n      So, even if they choose to treat such values as anomalous while\n      they are not widely used, any blocking will at least be under\n      policy control not hard-coded.  Then, if previously unused values\n      start to appear on the Internet (or in standards), such policies\n      could be quickly reversed.\n\n7. IANA Considerations\n\n   This document reassigns the TCP header flag at bit offset 7 to the\n   AccECN protocol.  This bit was previously called the Nonce Sum (NS)\n   flag [RFC3540], but RFC 3540 has been reclassified as historic\n   [RFC8311].  The flag will now be defined as the following in the \"TCP\n   Header Flags\" registry in the \"Transmission Control Protocol (TCP)\n   Parameters\" registry group:\n\n     +=====+==============+===========+==============================+\n     | Bit | Name         | Reference | Assignment Notes             |\n     +=====+==============+===========+==============================+\n     | 7   | AE (Accurate | RFC XXXX  | Previously used as NS (Nonce |\n     |     | ECN)         |           | Sum) by [RFC3540], which is  |\n     |     |              |           | now historic [RFC8311]       |\n     +-----+--------------+-----------+------------------------------+\n\n                   Table 6: TCP header flag reassignment \n   [TO BE REMOVED: IANA is requested to update the existing entry in the\n   TCP Header Flags registry (https://www.iana.org/assignments/tcp-\n   parameters/tcp-parameters.xhtml#tcp-header-flags ) for Bit 7 to \"AE\n   (Accurate ECN)\" and to change the reference to this RFC-to-be instead\n   of RFC8311.  Also IANA is requested to change the assignment note to\n   \"Previously used as NS (Nonce Sum) by [RFC3540], which is now\n   historic [RFC8311].\"]\n\n   This document also defines two new TCP options for AccECN, assigned\n   values of 172 and 174 (decimal) from the TCP option space.  These\n   values are defined as the following in the \"TCP Option Kind Numbers\"\n   registry in the \"Transmission Control Protocol (TCP) Parameters\"\n   registry group:\n\n      +======+========+================================+===========+\n      | Kind | Length | Meaning                        | Reference |\n      +======+========+================================+===========+\n      | 172  | N      | Accurate ECN Order 0 (AccECN0) | RFC XXXX  |\n      +------+--------+--------------------------------+-----------+\n      | 174  | N      | Accurate ECN Order 1 (AccECN1) | RFC XXXX  |\n      +------+--------+--------------------------------+-----------+\n\n                   Table 7: New TCP Option assignments\n\n   [TO BE REMOVED: These registrations have taken place using the early\n   registration procedure, which may be temporary if this draft does not\n   proceed, at the following location: http://www.iana.org/assignments/\n   tcp-parameters/tcp-parameters.xhtml#tcp-parameters-1 ]\n\n   Early experimental implementations of the two AccECN Options used\n   experimental option 254 per [RFC6994] with the 16-bit magic numbers\n   0xACC0 and 0xACC1 respectively for Order 0 and 1, as allocated in the\n   IANA \"TCP Experimental Option Experiment Identifiers (TCP ExIDs)\"\n   registry.  Even earlier experimental implementations used the single\n   magic number 0xACCE (16 bits).  Uses of these experimental options\n   SHOULD migrate to use the new option kinds (172 & 174).\n\n   [TO BE REMOVED: IANA is requested to replace the references for all\n   three of the above experimental options (0xACC0, 0xACC1 and 0xACCE)\n   with a reference to the present RFC XXXX.]\n\n   [TO BE REMOVED: If the early registrations, which may be temporary,\n   do not proceed, the three references to them in the TCP ExIDs\n   registry at the following location will also need to be edited out:https://www.iana.org/assignments/tcp-parameters/tcp-\n   parameters.xhtml#tcp-exids  ]\n\n\n\n\n\n8. Security and Privacy Considerations\n\n   If ever the supplementary feedback part of AccECN based on one of the\n   new AccECN TCP Options is unusable (due for example to middlebox\n   interference) the essential feedback part of AccECN's congestion\n   feedback offers only limited resilience to long runs of ACK loss (see Section 3.2.2.5).  These problems are unlikely to be due to malicious\n   intervention (because if an attacker could strip a TCP option or\n   discard a long run of ACKs it could wreak other arbitrary havoc).\n   However, it would be of concern if AccECN's resilience could be\n   indirectly compromised during a flooding attack.  AccECN is still\n   considered safe though, because if AccECN Options are not present,\n   the AccECN Data Sender is then required to switch to more\n   conservative assumptions about wrap of congestion indication counters\n   (see Section 3.2.2.5 and Appendix A.2). Section 5.1 describes how a TCP Server can negotiate AccECN and use\n   the SYN cookie method for mitigating SYN flooding attacks.\n\n   There is concern that ECN feedback could be altered or suppressed,\n   particularly because a misbehaving Data Receiver could increase its\n   own throughput at the expense of others.  AccECN is compatible with\n   the three schemes known to assure the integrity of ECN feedback (see Section 5.3 for details).  If AccECN Options are stripped by an\n   incorrectly implemented middlebox, the resolution of the feedback\n   will be degraded, but the integrity of this degraded information can\n   still be assured.  Assuring that Data Senders respond appropriately\n   to ECN feedback is possible, but the scope of the present document is\n   confined to the feedback protocol, and excludes the response to this\n   feedback.\n\n   In Section 3.2.3 a Data Sender is allowed to ignore an unrecognized\n   TCP AccECN Option length and read as many whole 3-octet fields from\n   it as possible up to a maximum of 3, treating the remainder as\n   padding.  This opens up a potential covert channel of up to 29B (40 -\n   (2+3*3)) B.  However, it is really an overt channel (not hidden) and\n   it is no different to the use of unknown TCP options with unknown\n   option lengths in general.  Therefore, where this is of concern, it\n   can already be adequately mitigated by regular TCP normalizer\n   technology (see Section 3.3.2).\n\n   The AccECN protocol is not believed to introduce any new privacy\n   concerns, because it merely counts and feeds back signals at the\n   transport layer that had already been visible at the IP layer.  A\n   covert channel can be used to compromise privacy.  However, as\n   explained above, undefined TCP options in general open up such\n   channels and common techniques are available to close them off. \n   There is a potential concern that a Data Receiver could deliberately\n   omit AccECN Options pretending that they had been stripped by a\n   middlebox.  No known way can yet be contrived for a receiver to take\n   advantage of this behaviour, which seems to always degrade its own\n   performance.  However, the concern is mentioned here for\n   completeness.\n\n   A generic privacy concern of any new protocol is that for a while it\n   will be used by a small population of hosts, and thus show up more\n   easily.  However, it is expected that this option will become\n   available in operating systems over time, and eventually turned on by\n   default in them.  Thus a individual identification of a particular\n   user is less of a concern than the fingerprinting of specific\n   versions of operation systems.  However, the latter can be done using\n   different means independent of Accurate ECN.\n\n   As Accurate ECN exposes more bits in the TCP header which could be\n   tampered with without interfering with the transport excessively, it\n   may allow an additional way to identify specific data streams across\n   a virtual private network (VPN) to an attacker which has access to\n   the datastream before and after the VPN tunnel endpoints.  This may\n   be achieved by injecting or modifying the ACE field in specific\n   patters that can be recognized.\n\n   Overall, Accurate ECN does not change the risk profile on privacy to\n   a user dramatically beyond what is already possible using classic\n   ECN.  However, in order to prevent such attacks and means of easier\n   identification of flows, it is adviseable for privacy conscious users\n   behind VPNs to not enable the Accurate ECN, or Classic ECN for that\n   matter.\n\nA. Example Algorithms\n\n   This appendix is informative, not normative.  It gives example\n   algorithms that would satisfy the normative requirements of the\n   AccECN protocol.  However, implementers are free to choose other ways\n   to implement the requirements.\n\nA.1. Example Algorithm to Encode/Decode the AccECN Option\n\n   The example algorithms below show how a Data Receiver in AccECN mode\n   could encode its CE byte counter r.ceb into the ECEB field within an\n   AccECN TCP Option, and how a Data Sender in AccECN mode could decode\n   the ECEB field into its byte counter s.ceb.  The other counters for\n   bytes marked ECT(0) and ECT(1) in an AccECN Option would be similarly\n   encoded and decoded.\n\n   It is assumed that each local byte counter is an unsigned integer\n   greater than 24b (probably 32b), and that the following constant has\n   been assigned:\n\n      DIVOPT = 2^24\n\n   Every time a CE marked data segment arrives, the Data Receiver\n   increments its local value of r.ceb by the size of the TCP Data.\n   Whenever it sends an ACK with an AccECN Option, the value it writes\n   into the ECEB field is\n\n      ECEB = r.ceb % DIVOPT \n   where '%' is the remainder operator.\n\n   On the arrival of an AccECN Option, the Data Sender first makes sure\n   the ACK has not been superseded in order to avoid winding the s.ceb\n   counter backwards.  It uses the TCP acknowledgement number and any\n   SACK options [RFC2018] to calculate newlyAckedB, the amount of new\n   data that the ACK acknowledges in bytes (newlyAckedB can be zero but\n   not negative).  If newlyAckedB is zero, either the ACK has been\n   superseded or CE-marked packet(s) without data could have arrived.\n   To break the tie for the latter case, the Data Sender could use time-\n   stamps [RFC7323] (if present) to work out newlyAckedT, the amount of\n   new time that the ACK acknowledges.  If the Data Sender determines\n   that the ACK has been superseded it ignores the AccECN Option.\n   Otherwise, the Data Sender calculates the minimum non-negative\n   difference d.ceb between the ECEB field and its local s.ceb counter,\n   using modulo arithmetic as follows:\n\n      if ((newlyAckedB > 0) || (newlyAckedT > 0)) {\n          d.ceb = (ECEB + DIVOPT - (s.ceb % DIVOPT)) % DIVOPT\n          s.ceb += d.ceb\n      }\n\n   For example, if s.ceb is 33,554,433 and ECEB is 1461 (both decimal),\n   then\n\n      s.ceb % DIVOPT = 1\n      d.ceb = (1461 + 2^24 - 1) % 2^24\n            = 1460\n      s.ceb = 33,554,433 + 1460\n            = 33,555,893\n\n   In practice an implementation might use heuristics to guess the\n   feedback in missing ACKs, then when it subsequently receives feedback\n   it might find that it needs to correct its earlier heuristics as part\n   of the decoding process.  The above decoding process does not include\n   any such heuristics.\n\n\nA.2. Example Algorithm for Safety Against Long Sequences of ACK Loss\n\n   The example algorithms below show how a Data Receiver in AccECN mode\n   could encode its CE packet counter r.cep into the ACE field, and how\n   the Data Sender in AccECN mode could decode the ACE field into its\n   s.cep counter.  The Data Sender's algorithm includes code to\n   heuristically detect a long enough unbroken string of ACK losses that\n   could have concealed a cycle of the congestion counter in the ACE\n   field of the next ACK to arrive. \n   Two variants of the algorithm are given: i) a more conservative\n   variant for a Data Sender to use if it detects that AccECN Options\n   are not available (see Section 3.2.2.5 and Section 3.2.3.2); and ii)\n   a less conservative variant that is feasible when complementary\n   information is available from AccECN Options.\n\nA.2.1. Safety Algorithm without the AccECN Option\n\n   It is assumed that each local packet counter is a sufficiently sized\n   unsigned integer (probably 32b) and that the following constant has\n   been assigned:\n\n      DIVACE = 2^3\n\n   Every time an Acceptable CE marked packet arrives (Section 3.2.2.2),\n   the Data Receiver increments its local value of r.cep by 1.  It\n   repeats the same value of ACE in every subsequent ACK until the next\n   CE marking arrives, where\n\n      ACE = r.cep % DIVACE.\n\n   If the Data Sender received an earlier value of the counter that had\n   been delayed due to ACK reordering, it might incorrectly calculate\n   that the ACE field had wrapped.  Therefore, on the arrival of every\n   ACK, the Data Sender ensures the ACK has not been superseded using\n   the TCP acknowledgement number, any SACK options and timestamps (if\n   available) to calculate newlyAckedB, as in Appendix A.1.  If the ACK\n   has not been superseded, the Data Sender calculates the minimum\n   difference d.cep between the ACE field and its local s.cep counter,\n   using modulo arithmetic as follows:\n\n      if ((newlyAckedB > 0) || (newlyAckedT > 0))\n          d.cep = (ACE + DIVACE - (s.cep % DIVACE)) % DIVACE Section 3.2.2.5 expects the Data Sender to assume that the ACE field\n   cycled if it is the safest likely case under prevailing conditions.\n   The 3-bit ACE field in an arriving ACK could have cycled and become\n   ambiguous to the Data Sender if a sequence of ACKs goes missing that\n   covers a stream of data long enough to contain 8 or more CE marks.\n   We use the word `missing' rather than `lost', because some or all the\n   missing ACKs might arrive eventually, but out of order.  Even if some\n   of the missing ACKs were piggy-backed on data (i.e., not pure ACKs)\n   retransmissions will not repair the lost AccECN information, because\n   AccECN requires retransmissions to carry the latest AccECN counters,\n   not the original ones. \n   The phrase `under prevailing conditions' allows for implementation-\n   dependent interpretation.  A Data Sender might take account of the\n   prevailing size of data segments and the prevailing CE marking rate\n   just before the sequence of missing ACKs.  However, we shall start\n   with the simplest algorithm, which assumes segments are all full-\n   sized and ultra-conservatively it assumes that ECN marking was 100%\n   on the forward path when ACKs on the reverse path started to all be\n   dropped.  Specifically, if newlyAckedB is the amount of data that an\n   ACK acknowledges since the previous ACK, then the Data Sender could\n   assume that this acknowledges newlyAckedPkt full-sized segments,\n   where newlyAckedPkt = newlyAckedB/MSS.  Then it could assume that the\n   ACE field incremented by\n\n       dSafer.cep = newlyAckedPkt - ((newlyAckedPkt - d.cep) % DIVACE),\n\n   For example, imagine an ACK acknowledges newlyAckedPkt=9 more full-\n   size segments than any previous ACK, and that ACE increments by a\n   minimum of 2 CE marks (d.cep=2).  The above formula works out that it\n   would still be safe to assume 2 CE marks (because 9 - ((9-2) % 8) =\n   2).  However, if ACE increases by a minimum of 2 but acknowledges 10\n   full-sized segments, then it would be necessary to assume that there\n   could have been 10 CE marks (because 10 - ((10-2) % 8) = 10).\n\n   Note that checks would need to be added to the above pseudocode for\n   (d.cep > newlyAckedPkt), which could occur if newlyAckedPkt had been\n   wrongly estimated using an inappropriate packet size.\n\n   ACKs that acknowledge a large stretch of packets might be common in\n   data centres to achieve a high packet rate or might be due to ACK\n   thinning by a middlebox.  In these cases, cycling of the ACE field\n   would often appear to have been possible, so the above algorithm\n   would be over-conservative, leading to a false high marking rate and\n   poor performance.  Therefore it would be reasonable to only use\n   dSafer.cep rather than d.cep if the moving average of newlyAckedPkt\n   was well below 8.\n\n   Implementers could build in more heuristics to estimate prevailing\n   average segment size and prevailing ECN marking.  For instance,\n   newlyAckedPkt in the above formula could be replaced with\n   newlyAckedPktHeur = newlyAckedPkt*p*MSS/s, where s is the prevailing\n   segment size and p is the prevailing ECN marking probability.\n   However, ultimately, if TCP's ECN feedback becomes inaccurate it\n   still has loss detection to fall back on.  Therefore, it would seem\n   safe to implement a simple algorithm, rather than a perfect one. \n   The simple algorithm for dSafer.cep above requires no monitoring of\n   prevailing conditions and it would still be safe if, for example,\n   segments were on average at least 5% of full-sized as long as ECN\n   marking was 5% or less.  Assuming it was used, the Data Sender would\n   increment its packet counter as follows:\n\n      s.cep += dSafer.cep\n\n   If missing acknowledgement numbers arrive later (due to reordering),Section 3.2.2.5 says \"the Data Sender MAY attempt to neutralize the\n   effect of any action it took based on a conservative assumption that\n   it later found to be incorrect\".  To do this, the Data Sender would\n   have to store the values of all the relevant variables whenever it\n   made assumptions, so that it could re-evaluate them later.  Given\n   this could become complex and it is not required, we do not attempt\n   to provide an example of how to do this.\n\n\nA.2.2. Safety Algorithm with the AccECN Option\n\n   When AccECN Options are available on the ACKs before and after the\n   possible sequence of ACK losses, if the Data Sender only needs CE-\n   marked bytes, it will have sufficient information in AccECN Options\n   without needing to process the ACE field.  If for some reason it\n   needs CE-marked packets, if dSafer.cep is different from d.cep, it\n   can determine whether d.cep is likely to be a safe enough estimate by\n   checking whether the average marked segment size (s = d.ceb/d.cep) is\n   less than the MSS (where d.ceb is the amount of newly CE-marked bytes\n   - see Appendix A.1).  Specifically, it could use the following\n   algorithm:\n\n      SAFETY_FACTOR = 2\n      if (dSafer.cep > d.cep) {\n          if (d.ceb <= MSS * d.cep) {  % Same as (s <= MSS), but no DBZ\n             sSafer = d.ceb/dSafer.cep\n             if (sSafer < MSS/SAFETY_FACTOR)\n                 dSafer.cep = d.cep    % d.cep is a safe enough estimate\n          } % else\n              % No need for else; dSafer.cep is already correct,\n              % because d.cep must have been too small\n      }\n\n   The chart below shows when the above algorithm will consider d.cep\n   can replace dSafer.cep as a safe enough estimate of the number of CE-\n   marked packets:\n                    ^\n              sSafer|\n                    |\n                 MSS+\n                    |\n                    |         dSafer.cep\n                    |                  is\n   MSS/SAFETY_FACTOR+--------------+    safest\n                    |              |\n                    | d.cep is safe|\n                    |    enough    |\n                    +-------------------->\n                                  MSS     s\n\n   The following examples give the reasoning behind the algorithm,\n   assuming MSS=1460 :\n\n   *  if d.cep=0, dSafer.cep=8 and d.ceb=1460, then s=infinity and\n      sSafer=182.5.\n\n      Therefore even though the average size of 8 data segments is\n      unlikely to have been as small as MSS/8, d.cep cannot have been\n      correct, because it would imply an average segment size greater\n      than the MSS.\n\n   *  if d.cep=2, dSafer.cep=10 and d.ceb=1460, then s=730 and\n      sSafer=146.\n\n      Therefore d.cep is safe enough, because the average size of 10\n      data segments is unlikely to have been as small as MSS/10.\n\n   *  if d.cep=7, dSafer.cep=15 and d.ceb=10200, then s=1457 and\n      sSafer=680.\n\n      Therefore d.cep is safe enough, because the average data segment\n      size is more likely to have been just less than one MSS, rather\n      than below MSS/2.\n\n   If pure ACKs were allowed to be ECN-capable, missing ACKs would be\n   far less likely.  However, because [RFC3168] currently precludes\n   this, the above algorithm assumes that pure ACKs are not ECN-capable. \n\n\n\n\n\n\n\nA.3. Example Algorithm to Estimate Marked Bytes from Marked Packets\n\n   If AccECN Options are not available, the Data Sender can only decode\n   CE-marking from the ACE field in packets.  Every time an ACK arrives,\n   to convert this into an estimate of CE-marked bytes, it needs an\n   average of the segment size, s_ave.  Then it can add or subtract\n   s_ave from the value of d.ceb as the value of d.cep increments or\n   decrements.  Some possible ways to calculate s_ave are outlined\n   below.  The precise details will depend on why an estimate of marked\n   bytes is needed.\n\n   The implementation could keep a record of the byte numbers of all the\n   boundaries between packets in flight (including control packets), and\n   recalculate s_ave on every ACK.  However it would be simpler to\n   merely maintain a counter packets_in_flight for the number of packets\n   in flight (including control packets), which is reset once per RTT.\n   Either way, it would estimate s_ave as:\n\n      s_ave ~= flightsize / packets_in_flight,\n\n   where flightsize is the variable that TCP already maintains for the\n   number of bytes in flight and '~=' means 'approximately equal to'.\n   To avoid floating point arithmetic, it could right-bit-shift by\n   lg(packets_in_flight), where lg() means log base 2.\n\n   An alternative would be to maintain an exponentially weighted moving\n   average (EWMA) of the segment size:\n\n      s_ave = a * s + (1-a) * s_ave,\n\n   where a is the decay constant for the EWMA.  However, then it is\n   necessary to choose a good value for this constant, which ought to\n   depend on the number of packets in flight.  Also the decay constant\n   needs to be power of two to avoid floating point arithmetic.\n\n\nA.4. Example Algorithm to Count Not-ECT Bytes\n\n   A Data Sender in AccECN mode can infer the amount of TCP payload data\n   arriving at the receiver marked Not-ECT from the difference between\n   the amount of newly ACKed data and the sum of the bytes with the\n   other three markings, d.ceb, d.e0b and d.e1b.\n\n   For this approach to be precise, it has to be assumed that spurious\n   (unnecessary) retransmissions do not lead to double counting.  This\n   assumption is currently correct, given that RFC 3168 requires that\n   the Data Sender marks retransmitted segments as Not-ECT.  However,\n   the converse is not true; necessary retransmissions will result in\n   under-counting. \n   However, such precision is unlikely to be necessary.  The only known\n   use of a count of Not-ECT marked bytes is to test whether equipment\n   on the path is clearing the ECN field (perhaps due to an out-dated\n   attempt to clear, or bleach, what used to be the IPv4 ToS byte or the\n   IPv6 Traffic Class field).  To detect bleaching it will be sufficient\n   to detect whether nearly all bytes arrive marked as Not-ECT.\n   Therefore there ought to be no need to keep track of the details of\n   retransmissions.\n\n\nB. Rationale for Usage of TCP Header Flags\n\n\n\n\n\nB.1. Three TCP Header Flags in the SYN-SYN/ACK Handshake\n\n   AccECN uses a rather unorthodox approach to negotiate the highest\n   version TCP ECN feedback scheme that both ends support, as justified\n   below.  It follows from the original TCP ECN capability negotiation\n   [RFC3168], in which the Client set the 2 least significant of the\n   original reserved flags in the TCP header, and fell back to no ECN\n   support if the Server responded with the 2 flags cleared, which had\n   previously been the default.\n\n   Classic ECN used header flags rather than a TCP option because it was\n   considered more efficient to use a header flag for 1 bit of feedback\n   per ACK, and this bit could be overloaded to indicate support for\n   Classic ECN during the handshake.  During the development of ECN, 1\n   bit crept up to 2, in order to deliver the feedback reliably and to\n   work round some broken hosts that reflected the reserved flags during\n   the handshake.\n\n   In order to be backward compatible with RFC 3168, AccECN continues\n   this approach, using the 3rd least significant TCP header flag that\n   had previously been allocated for the ECN nonce (now historic).\n   Then, whatever form of Server an AccECN Client encounters, the\n   connection can fall back to the highest version of feedback protocol\n   that both ends support, as explained in Section 3.1.\n\n   If AccECN capability negotiation had used the more orthodox approach\n   of a TCP option, it would still have had to set the two ECN flags in\n   the main TCP header, in order to be able to fall back to Classic RFC \n   3168 ECN, or to disable ECN support, without another round of\n   negotiation.  Then AccECN would also have had to handle all the\n   different ways that Servers currently respond to settings of the ECN\n   flags in the main TCP header, including all the conflicting cases\n   where a Server might have said it supported one approach in the flags\n   and another approach in a new TCP option.  And AccECN would have had\n   to deal with all the additional possibilities where a middlebox might\n   have mangled the ECN flags, or removed TCP options.  Thus, usage of\n   the 3rd reserved TCP header flag simplified the protocol. \n   The third flag was used in a way that could be distinguished from the\n   ECN nonce, in case any nonce deployment was encountered.  Previous\n   usage of this flag for the ECN nonce was integrated into the original\n   ECN negotiation.  This further justified the 3rd flag's use for\n   AccECN, because a non-ECN usage of this flag would have had to use it\n   as a separate single bit, rather than in combination with the other 2\n   ECN flags.\n\n   Indeed, having overloaded the original uses of these three flags for\n   its handshake, AccECN overloads all three bits again as a 3-bit\n   counter.\n\n\nB.2. Four Codepoints in the SYN/ACK\n\n   Of the 8 possible codepoints that the 3 TCP header flags can indicate\n   on the SYN/ACK, 4 already indicated earlier (or broken) versions of\n   ECN support, 1 now being historic.  In the early design of AccECN, an\n   AccECN Server could use only 2 of the 4 remaining codepoints.  They\n   both indicated AccECN support, but one fed back that the SYN had\n   arrived marked as CE.  Even though ECN support on a SYN is not yet on\n   the standards track, the idea is for either end to act as a\n   mechanistic reflector, so that future capabilities can be\n   unilaterally deployed without requiring 2-ended deployment (justified\n   in Section 2.5).\n\n   During traversal testing it was discovered that the IP-ECN field in\n   the SYN was mangled on a non-negligible proportion of paths.\n   Therefore it was necessary to allow the SYN/ACK to feed all four IP-\n   ECN codepoints that the SYN could arrive with back to the Client.\n   Without this, the Client could not know whether to disable ECN for\n   the connection due to mangling of the IP-ECN field (also explained in Section 2.5).  This development consumed the remaining 2 codepoints\n   on the SYN/ACK that had been reserved for future use by AccECN in\n   earlier versions.\n\n\nB.3. Space for Future Evolution\n\n   Despite availability of usable TCP header space being extremely\n   scarce, the AccECN protocol has taken all possible steps to ensure\n   that there is space to negotiate possible future variants of the\n   protocol, either if a variant of AccECN is required, or if a\n   completely different ECN feedback approach is needed:\n\n   Future AccECN variants:  When the AccECN capability is negotiated\n      during TCP's three-way handshake, the rows in Table 2 tagged as\n      'Nonce' and 'Broken' in the column for the capability of node B\n      are unused by any current protocol in the RFC series.  These could\n      be used by TCP Servers in future to indicate a variant of the \n      AccECN protocol.  In recent measurement studies in which the\n      response of large numbers of Servers to an AccECN SYN has been\n      tested, e.g., [Mandalari18], a very small number of SYN/ACKs\n      arrive with the pattern tagged as 'Nonce', and a small but more\n      significant number arrive with the pattern tagged as 'Broken'.\n      The 'Nonce' pattern could be a sign that a few Servers have\n      implemented the ECN Nonce [RFC3540], which has now been\n      reclassified as historic [RFC8311], or it could be the random\n      result of some unknown middlebox behaviour.  The greater\n      prevalence of the 'Broken' pattern suggests that some instances\n      still exist of the broken code that reflects the reserved flags on\n      the SYN.\n\n      The requirement not to reject unexpected initial values of the ACE\n      counter (in the main TCP header) in the last paragraph of Section 3.2.2.4 ensures that 3 unused codepoints on the ACK of the\n      SYN/ACK, 6 unused values on the first SYN=0 data packet from the\n      Client and 7 unused values on the first SYN=0 data packet from the\n      Server could be used to declare future variants of the AccECN\n      protocol.  The word 'declare' is used rather than 'negotiate'\n      because, at this late stage in the three-way handshake, it would\n      be too late for a negotiation between the endpoints to be\n      completed.  A similar requirement not to reject unexpected initial\n      values in AccECN TCP Options (Section 3.2.3.2.4) is for the same\n      purpose.  If traversal of AccECN TCP Options were reliable, this\n      would have enabled a far wider range of future variation of the\n      whole AccECN protocol.  Nonetheless, it could be used to reliably\n      negotiate a wide range of variation in the semantics of the AccECN\n      Option.\n\n   Future non-AccECN variants:  Five codepoints out of the 8 possible in\n      the 3 TCP header flags used by AccECN are unused on the initial\n      SYN (in the order (AE,CWR,ECE)): (0,0,1), (0,1,0), (1,0,0),\n      (1,0,1), (1,1,0).  Section 3.1.3 ensures that the installed base\n      of AccECN Servers will all assume these are equivalent to AccECN\n      negotiation with (1,1,1) on the SYN.  These codepoints would not\n      allow fall-back to Classic ECN support for a Server that did not\n      understand them, but this approach ensures they are available in\n      future, perhaps for uses other than ECN alongside the AccECN\n      scheme.  All possible combinations of SYN/ACK could be used in\n      response except either (0,0,0) or reflection of the same values\n      sent on the SYN.\n\n      In order to extend AccECN or ECN in future, other ways could be\n      resorted to, although their traversal properties are likely to be\n      inferior.  They include a new TCP option; using the remaining\n      reserved flags in the main TCP header (preferably extending the\n      3-bit combinations used by AccECN to 4-bit combinations, rather \n      than burning one bit for just one state); a non-zero urgent\n      pointer in combination with the URG flag cleared; or some other\n      unexpected combination of fields yet to be invented.\n\n\n\n",
    "structured_content": {
      "1": {
        "title": "Introduction",
        "content": "   Explicit Congestion Notification (ECN) [RFC3168] is a mechanism where\n   network nodes can mark IP packets instead of dropping them to\n   indicate incipient congestion to the endpoints.  Receivers with an\n   ECN-capable transport protocol feed back this information to the\n   sender.  In RFC 3168, ECN was specified for TCP in such a way that\n   only one feedback signal could be transmitted per Round-Trip Time\n   (RTT).  This is sufficient for congestion control scheme like Reno\n   [RFC6582] and Cubic [RFC9438], as those schemes reduce their\n   congestion window by a fixed factor if congestion occurs within an\n   RTT independent of the number of received congestion markings.\n   Recently, proposed mechanisms like Congestion Exposure (ConEx\n   [RFC7713]), DCTCP [RFC8257] or L4S [RFC9330] need to know when more\n   than one marking is received in one RTT, which is information that\n   cannot be provided by the feedback scheme as specified in [RFC3168].\n   This document specifies an update to the ECN feedback scheme of RFC \n   3168 that provides more accurate information and could be used by\n   these and potentially other future TCP extensions, while still also\n   supporting the pre-existing TCP congestion controllers that use just\n   one feedback signal per round.  Congestion control is the term the\n   IETF uses to describe data rate management.  It is the algorithm that\n   a sender uses to optimize its sending rate so that it transmits data\n   as fast as the network can carry it, but no faster.  A fuller\n   treatment of the motivation for this specification is given in the\n   associated requirements document [RFC7560].\n\n   This document specifies a standards track scheme for ECN feedback in\n   the TCP header to provide more than one feedback signal per RTT.  It\n   will be called the more Accurate ECN feedback scheme, or AccECN for\n   short.  This document updates RFC 3168 with respect to negotiation\n   and use of the feedback scheme for TCP.  All aspects of RFC 3168   other than the TCP feedback scheme and its negotiation remain\n   unchanged by this specification.  In particular the definition of ECN\n   at the IP layer is unaffected.  Section 4 gives a more detailed\n   specification of exactly which aspects of RFC 3168 this document\n   updates. \n   This document uses the term Classic ECN feedback when it needs to\n   distinguish the TCP/ECN feedback scheme defined in [RFC3168] from the\n   AccECN TCP feedback scheme.  AccECN is intended to offer a complete\n   replacement for Classic TCP/ECN feedback, not a fork in the design of\n   TCP.  AccECN feedback complements TCP's loss feedback and it can\n   coexist alongside hosts using Classic TCP/ECN feedback.  So its\n   applicability is intended to include the public Internet as well as\n   private IP network such as data centres (and even any non-IP networks\n   over which TCP is used), whether or not any nodes on the path support\n   ECN, of whatever flavour.\n\n   AccECN feedback overloads the two existing ECN flags in the TCP\n   header and allocates the currently reserved flag (previously called\n   NS) in the TCP header, to be used as one three-bit counter field for\n   feeding back the number of packets marked as congestion experienced\n   (CE).  Given the new definitions of these three bits, both ends have\n   to support the new wire protocol before it can be used.  Therefore,\n   during the TCP handshake, the two ends use these three bits in the\n   TCP header to negotiate the most advanced feedback protocol that they\n   can both support, in a way that is backward compatible with\n   [RFC3168].\n\n   AccECN is solely a change to the TCP wire protocol; it covers the\n   negotiation and signaling of more Accurate ECN feedback from a TCP\n   Data Receiver to a Data Sender.  It is completely independent of how\n   TCP might respond to congestion feedback, which is out of scope, but\n   ultimately the motivation for Accurate ECN feedback.  Like Classic\n   ECN feedback, AccECN can be used by standard Reno or CUBIC congestion\n   control [RFC5681] [RFC9438] to respond to the existence of at least\n   one congestion notification within a round trip.  Or, unlike Reno or\n   CUBIC, AccECN can be used to respond to the extent of congestion\n   notification over a round trip, as for example DCTCP does in\n   controlled environments [RFC8257].  For congestion response, this\n   specification refers to the original ECN specificiation adopted in\n   2001 [RFC3168], as updated by the more relaxed rules introduced in\n   2018 to allow ECN experiments [RFC8311], namely: a TCP-based Low\n   Latency Low Loss Scalable (L4S) congestion control [RFC9330]; or\n   Alternative Backoff with ECN (ABE) [RFC8511]. Section 5.2 explains how AccECN is compatible with current commonly\n   used TCP options, and a number of current experimental modifications\n   to TCP, as well as SYN cookies.",
        "children": {
          "1.1": {
            "title": "Document Roadmap",
            "content": "   The following introductory section outlines the goals of AccECN\n   (Section 1.2).  Then, terminology is defined (Section 1.3) and a\n   recap of existing prerequisite technology is given (Section 1.4). \n\n\n\n   Section 2 gives an informative overview of the AccECN protocol.  Then Section 3 gives the normative protocol specification, and Section 3.3   collects together requirements for proxies, offload engines and other\n   middleboxes.  Section 4 clarifies which aspects of RFC 3168 are\n   updated by AccECN.  Section 5 assesses the interaction of AccECN with\n   commonly used variants of TCP, whether standardized or not.  Then Section 6 summarizes the features and properties of AccECN. Section 7 summarizes the protocol fields and numbers that IANA will\n   need to assign and Section 8 points to the aspects of the protocol\n   that will be of interest to the security community. Appendix A  gives pseudocode examples for the various algorithms that\n   AccECN uses and Appendix B  explains why AccECN uses flags in the main\n   TCP header and quantifies the space left for future use.",
            "children": {}
          },
          "1.2": {
            "title": "Goals",
            "content": "   [RFC7560] enumerates requirements that a candidate feedback scheme\n   will need to satisfy, under the headings: resilience, timeliness,\n   integrity, accuracy (including ordering and lack of bias),\n   complexity, overhead and compatibility (both backward and forward).\n   It recognizes that a perfect scheme that fully satisfies all the\n   requirements is unlikely and trade-offs between requirements are\n   likely.  Section 6 presents the properties of AccECN against these\n   requirements and discusses the trade-offs made.\n\n   The requirements document recognizes that a protocol as ubiquitous as\n   TCP needs to be able to serve as-yet-unspecified requirements.\n   Therefore an AccECN receiver acts as a generic (mechanistic)\n   reflector of congestion information with the aim that in future new\n   sender behaviours can be deployed unilaterally (see Section 2.5).",
            "children": {}
          },
          "1.3": {
            "title": "Terminology",
            "content": "   AccECN:  The more Accurate ECN feedback scheme will be called AccECN\n      for short.\n\n   Classic ECN:  The ECN protocol specified in [RFC3168].\n\n   Classic ECN feedback:  The feedback aspect of the ECN protocol\n      specified in [RFC3168], including generation, encoding,\n      transmission and decoding of feedback, but not the Data Sender's\n      subsequent response to that feedback.\n\n   ACK:  A TCP acknowledgement, with or without a data payload (ACK=1).\n\n   Pure ACK:  A TCP acknowledgement without a data payload. \n   Acceptable packet / segment:  A packet or segment that passes the\n      acceptability tests in [RFC9293] and [RFC5961], or that has passed\n      other tests with equivalent protection.\n\n   TCP Client:  The TCP stack that originates a connection (the\n      initiator).\n\n   TCP Server:  The TCP stack that responds to a connection request (the\n      listener).\n\n   Three-way handshake:  The procedure used to establish a TCP\n      connection as described in the TCP protocol specification\n      [RFC9293].\n\n   Data Receiver:  The endpoint of a TCP half-connection that receives\n      data and sends AccECN feedback.\n\n   Data Sender:  The endpoint of a TCP half-connection that sends data\n      and receives AccECN feedback.\n\n   In a mild abuse of terminology, this document sometimes refers to\n   'TCP packets' instead of 'TCP segments'.\n\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described in BCP \n   14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals, as shown here.",
            "children": {}
          },
          "1.4": {
            "title": "Recap of Existing ECN feedback in IP/TCP",
            "content": "   Explicit Congestion Notification (ECN) [RFC3168] can be split into\n   two parts conceptionally.  In the forward direction, alongside the\n   data stream, it uses a two-bit field in the IP header.  This is\n   referred to as IP-ECN later on.  This signal carried in the IP (Layer\n   3) header is exposed to network devices and may be modified when such\n   a device starts to experience congestion (see Table 1).  The second\n   part is the feedback mechanism, by which the original data sender is\n   notified of the current congestion state of the intermediate path.\n   That returned signal is carried in a protocol specific manner, and is\n   not to be modified by intermediate network devices.  While ECN is in\n   active use for protocols such as QUIC [RFC9000], SCTP [RFC9260], RTP\n   [RFC6679] and Remote Direct Memory Access over Converged Ethernet\n   [RoCEv2], this document only concerns itself with the specific\n   implementation for the TCP protocol. \n   Once ECN has been negotiated for a transport layer connection, the\n   Data Sender for either half-connection can set two possible\n   codepoints (ECT(0) or ECT(1)) in the IP header of a data packet to\n   indicate an ECN-capable transport (ECT).  If the ECN codepoint is\n   0b00, the packet is considered to have been sent by a Not ECN-capable\n   Transport (Not-ECT).  When a network node experiences congestion, it\n   will occasionally either drop or mark a packet, with the choice\n   depending on the packet's ECN codepoint.  If the codepoint is Not-\n   ECT, only drop is appropriate.  If the codepoint is ECT(0) or ECT(1),\n   the node can mark the packet by setting the ECN codepoint to 0b11,\n   which is termed 'Congestion Experienced' (CE), or loosely a\n   'congestion mark'.  Table 1 summarises these codepoints.\n\n     +==================+================+===========================+\n     | IP-ECN codepoint | Codepoint name | Description               |\n     +==================+================+===========================+\n     | 0b00             | Not-ECT        | Not ECN-Capable Transport |\n     +------------------+----------------+---------------------------+\n     | 0b01             | ECT(1)         | ECN-Capable Transport (1) |\n     +------------------+----------------+---------------------------+\n     | 0b10             | ECT(0)         | ECN-Capable Transport (0) |\n     +------------------+----------------+---------------------------+\n     | 0b11             | CE             | Congestion Experienced    |\n     +------------------+----------------+---------------------------+\n\n                  Table 1: The ECN Field in the IP Header\n\n   In the TCP header the first two bits in byte 14 (the TCP header flags\n   at bit offsets 8 and 9 labelled Congestion Window Reduced (CWR) and\n   Explicit Congestion notification Echo (ECE) in Figure 1) are defined\n   as flags for the use of Classic ECN [RFC3168].  A TCP Client\n   indicates that it supports Classic ECN feedback by setting (CWR,ECE)\n   = (1,1) in the SYN, and an ECN-enabled TCP Server confirms Classic\n   ECN support by setting (CWR,ECE) = (0,1) in the SYN/ACK.  On\n   reception of a CE-marked packet at the IP layer, the Data Receiver\n   for that half-connection starts to set the Echo Congestion\n   Experienced (ECE) flag continuously in the TCP header of ACKs, which\n   gives the signal resilience to loss or reordering of ACKs.  The Data\n   Sender for the same half-connection confirms that it has received at\n   least one ECE signal by responding with the congestion window reduced\n   (CWR) flag, which allows the Data Receiver to stop repeating the ECN-\n   Echo flag.  This always leads to a full RTT of ACKs with ECE set.\n   Thus Classic ECN cannot feed back any additional CE markings arriving\n   within this RTT.\n\n   The last bit in byte 13 of the TCP header (the TCP header flag at bit\n   offset 7 in Figure 1) was defined as the Nonce Sum (NS) for the ECN\n   Nonce [RFC3540].  In the absence of widespread deployment RFC 3540\n\n\n\n\n   has been reclassified as historic [RFC8311] and the respective flag\n   has been marked as \"reserved\", making this TCP flag available for use\n   by AccECN instead.\n\n\n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           | N | C | E | U | A | P | R | S | F |\n     | Header Length | Reserved  | S | W | C | R | C | S | S | Y | I |\n     |               |           |   | R | E | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 1: TCP header flags as defined before the Nonce Sum flag\n                            reverted to Reserved",
            "children": {}
          }
        }
      },
      "2": {
        "title": "AccECN Protocol Overview and Rationale",
        "content": "   This section provides an informative overview of the AccECN protocol\n   that will be normatively specified in Section 3   Like the general TCP approach, the Data Receiver of each TCP half-\n   connection sends AccECN feedback to the Data Sender on TCP\n   acknowledgements, reusing data packets of the other half-connection\n   whenever possible.\n\n   The AccECN protocol has had to be designed in two parts:\n\n   *  an essential feedback part that re-uses the TCP-ECN header bits\n      for the Data Receiver to feed back the number of packets arriving\n      with CE in the IP-ECN field.  This provides more accuracy than\n      Classic ECN feedback, but limited resilience against ACK loss;\n\n   *  a supplementary feedback part using one of two new alternative\n      AccECN TCP options that provide additional feedback on the number\n      of payload bytes that arrive marked with each of the three ECN\n      codepoints in the IP-ECN field (not just CE marks).  See the BCP\n      on Byte and Packet Congestion Notification [RFC7141] for the\n      rationale determining that conveying congested payload bytes\n      should be preferred over just providing feedback about congested\n      packets.  This also provides greater resilience against ACK loss\n      than the essential feedback, but it is currently more likely to\n      suffer from middlebox interference.\n\n   The two part design was necessary, given limitations on the space\n   available for TCP options and given the possibility that certain\n   incorrectly designed middleboxes might prevent TCP using any new\n   options. \n   The essential feedback part overloads the previous definition of the\n   three flags in the TCP header that had been assigned for use by\n   Classic ECN.  This design choice deliberately allows AccECN peers to\n   replace the Classic ECN feedback protocol, rather than leaving\n   Classic ECN feedback intact and adding more accurate feedback\n   separately because:\n\n   *  this efficiently reuses scarce TCP header space, given TCP option\n      space is approaching saturation;\n\n   *  a single upgrade path for the TCP protocol is preferable to a fork\n      in the design which modifies the TCP header to convey all ECN\n      feedback;\n\n   *  otherwise Classic and Accurate ECN feedback could give conflicting\n      feedback about the same segment, which could open up new security\n      concerns and make implementations unnecessarily complex;\n\n   *  middleboxes are more likely to faithfully forward the TCP ECN\n      flags than newly defined areas of the TCP header.\n\n   AccECN is designed to work even if the supplementary feedback part is\n   removed or zeroed out, as long as the essential feedback part gets\n   through.",
        "children": {
          "2.1": {
            "title": "Capability Negotiation",
            "content": "   AccECN is a change to the wire protocol of the main TCP header,\n   therefore it can only be used if both endpoints have been upgraded to\n   understand it.  The TCP Client signals support for AccECN on the\n   initial SYN of a connection and the TCP Server signals whether it\n   supports AccECN on the SYN/ACK.  The TCP flags on the SYN that the\n   TCP Client uses to signal AccECN support have been carefully chosen\n   so that a TCP Server will interpret them as a request to support the\n   most recent variant of ECN feedback that it supports.  Then the TCP\n   Client falls back to the same variant of ECN feedback.\n\n   An AccECN TCP Client does not send an AccECN Option on the SYN as SYN\n   option space is limited.  The TCP Server sends an AccECN Option on\n   the SYN/ACK and the TCP Client sends one on the first ACK to test\n   whether the network path forwards these options correctly. \n\n\n\n",
            "children": {}
          },
          "2.2": {
            "title": "Feedback Mechanism",
            "content": "   A Data Receiver maintains four counters initialized at the start of\n   the half-connection.  Three count the number of arriving payload\n   bytes marked CE, ECT(1) and ECT(0) in the IP-ECN field.  These byte\n   counters reflect only the TCP payload length, excluding the TCP\n   header and TCP options.  The fourth counter counts the number of\n   packets arriving marked with a CE codepoint (including control\n   packets without payload if they are CE-marked).\n\n   The Data Sender maintains four equivalent counters for the half\n   connection, and the AccECN protocol is designed to ensure they will\n   match the values in the Data Receiver's counters, albeit after a\n   little delay.\n\n   Each ACK carries the three least significant bits (LSBs) of the\n   packet-based CE counter using the ECN bits in the TCP header, now\n   renamed the Accurate ECN (ACE) field (see Figure 3 later).  The 24\n   LSBs of some or all of the byte counters can be optionally carried in\n   an AccECN Option.  For efficient use of limited option space, two\n   alternative forms of AccECN Option are specified with the fields in\n   the opposite order to each other.",
            "children": {}
          },
          "2.3": {
            "title": "Delayed ACKs and Resilience Against ACK Loss",
            "content": "   With both the ACE and the AccECN Option mechanisms, the Data Receiver\n   continually repeats the current LSBs of each of its respective\n   counters.  There is no need to acknowledge these continually repeated\n   counters, so the congestion window reduced (CWR) mechanism of\n   [RFC3168] is no longer used.  Even if some ACKs are lost, the Data\n   Sender ought to be able to infer how much to increment its own\n   counters, even if the protocol field has wrapped.\n\n   The 3-bit ACE field can wrap fairly frequently.  Therefore, even if\n   it appears to have incremented by one (say), the field might have\n   actually cycled completely then incremented by one.  The Data\n   Receiver is not allowed to delay sending an ACK to such an extent\n   that the ACE field would cycle.  However ACKs received at the Data\n   Sender could still cycle because a whole sequence of ACKs carrying\n   intervening values of the field might all be lost or delayed in\n   transit.\n\n   The fields in an AccECN Option are larger, but they will increment in\n   larger steps because they count bytes not packets.  Nonetheless,\n   their size has been chosen such that a whole cycle of the field would\n   never occur between ACKs unless there had been an infeasibly long\n   sequence of ACK losses.  Therefore, provided that an AccECN Option is\n   available, it can be treated as a dependable feedback channel. \n   If an AccECN Option is not available, e.g., it is being stripped by a\n   middlebox, the AccECN protocol will only feed back information on CE\n   markings (using the ACE field).  Although not ideal, this will be\n   sufficient, because it is envisaged that neither ECT(0) nor ECT(1)\n   will ever indicate more severe congestion than CE, even though future\n   uses for ECT(0) or ECT(1) are still unclear [RFC8311].  Because the\n   3-bit ACE field is so small, when it is the only field available, the\n   Data Sender has to interpret it assuming the most likely wrap, but\n   with a degree of conservatism.\n\n   Certain specified events trigger the Data Receiver to include an\n   AccECN Option on an ACK.  The rules are designed to ensure that the\n   order in which different markings arrive at the receiver is\n   communicated to the sender (as long as options are reaching the\n   sender and as long as there is no ACK loss).  Implementations are\n   encouraged to send an AccECN Option more frequently, but this is left\n   up to the implementer.",
            "children": {}
          },
          "2.4": {
            "title": "Feedback Metrics",
            "content": "   The CE packet counter in the ACE field and the CE byte counter in\n   AccECN Options both provide feedback on received CE-marks.  The CE\n   packet counter includes control packets that do not have payload\n   data, while the CE byte counter solely includes marked payload bytes.\n   If both are present, the byte counter in an AccECN Option will\n   provide the more accurate information needed for modern congestion\n   control and policing schemes, such as L4S, DCTCP or ConEx.  If AccECN\n   Options are stripped, a simple algorithm to estimate the number of\n   marked bytes from the ACE field is given in Appendix A.3.\n\n   The AccECN design has been generalized so that it ought to be able to\n   support possible future uses of the experimental ECT(1) codepoint\n   other than the L4S experiment [RFC9330], such as a lower severity or\n   a more instant congestion signal than CE.\n\n   Feedback in bytes is provided to protect against the receiver or a\n   middlebox using attacks similar to 'ACK-Division' to artificially\n   inflate the congestion window, which is why [RFC5681] now recommends\n   that TCP counts acknowledged bytes not packets.",
            "children": {}
          },
          "2.5": {
            "title": "Generic (Mechanistic) Reflector",
            "content": "   The ACE field provides feedback about CE markings in the IP-ECN field\n   of both data and control packets.  According to [RFC3168] the Data\n   Sender is meant to set the IP-ECN field of control packets to Not-\n   ECT.  However, mechanisms in certain private networks (e.g., data\n   centres) set control packets to be ECN capable because they are\n   precisely the packets that performance depends on most. \n   For this reason, AccECN is designed to be a generic reflector of\n   whatever ECN markings it sees, whether or not they are compliant with\n   a current standard.  Then as standards evolve, Data Senders can\n   upgrade unilaterally without any need for receivers to upgrade too.\n\n   It is also useful to be able to rely on generic reflection behaviour\n   when senders need to test for unexpected interference with markings\n   (for instance Section 3.2.2.3, Section 3.2.2.4 and Section 3.2.3.2 of\n   the present document and paragraph 2 of Section 20.2 of [RFC3168]).\n\n   The initial SYN and SYN/ACK are the most critical control packets, so\n   AccECN feeds back their IP-ECN fields.  Although RFC 3168 prohibits\n   ECN-capable SYNs and SYN/ACKs, providing feedback of ECN marking on\n   the SYN and SYN/ACK supports future scenarios in which SYNs might be\n   ECN-enabled (without prejudging whether they ought to be).  For\n   instance, [RFC8311] updates this aspect of RFC 3168 to allow\n   experimentation with ECN-capable TCP control packets.\n\n   Even if the TCP Client (or Server) has set the SYN (or SYN/ACK) to\n   not-ECT in compliance with RFC 3168, feedback on the state of the IP-\n   ECN field when it arrives at the receiver could still be useful,\n   because middleboxes have been known to overwrite the IP-ECN field as\n   if it is still part of the old Type of Service (ToS) field\n   [Mandalari18].  For example, if a TCP Client has set the SYN to Not-\n   ECT, but receives feedback that the IP-ECN field on the SYN arrived\n   with a different codepoint, it can detect such middlebox\n   interference.  Previously, neither end knew what IP-ECN field the\n   other had sent.  So, if a TCP Server received ECT or CE on a SYN, it\n   could not know whether it was invalid because only the TCP Client\n   knew whether it originally marked the SYN as Not-ECT (or ECT).\n   Therefore, prior to AccECN, the Server's only safe course of action\n   in this example was to disable ECN for the connection.  Instead, the\n   AccECN protocol allows the Server and Client to feed back the ECN\n   field received on the SYN and SYN/ACK to their peer, which then has\n   all the information to decide whether the connection has to fall-back\n   from supporting ECN (or not).",
            "children": {}
          }
        }
      },
      "3": {
        "title": "AccECN Protocol Specification",
        "content": "\n\n",
        "children": {
          "3.1": {
            "title": "Negotiating to use AccECN",
            "content": "\n\n\n",
            "children": {
              "3.1.1": {
                "title": "Negotiation during the TCP three-way handshake",
                "content": "   Given the ECN Nonce [RFC3540] has been reclassified as historic\n   [RFC8311], the TCP flag that was previously called NS (Nonce Sum) is\n   renamed as the AE (Accurate ECN) flag (the TCP header flag at bit\n   offset 7 in Figure 2).  See the IANA Considerations in Section 7. \n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           | A | C | E | U | A | P | R | S | F |\n     | Header Length | Reserved  | E | W | C | R | C | S | S | Y | I |\n     |               |           |   | R | E | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 2: The new definition of the TCP header flags during the\n                          TCP three-way handshake\n\n   During the TCP three-way handshake at the start of a connection, to\n   request more Accurate ECN feedback the TCP Client (host A) MUST set\n   the TCP flags (AE,CWR,ECE) = (1,1,1) in the initial SYN segment.\n\n   If a TCP Server (host B) that is AccECN-enabled receives a SYN with\n   the above three flags set, it MUST set both its half connections into\n   AccECN mode.  Then it MUST set the AE, CWR and ECE TCP flags on the\n   SYN/ACK to the combination in the top block of Table 2 that feeds\n   back the IP-ECN field that arrived on the SYN.  This applies whether\n   or not the Server itself supports setting the IP-ECN field on a SYN\n   or SYN/ACK (see Section 2.5 for rationale).\n\n   When the TCP Server returns any of the 4 combinations in the top\n   block of Table 2, it confirms that it supports AccECN.  The TCP\n   Server MUST NOT set one of these 4 combination of flags on the SYN/\n   ACK unless the preceding SYN requested support for AccECN as above.\n\n   Once a TCP Client (A) has sent the above SYN to declare that it\n   supports AccECN, and once it has received the above SYN/ACK segment\n   that confirms that the TCP Server supports AccECN, the TCP Client\n   MUST set both its half connections into AccECN mode.  The TCP Client\n   MUST NOT enter AccECN mode (or any feedback mode) before it has\n   received the first SYN/ACK.\n\n   Once in AccECN mode, a TCP Client or Server has the rights and\n   obligations to participate in the ECN protocol defined in Section 3.1.5.\n\n   The procedures to follow for retransmission of SYNs or SYN/ACKs are\n   given in Section 3.1.4.\n\n   It is RECOMMENDED that the AccECN protocol is implemented alongside\n   Selective Acknowledgement (SACK) [RFC2018].  If SACK is implemented\n   with AccECN, Duplicate Selective Acknowledgement (D-SACK) [RFC2883]\n   MUST also be implemented. \n\n\n\n",
                "children": {}
              },
              "3.1.2": {
                "title": "Backward Compatibility",
                "content": "   The three flags set to 1 to indicate AccECN support on the SYN have\n   been carefully chosen to enable natural fall-back to prior stages in\n   the evolution of ECN.  Table 2 tabulates all the negotiation\n   possibilities for ECN-related capabilities that involve at least one\n   AccECN-capable host.  The entries in the first two columns have been\n   abbreviated, as follows:\n\n   AccECN:  Supports more Accurate ECN Feedback (the present\n       specification)\n\n   Nonce:  Supports ECN Nonce feedback [RFC3540]\n\n   ECN:  Supports 'Classic' ECN feedback [RFC3168]\n\n   No ECN:  Not ECN-capable.  Implicit congestion notification using\n       packet drop.\n\n   +========+========+============+============+======================+\n   | Host A | Host B |    SYN     |  SYN/ACK   | Feedback Mode        |\n   |        |        |    A->B    |    B->A    | of Host A            |\n   |        |        | AE CWR ECE | AE CWR ECE |                      |\n   +========+========+============+============+======================+\n   | AccECN | AccECN | 1   1   1  | 0   1   0  | AccECN (Not-ECT SYN) |\n   | AccECN | AccECN | 1   1   1  | 0   1   1  | AccECN (ECT1 on SYN) |\n   | AccECN | AccECN | 1   1   1  | 1   0   0  | AccECN (ECT0 on SYN) |\n   | AccECN | AccECN | 1   1   1  | 1   1   0  | AccECN (CE on SYN)   |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | AccECN | Nonce  | 1   1   1  | 1   0   1  | (Reserved)           |\n   | AccECN | ECN    | 1   1   1  | 0   0   1  | Classic ECN          |\n   | AccECN | No ECN | 1   1   1  | 0   0   0  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | Nonce  | AccECN | 0   1   1  | 0   0   1  | Classic ECN          |\n   | ECN    | AccECN | 0   1   1  | 0   0   1  | Classic ECN          |\n   | No ECN | AccECN | 0   0   0  | 0   0   0  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n   +--------+--------+------------+------------+----------------------+\n   | AccECN | Broken | 1   1   1  | 1   1   1  | Not ECN              |\n   +--------+--------+------------+------------+----------------------+\n\n        Table 2: ECN capability negotiation between Client (A) and\n                                Server (B)\n\n   Table 2 is divided into blocks each separated by an empty row. \n   1.  The top block shows the case already described in Section 3.1       where both endpoints support AccECN and how the TCP Server (B)\n       indicates congestion feedback.\n\n   2.  The second block shows the cases where the TCP Client (A)\n       supports AccECN but the TCP Server (B) supports some earlier\n       variant of TCP feedback, indicated in its SYN/ACK.  Therefore, as\n       soon as an AccECN-capable TCP Client (A) receives the SYN/ACK\n       shown it MUST set both its half connections into the feedback\n       mode shown in the rightmost column.  If the TCP Client has set\n       itself into Classic ECN feedback mode it MUST then comply with\n       [RFC3168].\n\n       An AccECN implementation has no need to recognize or support the\n       Server response labelled 'Nonce' or ECN Nonce feedback more\n       generally [RFC3540], which has been reclassified as historic\n       [RFC8311].  AccECN is compatible with alternative ECN feedback\n       integrity approaches to the nonce (see Section 5.3).  The SYN/ACK\n       labelled 'Nonce' with (AE,CWR,ECE) = (1,0,1) is reserved for\n       future use.  A TCP Client (A) that receives such a SYN/ACK\n       follows the procedure for forward compatibility given in Section 3.1.3.\n\n   3.  The third block shows the cases where the TCP Server (B) supports\n       AccECN but the TCP Client (A) supports some earlier variant of\n       TCP feedback, indicated in its SYN.\n\n       When an AccECN-enabled TCP Server (B) receives a SYN with\n       (AE,CWR,ECE) = (0,1,1) it MUST do one of the following:\n\n       *  set both its half connections into the Classic ECN feedback\n          mode and return a SYN/ACK with (AE,CWR,ECE) = (0,0,1) as\n          shown.  Then it MUST comply with [RFC3168].\n\n       *  set both its half-connections into Not ECN mode and return a\n          SYN/ACK with (AE,CWR,ECE) = (0,0,0), then continue with ECN\n          disabled.  This latter case is unlikely to be desirable, but\n          it is allowed as a possibility, e.g., for minimal TCP\n          implementations.\n\n       When an AccECN-enabled TCP Server (B) receives a SYN with\n       (AE,CWR,ECE) = (0,0,0) it MUST set both its half connections into\n       the Not ECN feedback mode, return a SYN/ACK with (AE,CWR,ECE) =\n       (0,0,0) as shown and continue with ECN disabled.\n\n   4.  The fourth block displays a combination labelled `Broken'.  Some\n       older TCP Server implementations incorrectly set the TCP-ECN\n       flags in the SYN/ACK by reflecting those in the SYN.  Such broken \n       TCP Servers (B) cannot support ECN, so as soon as an AccECN-\n       capable TCP Client (A) receives such a broken SYN/ACK it MUST\n       fall back to Not ECN mode for both its half connections and\n       continue with ECN disabled.\n\n   The following additional rules do not fit the structure of the table,\n   but they complement it:\n\n   Simultaneous Open:  An originating AccECN Host (A), having sent a SYN\n      with (AE,CWR,ECE) = (1,1,1), might receive another SYN from host\n      B.  Host A MUST then enter the same feedback mode as it would have\n      entered had it been a responding host and received the same SYN.\n      Then host A MUST send the same SYN/ACK as it would have sent had\n      it been a responding host.\n\n   In-window SYN during TIME-WAIT:  Many TCP implementations create a\n      new TCP connection if they receive an in-window SYN packet during\n      TIME-WAIT state.  When a TCP host enters TIME-WAIT or CLOSED\n      state, it ought to ignore any previous state about the negotiation\n      of AccECN for that connection and renegotiate the feedback mode\n      according to Table 2.",
                "children": {}
              },
              "3.1.3": {
                "title": "Forward Compatibility",
                "content": "   If a TCP Server that implements AccECN receives a SYN with the three\n   TCP header flags (AE,CWR,ECE) set to any combination other than\n   (0,0,0), (0,1,1) or (1,1,1) and it does not have logic specific to\n   such a combination, the Server MUST negotiate the use of AccECN as if\n   the three flags had been set to (1,1,1).  However, an AccECN Client\n   implementation MUST NOT send a SYN with any combination other than\n   the three listed.\n\n   If a TCP Client has sent a SYN requesting AccECN feedback with\n   (AE,CWR,ECE) = (1,1,1) then receives a SYN/ACK with the currently\n   reserved combination (AE,CWR,ECE) = (1,0,1) but it does not have\n   logic specific to such a combination, the Client MUST enable AccECN\n   mode as if the SYN/ACK confirmed that the Server supported AccECN and\n   as if it fed back that the IP-ECN field on the SYN had arrived\n   unchanged.  However, an AccECN Server implementation MUST NOT send a\n   SYN/ACK with this combination (AE,CWR,ECE) = (1,0,1).\n\n      |  For the avoidance of doubt, the behaviour described in the\n      |  present specification applies whether or not the three\n      |  remaining reserved TCP header flags are zero. \n   All these requirements ensure that future uses of all the Reserved\n   combinations on a SYN or SYN/ACK can rely on consistent behaviour\n   from the installed base of AccECN implementations.  See Appendix B.3   for related discussion.",
                "children": {}
              },
              "3.1.4": {
                "title": "Multiple SYNs or SYN/ACKs",
                "content": "\n\n\n",
                "children": {
                  "3.1.4.1": {
                    "title": "Retransmitted SYNs",
                    "content": "   If the sender of an AccECN SYN (the TCP Client) times out before\n   receiving the SYN/ACK, it SHOULD attempt to negotiate the use of\n   AccECN at least one more time by continuing to set all three TCP ECN\n   flags (AE,CWR,ECE) = (1,1,1) on the first retransmitted SYN (using\n   the usual retransmission time-outs).  If this first retransmission\n   also fails to be acknowledged, in deployment scenarios where AccECN\n   path traversal might be problematic, the TCP Client SHOULD send\n   subsequent retransmissions of the SYN with the three TCP-ECN flags\n   cleared (AE,CWR,ECE) = (0,0,0).  Such a retransmitted SYN MUST use\n   the same initial sequence number (ISN) as the original SYN.\n\n   Retrying once before fall-back adds delay in the case where a\n   middlebox drops an AccECN (or ECN) SYN deliberately.  However, recent\n   measurements [Mandalari18] imply that a drop is less likely to be due\n   to middlebox interference than other intermittent causes of loss,\n   e.g., congestion, wireless transmission loss, etc.\n\n   Implementers MAY use other fall-back strategies if they are found to\n   be more effective (e.g., attempting to negotiate AccECN on the SYN\n   only once or more than twice (most appropriate during high levels of\n   congestion).\n\n   Further it might make sense to also remove any other new or\n   experimental fields or options on the SYN in case a middlebox might\n   be blocking them, although the required behaviour will depend on the\n   specification of the other option(s) and any attempt to co-ordinate\n   fall-back between different modules of the stack.  For instance, even\n   if taking part in an [RFC8311] experiment that allows ECT on a SYN,\n   it would be advisable to try it without.\n\n   Whichever fall-back strategy is used, the TCP initiator SHOULD cache\n   failed connection attempts.  If it does, it SHOULD NOT give up\n   attempting to negotiate AccECN on the SYN of subsequent connection\n   attempts until it is clear that the blockage is persistently and\n   specifically due to AccECN.  The cache needs to be arranged to expire\n   so that the initiator will infrequently attempt to check whether the\n   problem has been resolved. \n   All fall-back strategies will need to follow all the normative rules\n   in Section 3.1.5, which concern behaviour when SYNs or SYN/ACKs\n   negotiating different types of feedback have been sent within the\n   same connection, including the possibility that they arrive out of\n   order.  As examples, the following non-normative bullets call out\n   those rules from Section 3.1.5 that apply to the above fall-back\n   strategies:\n\n   *  Once the TCP Client has sent SYNs with (AE,CWR,ECE) = (1,1,1) and\n      with (AE,CWR,ECE) = (0,0,0), it might eventually receive a SYN/ACK\n      from the Server in response to one, the other, or both and\n      possibly reordered;\n\n   *  Such a TCP Client enters the feedback mode appropriate to the\n      first SYN/ACK it receives according to Table 2, and it does not\n      switch to a different mode, whatever other SYN/ACKs it might\n      receive or send;\n\n   *  If a TCP Client has entered AccECN mode but then subsequently\n      sends a SYN or receives a SYN/ACK with (AE,CWR,ECE) = (0,0,0), it\n      is still allowed to set ECT on packets for the rest of the\n      connection.  Note that this rule is different to that of a Server\n      in an equivalent position (Section 3.1.5 explains).\n\n   *  Having entered AccECN mode, in general a TCP Client commits to\n      respond to any incoming congestion feedback, whether or not it\n      sets ECT on outgoing packets (for rationale and some exceptions\n      see Section 3.2.2.3, Section 3.2.2.4);\n\n   *  Having entered AccECN mode, a TCP Client commits to using AccECN\n      to feed back the IP-ECN field in incoming packets for the rest of\n      the connection, as specified in Section 3.2, even if it is not\n      itself setting ECT on outgoing packets.",
                    "children": {}
                  },
                  "3.1.4.2": {
                    "title": "Retransmitted SYN/ACKs",
                    "content": "   A TCP Server might send multiple SYN/ACKs indicating different\n   feedback modes.  For instance, when falling back to sending a SYN/ACK\n   with (AE,CWR,ECE) = (0,0,0) after previous AccECN SYN/ACKs have timed\n   out (Section 3.2.3.2.2); or to acknowledge different retransmissions\n   of the SYN (Section 3.1.4.1).\n\n   All fall-back strategies will need to follow all the normative rules\n   in Section 3.1.5, which concern behaviour when SYNs or SYN/ACKs\n   negotiating different types of feedback are sent within the same\n   connection, including the possibility that they arrive out of order.\n   As examples, the following non-normative bullets call out those rules\n   from Section 3.1.5 that apply to the above fall-back strategies:\n   *  An AccECN-capable TCP Server enters the feedback mode appropriate\n      to the first SYN it receives using Table 2, and it does not switch\n      to a different mode, whatever other SYNs it might receive and\n      whatever SYN/ACKs it might send;\n\n   *  if a TCP Server in AccECN mode receives a SYN with (AE,CWR,ECE) =\n      (0,0,0), it preferably acknowledges it first using an AccECN SYN/\n      ACK, but it can retry using a SYN/ACK with (AE,CWR,ECE) = (0,0,0);\n\n   *  If a TCP Server in AccECN mode sends multiple AccECN SYN/ACKs, it\n      uses the TCP-ECN flags in each SYN/ACK to feed back the IP-ECN\n      field on the latest SYN to have arrived;\n\n   *  If a TCP Server enters AccECN mode then subsequently sends a SYN/\n      ACK or receives a SYN with (AE,CWR,ECE) = (0,0,0), it is\n      prohibited from setting ECT on any packet for the rest of the\n      connection;\n\n   *  Having entered AccECN mode, in general a TCP Server commits to\n      respond to any incoming congestion feedback, whether or not it\n      sets ECT on outgoing packets (for rationale and some exceptions\n      see Section 3.2.2.3, Section 3.2.2.4);\n\n   *  Having entered AccECN mode, a TCP Server commits to using AccECN\n      to feed back the IP-ECN field in incoming packets for the rest of\n      the connection, as specified in Section 3.2, even if it is not\n      itself setting ECT on outgoing packets.",
                    "children": {}
                  }
                }
              },
              "3.1.5": {
                "title": "Implications of AccECN Mode",
                "content": "\n\n   Section 3.1.1 describes the only ways that a host can enter AccECN\n   mode, whether as a Client or as a Server.\n\n   An implementation that supports AccECN has the rights and obligations\n   concerning the use of ECN defined below, which update those in Section 6.1.1 of [RFC3168].  This section uses the following\n   definitions:\n\n   'During the handshake':  The connection states prior to\n      synchronization;\n\n   'Valid SYN':  A SYN that has the same port numbers and the same ISN\n      as the SYN that first caused the Server to open the connection.\n      An 'Acceptable' packet is defined in Section 1.3.\n\n   Handling SYNs or SYN/ACKs of multiple types (e.g., fall-back):\n\n   *  Any implementation that supports AccECN:\n      -  MUST NOT switch into a different feedback mode to the one it\n         first entered according to Table 2, no matter whether it\n         subsequently receives valid SYNs or Acceptable SYN/ACKs of\n         different types.\n\n      -  SHOULD ignore the TCP-ECN flags in SYNs or SYN/ACKs that are\n         received after the implementation reaches the Established\n         state, in line with the general TCP approach [RFC9293];\n\n         Reason: Reaching established state implies that at least one\n         SYN and one SYN/ACK have successfully been delivered.  And all\n         the rules for handshake fall-back are designed to work based on\n         those packets that successfully traverse the path, whatever\n         other handshake packets are lost or delayed.\n\n      -  MUST NOT send a 'Classic' ECN-setup SYN [RFC3168] with\n         (AE,CWR,ECE) = (0,1,1) and a SYN with (AE,CWR,ECE) = (1,1,1)\n         requesting AccECN feedback within the same connection;\n\n      -  MUST NOT send a 'Classic' ECN-setup SYN/ACK [RFC3168] with\n         (AE,CWR,ECE) = (0,0,1) and a SYN/ACK agreeing to use AccECN\n         feedback within the same connection;\n\n      -  MUST reset the connection with a RST packet, if it receives a\n         'Classic' ECN-setup SYN with (AE,CWR,ECE) = (0,1,1) and a SYN\n         requesting AccECN feedback during the same handshake;\n\n      -  MUST reset the connection with a RST packet, if it receives\n         'Classic' ECN-setup SYN/ACK with (AE,CWR,ECE) = (0,0,1) and a\n         SYN/ACK agreeing to use AccECN feedback during the same\n         handshake;\n\n      The last four rules are necessary because, if one peer were to\n      negotiate the feedback mode in two different types of handshake,\n      it would not be possible for the other peer to know for certain\n      which handshake packet(s) the other end had eventually received or\n      in which order it received them.  So, in the absence of these\n      rules, the two peers could end up using different ECN feedback\n      modes without knowing it.\n\n   *  A host in AccECN mode that is feeding back the IP-ECN field on a\n      SYN or SYN/ACK:\n\n      -  MUST feed back the IP-ECN field on the latest valid SYN or\n         acceptable SYN/ACK to arrive.\n\n   *  A TCP Server already in AccECN mode:\n      -  SHOULD acknowledge a valid SYN arriving with (AE,CWR,ECE) =\n         (0,0,0) by emitting an AccECN SYN/ACK (with the appropriate\n         combination of TCP-ECN flags to feed back the IP-ECN field of\n         this latest SYN);\n\n      -  MAY acknowledge a valid SYN arriving with (AE,CWR,ECE) =\n         (0,0,0) by sending a SYN/ACK with (AE,CWR,ECE) = (0,0,0);\n\n      Rationale: When a SYN arrives with (AE,CWR,ECE) = (0,0,0) at a TCP\n      Server that is already in AccECN mode, it implies that the TCP\n      Client had probably not received the previous AccECN SYN/ACK\n      emitted by the TCP Server.  Therefore, the first bullet recommends\n      attempting at least one more AccECN SYN/ACK.  Nonetheless, the\n      second bullet recognizes that the Server might eventually need to\n      fall back to a non-ECN SYN/ACK.  In either case, the TCP Server\n      remains in AccECN feedback mode (according to the earlier\n      requirement not to switch modes).\n\n   *  An AccECN-capable TCP Server already in Not ECN mode:\n\n      -  SHOULD respond to any subsequent valid SYN using a SYN/ACK with\n         (AE,CWR,ECE) = (0,0,0), even if the SYN is offering to\n         negotiate Classic ECN or AccECN feedback mode;\n\n         Rationale: There would be no point in the Server offering any\n         type of ECN feedback, because the Client will not be using ECN.\n         However, there is no interoperability reason to make this rule\n         mandatory.\n\n   If for any reason a host is not willing to provide ECN feedback on a\n   particular TCP connection, it SHOULD clear the AE, CWR and ECE flags\n   in all SYN and/or SYN/ACK packets that it sends.\n\n   Sending ECT:\n\n   *  Any implementation that supports AccECN:\n\n      -  MUST NOT set ECT if it is in Not ECN feedback mode.\n\n      A Data Sender in AccECN mode:\n\n      -  SHOULD set an ECT codepoint in the IP header of packets to\n         indicate to the network that the transport is capable and\n         willing to participate in ECN for this packet;\n\n      -  MAY not set ECT on any packet (for instance if it has reason to\n         believe such a packet would be blocked);\n      A TCP Server in AccECN mode:\n\n      -  MUST NOT set ECT on any packet for the rest of the connection,\n         if it has received or sent at least one valid SYN or Acceptable\n         SYN/ACK with (AE,CWR,ECE) = (0,0,0) during the handshake.\n\n         This rule solely applies to a Server because, when a Server\n         enters AccECN mode it doesn't know for sure whether the Client\n         will end up in AccECN mode.  But when a Client enters AccECN\n         mode, it can be certain that the Server is already in AccECN\n         feedback mode.\n\n   Congestion response:\n\n   *  A host in AccECN mode:\n\n      -  is obliged to respond appropriately to AccECN feedback that\n         indicates there were ECN marks on packets it had previously\n         sent, where 'appropriately' is defined in Section 6.1 of\n         [RFC3168] and updated by Sections 2.1 and 4.1 of [RFC8311];\n\n      -  is still obliged to respond appropriately to congestion\n         feedback, even when it is solely sending non-ECN-capable\n         packets (for rationale, some examples and some exceptions see Section 3.2.2.3, Section 3.2.2.4).\n\n      -  is still obliged to respond appropriately to congestion\n         feedback, even if it has sent or received a SYN or SYN/ACK\n         packet with (AE,CWR,ECE) = (0,0,0) during the handshake;\n\n      -  MUST NOT set CWR to indicate that it has received and responded\n         to indications of congestion.\n\n         For the avoidance of doubt, this is unlike an RFC 3168 data\n         sender and this does not preclude the Data Sender from setting\n         the bits of the ACE counter field, which includes an overloaded\n         use of the same bit.\n\n   Receiving ECT:\n\n   *  A host in AccECN mode:\n\n      -  MUST feed back the information in the IP-ECN field of incoming\n         packets using Accurate ECN feedback, as specified in Section 3.2. \n         For the avoidance of doubt, this requirement stands even if the\n         AccECN host has also sent or received a SYN or SYN/ACK with\n         (AE,CWR,ECE) = (0,0,0).  Reason: Such a SYN or SYN/ACK implies\n         some form of packet mangling might be present.  Even if the\n         remote peer is not setting ECT, it could still be set\n         erroneously by packet mangling at the IP layer (see Section 3.2.2.3).  In such cases, the Data Sender is best\n         placed to decide whether ECN markings are valid, but it can\n         only do that if the Data Receiver mechanistically feeds back\n         any ECN markings.  This approach will not lead to TCP Options\n         being generated unnecessarily if the recommended simple scheme\n         in Section 3.2.3.3 is used, because no byte counters will\n         change if no packets are set to ECT.\n\n      -  MUST NOT use reception of packets with ECT set in the IP-ECN\n         field as an implicit signal that the peer is ECN-capable.\n\n         Reason: ECT at the IP layer does not explicitly confirm the\n         peer has the correct ECN feedback logic, because the packets\n         could have been mangled at the IP layer.",
                "children": {}
              }
            }
          },
          "3.2": {
            "title": "AccECN Feedback",
            "content": "   Each Data Receiver of each half connection maintains four counters,\n   r.cep, r.ceb, r.e0b and r.e1b:\n\n   *  The Data Receiver MUST increment the CE packet counter (r.cep),\n      for every Acceptable packet that it receives with the CE code\n      point in the IP ECN field, including CE marked control packets and\n      retransmissions but excluding CE on SYN packets (SYN=1; ACK=0).\n\n   *  A Data Receiver that supports sending of AccECN TCP Options MUST\n      increment the r.ceb, r.e0b or r.e1b byte counters by the number of\n      TCP payload octets in Acceptable packets marked with the CE,\n      ECT(0) and ECT(1) codepoint in their IP-ECN field, including any\n      payload octets on control packets and retransmissions, but not\n      including any payload octets on SYN packets (SYN=1; ACK=0).\n\n   Each Data Sender of each half connection maintains four counters,\n   s.cep, s.ceb, s.e0b and s.e1b intended to track the equivalent\n   counters at the Data Receiver.\n\n   A Data Receiver feeds back the CE packet counter using the Accurate\n   ECN (ACE) field, as explained in Section 3.2.2.  And it optionally\n   feeds back all the byte counters using the AccECN TCP Option, as\n   specified in Section 3.2.3. \n   Whenever a Data Receiver feeds back the value of any counter, it MUST\n   report the most recent value, no matter whether it is in a pure ACK,\n   or an ACK piggybacked on a packet used by the other half-connection,\n   whether new payload data or a retransmission.  Therefore the feedback\n   piggybacked on a retransmitted packet is unlikely to be the same as\n   the feedback on the original packet.",
            "children": {
              "3.2.1": {
                "title": "Initialization of Feedback Counters",
                "content": "   When a host first enters AccECN mode, in its role as a Data Receiver\n   it initializes its counters to r.cep = 5, r.e0b = r.e1b = 1 and r.ceb\n   = 0,\n\n   Non-zero initial values are used to support a stateless handshake\n   (see Section 5.1) and to be distinct from cases where the fields are\n   incorrectly zeroed (e.g., by middleboxes - see Section 3.2.3.2.4).\n\n   When a host enters AccECN mode, in its role as a Data Sender it\n   initializes its counters to s.cep = 5, s.e0b = s.e1b = 1 and s.ceb =\n   0.",
                "children": {}
              },
              "3.2.2": {
                "title": "The ACE Field",
                "content": "   After AccECN has been negotiated on the SYN and SYN/ACK, both hosts\n   overload the three TCP flags (AE, CWR and ECE) in the main TCP header\n   as one 3-bit field.  Then the field is given a new name, ACE, as\n   shown in Figure 3.\n\n\n       0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n     |               |           |           | U | A | P | R | S | F |\n     | Header Length | Reserved  |    ACE    | R | C | S | S | Y | I |\n     |               |           |           | G | K | H | T | N | N |\n     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n      Figure 3: Definition of the ACE field within bytes 13 and 14 of\n        the TCP Header (when AccECN has been negotiated and SYN=0).\n\n   The original definition of these three flags in the TCP header,\n   including the addition of support for the ECN Nonce, is shown for\n   comparison in Figure 1.  This specification does not rename these\n   three TCP flags to ACE unconditionally; it merely overloads them with\n   another name and definition once an AccECN connection has been\n   established. \n   With one exception (Section 3.2.2.1), a host with both of its half-\n   connections in AccECN mode MUST interpret the AE, CWR and ECE flags\n   as the 3-bit ACE counter on a segment with the SYN flag cleared\n   (SYN=0).  On such a packet, a Data Receiver MUST encode the three\n   least significant bits of its r.cep counter into the ACE field that\n   it feeds back to the Data Sender.  The least significant bit is at\n   bit offset 9 in Figure 3.  A host MUST NOT interpret the 3 flags as a\n   3-bit ACE field on any segment with SYN=1 (whether ACK is 0 or 1), or\n   if AccECN negotiation is incomplete or has not succeeded.\n\n   Both parts of each of these conditions are equally important.  For\n   instance, even if AccECN negotiation has been successful, the ACE\n   field is not defined on any segments with SYN=1 (e.g., a\n   retransmission of an unacknowledged SYN/ACK, or when both ends send\n   SYN/ACKs after AccECN support has been successfully negotiated during\n   a simultaneous open).",
                "children": {
                  "3.2.2.1": {
                    "title": "ACE Field on the ACK of the SYN/ACK",
                    "content": "   A TCP Client (A) in AccECN mode MUST feed back which of the 4\n   possible values of the IP-ECN field was on the SYN/ACK by writing it\n   into the ACE field of a pure ACK with no SACK blocks using the binary\n   encoding in Table 3 (which is the same as that used on the SYN/ACK in\n   Table 2).  This shall be called the handshake encoding of the ACE\n   field, and it is the only exception to the rule that the ACE field\n   carries the 3 least significant bits of the r.cep counter on packets\n   with SYN=0.\n\n   Normally, a TCP Client acknowledges a SYN/ACK with an ACK that\n   satisfies the above conditions anyway (SYN=0, no data, no SACK\n   blocks).  If an AccECN TCP Client intends to acknowledge the SYN/ACK\n   with a packet that does not satisfy these conditions (e.g., it has\n   data to include on the ACK), it SHOULD first send a pure ACK that\n   does satisfy these conditions (see Section 5.2), so that it can feed\n   back which of the four values of the IP-ECN field arrived on the SYN/\n   ACK.  A valid exception to this \"SHOULD\" would be where the\n   implementation will only be used in an environment where mangling of\n   the ECN field is unlikely.\n\n   The TCP Client MUST also use the handshake encoding for the pure ACK\n   of any retransmitted SYN/ACK that confirms that the TCP Server\n   supports AccECN.  The procedure for the TCP Server to follow if the\n   final ACK of the handshake does not arrive before its retransmission\n   timer expires is given in Section 3.1.4.2. \n        +==================+================+=====================+\n        | IP-ECN codepoint | ACE on pure    | r.cep of TCP Client |\n        | on SYN/ACK       | ACK of SYN/ACK | in AccECN mode      |\n        +==================+================+=====================+\n        | Not-ECT          | 0b010          | 5                   |\n        +------------------+----------------+---------------------+\n        | ECT(1)           | 0b011          | 5                   |\n        +------------------+----------------+---------------------+\n        | ECT(0)           | 0b100          | 5                   |\n        +------------------+----------------+---------------------+\n        | CE               | 0b110          | 6                   |\n        +------------------+----------------+---------------------+\n\n            Table 3: The encoding of the ACE field in the ACK of\n             the SYN-ACK to reflect the SYN-ACK's IP-ECN field\n\n   When an AccECN Server in SYN-RCVD state receives a pure ACK with\n   SYN=0 and no SACK blocks, instead of treating the ACE field as a\n   counter, it MUST infer the meaning of each possible value of the ACE\n   field from Table 4, which also shows the value that an AccECN Server\n   MUST set s.cep to as a result.\n\n   Given this encoding of the ACE field on the ACK of a SYN/ACK is\n   exceptional, an AccECN Server using large receive offload (LRO) might\n   prefer to disable LRO until such an ACK has transitioned it out of\n   SYN-RCVD state. \n      +============+==========================+=====================+\n      | ACE on ACK | IP-ECN codepoint on SYN/ | s.cep of TCP Server |\n      | of SYN/ACK | ACK inferred by Server   | in AccECN mode      |\n      +============+==========================+=====================+\n      | 0b000      | {Notes 1, 3}             | Disable s.cep       |\n      +------------+--------------------------+---------------------+\n      | 0b001      | {Notes 2, 3}             | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b010      | Not-ECT                  | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b011      | ECT(1)                   | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b100      | ECT(0)                   | 5                   |\n      +------------+--------------------------+---------------------+\n      | 0b101      | Currently Unused {Note   | 5                   |\n      |            | 2}                       |                     |\n      +------------+--------------------------+---------------------+\n      | 0b110      | CE                       | 6                   |\n      +------------+--------------------------+---------------------+\n      | 0b111      | Currently Unused {Note   | 5                   |\n      |            | 2}                       |                     |\n      +------------+--------------------------+---------------------+\n\n        Table 4: Meaning of the ACE field on the ACK of the SYN/ACK\n\n   {Note 1}: If the Server is in AccECN mode and in SYN-RCVD state, and\n   if it receives a value of zero on a pure ACK with SYN=0 and no SACK\n   blocks, for the rest of the connection the Server MUST NOT set ECT on\n   outgoing packets and MUST NOT respond to AccECN feedback.\n   Nonetheless, as a Data Receiver it MUST NOT disable AccECN feedback.\n\n   Any of the circumstances below could cause a value of zero but,\n   whatever the cause, the actions above would be the appropriate\n   response:\n\n   *  The TCP Client has somehow entered No ECN feedback mode (most\n      likely if the Server received a SYN or sent a SYN/ACK with\n      (AE,CWR,ECE) = (0,0,0) after entering AccECN mode, but possible\n      even if it didn't);\n\n   *  The TCP Client genuinely might be in AccECN mode, but its count of\n      received CE marks might have caused the ACE field to wrap to zero.\n      This is highly unlikely, but not impossible because the Server\n      might have already sent multiple packets while still in SYN-RCVD\n      state, e.g., using TFO (see Section 5.2) and some might have been\n      CE-marked.  Then ACE on the first ACK seen by the Server might be\n      zero, due to previous ACKs experiencing an unfortunate pattern of\n      loss or delay. \n   *  Some form of non-compliance at the TCP Client or on the path (see Section 3.2.2.4).\n\n   {Note 2}: If the Server is in AccECN mode, these values are Currently\n   Unused but the AccECN Server's behaviour is still defined for forward\n   compatibility.  Then the designer of a future protocol can know for\n   certain what AccECN Servers will do with these codepoints.\n\n   {Note 3}: In the case where a Server that implements AccECN is also\n   using a stateless handshake (termed a SYN cookie) it will not\n   remember whether it entered AccECN mode.  The values 0b000 or 0b001\n   will remind it that it did not enter AccECN mode, because AccECN does\n   not use them (see Section 5.1 for details).  If a Server that uses a\n   stateless handshake and implements AccECN receives either of these\n   two values in the ACK, its action is implementation-dependent and\n   outside the scope of this document.  It will certainly not take the\n   action in the third column because, after it receives either of these\n   values, it is not in AccECN mode.  In example, it will not disable\n   ECN (at least not just because ACE is 0b000) and it will not set\n   s.cep.",
                    "children": {}
                  },
                  "3.2.2.2": {
                    "title": "Encoding and Decoding Feedback in the ACE Field",
                    "content": "   Whenever the Data Receiver sends an ACK with SYN=0 (with or without\n   data), unless the handshake encoding in Section 3.2.2.1 applies, the\n   Data Receiver MUST encode the least significant 3 bits of its r.cep\n   counter into the ACE field (see Appendix A.2).\n\n   Whenever the Data Sender receives an ACK with SYN=0 (with or without\n   data), it first checks whether it has already been superseded\n   (defined in Appendix A.1) by another ACK in which case it ignores the\n   ECN feedback.  If the ACK has not been superseded, and if the special\n   handshake encoding in Section 3.2.2.1 does not apply, the Data Sender\n   decodes the ACE field as follows (see Appendix A.2 for examples).\n\n   *  It takes the least significant 3 bits of its local s.cep counter\n      and subtracts them from the incoming ACE counter to work out the\n      minimum positive increment it could apply to s.cep (assuming the\n      ACE field only wrapped at most once).\n\n   *  It then follows the safety procedures in Section 3.2.2.5.2 to\n      calculate or estimate how many packets the ACK could have\n      acknowledged under the prevailing conditions to determine whether\n      the ACE field might have wrapped more than once.\n\n   The encode/decode procedures during the three-way handshake are\n   exceptions to the general rules given so far, so they are spelled out\n   step by step below for clarity:\n   *  If a TCP Server in AccECN mode receives a CE mark in the IP-ECN\n      field of a SYN (SYN=1, ACK=0), it MUST NOT increment r.cep (it\n      remains at its initial value of 5).\n\n      Reason: It would be redundant for the Server to include CE-marked\n      SYNs in its r.cep counter, because it already reliably delivers\n      feedback of any CE marking using the encoding in the top block of\n      Table 2 in the SYN/ACK.  This also ensures that, when the Server\n      starts using the ACE field, it has not unnecessarily consumed more\n      than one initial value, given they can be used to negotiate\n      variants of the AccECN protocol (see Appendix B.3).\n\n   *  If a TCP Client in AccECN mode receives CE feedback in the TCP\n      flags of a SYN/ACK, it MUST NOT increment s.cep (it remains at its\n      initial value of 5), so that it stays in step with r.cep on the\n      Server.  Nonetheless, the TCP Client still triggers the congestion\n      control actions necessary to respond to the CE feedback.\n\n   *  If a TCP Client in AccECN mode receives a CE mark in the IP-ECN\n      field of a SYN/ACK, it MUST increment r.cep, but no more than once\n      no matter how many CE-marked SYN/ACKs it receives\n      (i.e., incremented from 5 to 6, but no further).\n\n      Reason: Incrementing r.cep ensures the Client will eventually\n      deliver any CE marking to the Server reliably when it starts using\n      the ACE field.  Even though the Client also feeds back any CE\n      marking on the ACK of the SYN/ACK using the encoding in Table 3,\n      this ACK is not delivered reliably, so it can be considered as a\n      timely notification that is redundant but unreliable.  The Client\n      does not increment r.cep more than once, because the Server can\n      only increment s.cep once (see next bullet).  Also, this limits\n      the unnecessarily consumed initial values of the ACE field to two.\n\n   *  If a TCP Server in AccECN mode and in SYN-RCVD state receives CE\n      feedback in the TCP flags of a pure ACK with no SACK blocks, it\n      MUST increment s.cep (from 5 to 6).  The TCP Server then triggers\n      the congestion control actions necessary to respond to the CE\n      feedback.\n\n      Reasoning: The TCP Server can only increment s.cep once, because\n      the first ACK it receives will cause it to transition out of SYN-\n      RCVD state.  The Server's congestion response would be no\n      different even if it could receive feedback of more than one CE-\n      marked SYN/ACK.\n\n      Once the TCP Server transitions to ESTABLISHED state, it might\n      later receive other pure ACK(s) with the handshake encoding in the\n      ACE field.  A Server MAY implement a test for such a case, but it \n      is not required.  Therefore, once in the ESTABLISHED state, it\n      will be sufficient for the Server to consider the ACE field to be\n      encoded as the normal ACE counter on all packets with SYN=0.\n\n      Reasoning: Such ACKs will be quite unusual, e.g., a SYN/ACK (or\n      ACK of the SYN/ACK) that is delayed for longer than the Server's\n      retransmission timeout; or packet duplication by the network.  And\n      the impact of any error in the feedback on such ACKs will only be\n      temporary.",
                    "children": {}
                  },
                  "3.2.2.3": {
                    "title": "Testing for Mangling of the IP/ECN Field",
                    "content": "   *  TCP Client side:\n\n      The value of the TCP-ECN flags on the SYN/ACK indicates the value\n      of the IP-ECN field when the SYN arrived at the Server.  The TCP\n      Client can compare this with how it originally set the IP-ECN\n      field on the SYN.  If this comparison implies an invalid\n      transition (defined below) of the IP-ECN field, for the remainder\n      of the half-connection the Client is advised to send non-ECN-\n      capable packets, but it still ought to respond to any feedback of\n      CE markings (explained below).  However, the TCP Client MUST\n      remain in the AccECN feedback mode and it MUST continue to feed\n      back any ECN markings on arriving packets (in its role as Data\n      Receiver).\n\n   *  TCP Server side:\n\n      The value of the ACE field on the last ACK of the three-way\n      handshake indicates the value of the IP-ECN field when the SYN/ACK\n      arrived at the TCP Client.  The Server can compare this with how\n      it originally set the IP-ECN field on the SYN/ACK.  If this\n      comparison implies an invalid transition of the IP-ECN field, for\n      the remainder of the half-connection the Server is advised to send\n      non-ECN-capable packets, but it still ought to respond to any\n      feedback of CE markings (explained below).  However, the Server\n      MUST remain in the AccECN feedback mode and it MUST continue to\n      feed back any ECN markings on arriving packets (in its role as\n      Data Receiver).\n\n   If a Data Sender in AccECN mode starts sending non-ECN-capable\n   packets because it has detected mangling, it is still advised to\n   respond to CE feedback.  Reason: any CE-marking arriving at the Data\n   Receiver could be due to something early in the path mangling the\n   non-ECN-capable IP-ECN field into an ECN-capable codepoint and then,\n   later in the path, a network bottleneck might be applying CE-markings\n   to indicate genuine congestion.  This argument applies whether the\n   handshake packet originally sent by the TCP Client or Server was non-\n   ECN-capable or ECN-capable because, in either case, an unsafe\n   transition could imply that non-ECN-capable packets later in the\n   connection might get mangled.\n\n   Once a Data Sender has entered AccECN mode it is advised to check\n   whether it is receiving continuous feedback of CE.  Specifying\n   exactly how to do this is beyond the scope of the present\n   specification, but the sender might check whether the feedback for\n   every packet it sends for the first three or four rounds indicates\n   CE-marking.  If continuous CE-marking is detected, for the remainder\n   of the half-connection, the Data Sender ought to send non-ECN-capable\n   packets and it is advised not to respond to any feedback of CE\n   markings.  The Data Sender might occasionally test whether it can\n   resume sending ECN-capable packets.\n\n   The above advice on switching to sending non-ECN-capable packets but\n   still responding to CE-markings unless they become continuous is not\n   stated normatively (in capitals), because the best strategy might\n   depend on experience of the most likely types of mangling, which can\n   only be known at the time of deployment.  The same is true for other\n   forms of mangling (or resumption of expected marking) during later\n   stages of a connection.\n\n   As always, once a host has entered AccECN mode, it follows the\n   general mandatory requirements (Section 3.1.5) to remain in the same\n   feedback mode and to continue feeding back any ECN markings on\n   arriving packets using AccECN feedback.  This follows the general\n   approach where an AccECN Data Receiver mechanistically reflects\n   whatever it receives (Section 2.5).\n\n   The ACK of the SYN/ACK is not reliably delivered (nonetheless, the\n   count of CE marks is still eventually delivered reliably).  If this\n   ACK does not arrive, the Server is advised to continue to send ECN-\n   capable packets without having tested for mangling of the IP-ECN\n   field on the SYN/ACK.\n\n   All the fall-back behaviours in this section are necessary in case\n   mangling of the IP-ECN field is asymmetric, which is currently common\n   over some mobile networks [Mandalari18].  Then one end might see no\n   unsafe transition and continue sending ECN-capable packets, while the\n   other end sees an unsafe transition and stops sending ECN-capable\n   packets.\n\n   Invalid transitions of the IP-ECN field are defined in section 18 of\n   the Classic ECN specification [RFC3168] and repeated here for\n   convenience:\n\n   *  the not-ECT codepoint changes;\n   *  either ECT codepoint transitions to not-ECT;\n\n   *  the CE codepoint changes. RFC 3168 says that a router that changes ECT to not-ECT is invalid\n   but safe.  However, from a host's viewpoint, this transition is\n   unsafe because it could be the result of two transitions at different\n   routers on the path: ECT to CE (safe) then CE to not-ECT (unsafe).\n   This scenario could well happen where an ECN-enabled home router\n   congests its upstream mobile broadband bottleneck link, then the\n   ingress to the mobile network clears the ECN field [Mandalari18].",
                    "children": {}
                  },
                  "3.2.2.4": {
                    "title": "Testing for Zeroing of the ACE Field",
                    "content": "\n\n   Section 3.2.2 required the Data Receiver to initialize the r.cep\n   counter to a non-zero value.  Therefore, in either direction the\n   initial value of the ACE counter ought to be non-zero.\n\n   This section does not concern the case where the ACE field is zero\n   when the handshake encoding has been used on the ACK of the SYN/ACK\n   under the carefully worded conditions in Section 3.2.2.1.\n\n   If AccECN has been successfully negotiated, the Data Sender MAY check\n   the value of the ACE counter in the first feedback packet (with or\n   without data) that arrives after the three-way handshake.  If the\n   value of this ACE field is found to be zero (0b000), for the\n   remainder of the half-connection the Data Sender ought to send non-\n   ECN-capable packets and it is advised not to respond to any feedback\n   of CE markings.\n\n   Reason: the symptoms imply any or all of the following:\n\n   *  the remote peer has somehow entered Not ECN feedback mode;\n\n   *  a broken remote TCP implementation;\n\n   *  potential mangling of the ECN fields in the TCP headers (although\n      unlikely given they clearly survived during the handshake).\n\n   This advice is not stated normatively (in capitals), because the best\n   strategy might depend on experience of the most likely scenarios,\n   which can only be known at the time of deployment.\n\n   Note that a host in AccECN mode MUST continue to provide Accurate ECN\n   feedback to its peer, even if it is no longer sending ECT itself over\n   the other half connection. \n   If reordering occurs, the first feedback packet that arrives will not\n   necessarily be the same as the first packet in sequence order.  The\n   test has been specified loosely like this to simplify implementation,\n   and because it would not have been any more precise to have specified\n   the first packet in sequence order, which would not necessarily be\n   the first ACE counter that the Data Receiver fed back anyway, given\n   it might have been a retransmission.\n\n   The possibility of re-ordering means that there is a small chance\n   that the ACE field on the first packet to arrive is genuinely zero\n   (without middlebox interference).  This would cause a host to\n   unnecessarily disable ECN for a half connection.  Therefore, in\n   environments where there is no evidence of the ACE field being\n   zeroed, implementations MAY skip this test.\n\n   Note that the Data Sender MUST NOT test whether the arriving counter\n   in the initial ACE field has been initialized to a specific valid\n   value - the above check solely tests whether the ACE fields have been\n   incorrectly zeroed.  This allows hosts to use different initial\n   values as an additional signalling channel in future.",
                    "children": {}
                  },
                  "3.2.2.5": {
                    "title": "Safety against Ambiguity of the ACE Field",
                    "content": "   If too many CE-marked segments are acknowledged at once, or if a long\n   run of ACKs is lost or thinned out, the 3-bit counter in the ACE\n   field might have cycled between two ACKs arriving at the Data Sender.\n   The following safety procedures minimize this ambiguity.",
                    "children": {
                      "3.2.2.5.1": {
                        "title": "Packet Receiver Safety Procedures",
                        "content": "   The following rules define when the receiver of a packet in AccECN\n   mode emits an ACK:\n\n   Change-Triggered ACKs:  An AccECN Data Receiver SHOULD emit an ACK\n      whenever a data packet marked CE arrives after the previous packet\n      was not CE.\n\n      Even though this rule is stated as a \"SHOULD\", it is important for\n      a transition to trigger an ACK if at all possible, The only valid\n      exception to this rule is given below these bullets.\n\n      For the avoidance of doubt, this rule is deliberately worded to\n      apply solely when _data_ packets arrive, but the comparison with\n      the previous packet includes any packet, not just data packets.\n\n   Increment-Triggered ACKs:  An AccECN receiver of a packet MUST emit \n      an ACK if 'n' CE marks have arrived since the previous ACK.  If\n      there is unacknowledged data at the receiver, 'n' SHOULD be 2.  If\n      there is no unacknowledged data at the receiver, 'n' SHOULD be 3\n      and MUST be no less than 3.  In either case, 'n' MUST be no\n      greater than 7.\n\n   The above rules for when to send an ACK are designed to be\n   complemented by those in Section 3.2.3.3, which concern whether an\n   AccECN TCP Option ought to be included on ACKs.\n\n   If the arrivals of a number of data packets are all processed as one\n   event, e.g., using large receive offload (LRO) or generic receive\n   offload (GRO), both the above rules SHOULD be interpreted as\n   requiring multiple ACKs to be emitted back-to-back (for each\n   transition and for each sequence of 'n' CE marks).  If this is\n   problematic for high performance, either rule can be interpreted as\n   requiring just a single ACK at the end of the whole receive event.\n\n   Even if a number of data packets do not arrive as one event, the\n   'Change-Triggered ACKs' rule could sometimes cause the ACK rate to be\n   problematic for high performance (although high performance protocols\n   such as DCTCP already successfully use change-triggered ACKs).  The\n   rationale for change-triggered ACKs is so that the Data Sender can\n   rely on them to detect queue growth as soon as possible, particularly\n   at the start of a flow.  The approach can lead to some additional\n   ACKs but it feeds back the timing and the order in which ECN marks\n   are received with minimal additional complexity.  If CE marks are\n   infrequent, as is the case for most Active Queue Managment (AQM)\n   packet schedulers at the time of writing, or there are multiple marks\n   in a row, the additional load will be low.  However, marking patterns\n   with numerous non-contiguous CE marks could increase the load\n   significantly.  One possible compromise would be for the receiver to\n   heuristically detect whether the sender is in slow-start, then to\n   implement change-triggered ACKs while the sender is in slow-start,\n   and offload otherwise.\n\n   In a scenario where both endpoints support AccECN, if host B has\n   chosen to use ECN-capable pure ACKs (as allowed in [RFC8311]\n   experiments) and enough of these ACKs become CE-marked, then the\n   'Increment-Triggered ACKs' rule ensures that its peer (host A) gives\n   B sufficient feedback about this congestion on the ACKs from B to A.\n   Normally, for instance in a unidirectional data scenario from host A\n   to B, the Data Sender (A) can piggyback that feedback on its data.\n   But if A stops sending data, the second part of the 'Increment-\n   Triggered ACKs' rule requires A to emit a pure ACK for at least every\n   third CE-marked incoming ACK over the subsequent round trip. \n   Although TCP normally only ACKs data segments, in this case the\n   increment-triggered ACK rule makes it mandatory for A to emit ACKs of\n   ACKs.  This is justifiable because the ACKs in this case are ECN-\n   capable and so, even though the ACKs of these ACKs do not acknowledge\n   new data, they feed back new congestion state (useful in case B\n   starts sending).  The minimum of 3 for 'n' in this case ensures that,\n   even if A also uses ECN-capable pure ACKs, and even if there is\n   pathological congestion in both directions, any resulting ping-pong\n   of ACKs will be rapidly damped.\n\n   In the above bidirectional scenario, incoming ACKs of ACKs could be\n   mistaken for duplicate ACKs.  But ACKs of ACKs can be distinguished\n   from duplicate ACKs because they do not contain any SACK blocks even\n   when SACK has been negotiated.  It is outside the scope of this\n   AccECN specification to normatively specify this additional test for\n   DupACKs, because ACKs of ACKs can only arise if the original ACKs are\n   ECN-capable.  Instead any specification that allows ECN-capable pure\n   ACKs MUST make sending ACKs of ACKs conditional on measures to\n   distinguish ACKs of ACKs from DupACKs (see for example\n   [I-D.ietf-tcpm-generalized-ecn ]).  All that is necessary here is to\n   require that these ACKs of ACKs MUST NOT contain any SACK blocks\n   (which would normally not happen anyway).",
                        "children": {}
                      },
                      "3.2.2.5.2": {
                        "title": "Data Sender Safety Procedures",
                        "content": "   If the Data Sender has not received AccECN TCP Options to give it\n   more dependable information, and it detects that the ACE field could\n   have cycled, it SHOULD deem whether it cycled by taking the safest\n   likely case under the prevailing conditions.  It can detect if the\n   counter could have cycled by using the jump in the acknowledgement\n   number since the last ACK to calculate or estimate how many segments\n   could have been acknowledged.  An example algorithm to implement this\n   policy is given in Appendix A.2.  An implementation MAY use an\n   alternative algorithm as long as it satisfies the requirements in\n   this subsection.\n\n   If missing acknowledgement numbers arrive later (reordering) and\n   prove that the counter did not cycle, the Data Sender MAY attempt to\n   neutralize the effect of any action it took based on a conservative\n   assumption that it later found to be incorrect.\n\n   The Data Sender can estimate how many packets (of any marking) an ACK\n   acknowledges.  If the ACE counter on an ACK seems to imply that the\n   minimum number of newly CE-marked packets is greater than the number\n   of newly acknowledged packets, the Data Sender SHOULD consider the\n   ACE counter to be correct (and its count of control packets to be\n   incomplete), unless it can be sure that it is counting all control\n   packets correctly. \n\n\n\n",
                        "children": {}
                      }
                    }
                  }
                }
              },
              "3.2.3": {
                "title": "The AccECN Option",
                "content": "   Two alternative AccECN Options are defined as shown in Figure 4.  The\n   initial 'E' of each field name stands for 'Echo'.\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Kind = 172   |  Length = 11  |          EE0B field           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | EE0B (cont'd) |           ECEB field                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                  EE1B field                   |             Order 0\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Kind = 174   |  Length = 11  |          EE1B field           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | EE1B (cont'd) |           ECEB field                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                  EE0B field                   |             Order 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n              Figure 4: The Two Alternative AccECN TCP Options\n\n   Figure 4 shows two option field orders; order 0 and order 1.  They\n   both consists of three 24-bit fields.  Order 0 provides the 24 least\n   significant bits of the r.e0b, r.ceb and r.e1b counters,\n   respectively.  Order 1 provides the same fields, but in the opposite\n   order.  On each packet, the Data Receiver can use whichever order is\n   more efficient.  In either case, the bytes within the fields are in\n   network byte order (big-endian).\n\n   The choice to use three bytes (24 bits) fields in the options was\n   made to strike a balance between TCP option space usage, and the\n   required fidelity of the counters to accomodate typical scenarios\n   such as hardware TCP segmentation offloading (TSO), and periods where\n   no option may be transmitted (e.g., SACK loss recovery).  Providing\n   only 2 bytes (16 bits) for these counters could easily roll over\n   within a single TSO transmission or large/generic receive offload\n   (LRO/GRO) event.  Having two distinct orderings further allows the\n   transmission of the most pertinent changes in an abbreviated option\n   (see below). \n   When a Data Receiver sends an AccECN Option, it MUST set the Kind\n   field to 172 if using Order 0, or to 174 if using Order 1.  These two\n   new TCP Option Kinds are registered in Section 7 and called\n   respectively AccECN0 and AccECN1.\n\n   Note that there is no field to feed back Not-ECT bytes.  Nonetheless\n   an algorithm for the Data Sender to calculate the number of payload\n   bytes received as Not-ECT is given in Appendix A.4.\n\n   Whenever a Data Receiver sends an AccECN Option, the rules in Section 3.2.3.3 allow it to omit unchanged fields from the tail of\n   the option, to help cope with option space limitations, as long as it\n   preserves the order of the remaining fields and includes any field\n   that has changed.  The length field MUST indicate which fields are\n   present as follows:\n\n             +========+==================+==================+\n             | Length | Order 0          | Order 1          |\n             +========+==================+==================+\n             | 11     | EE0B, ECEB, EE1B | EE1B, ECEB, EE0B |\n             +--------+------------------+------------------+\n             | 8      | EE0B, ECEB       | EE1B, ECEB       |\n             +--------+------------------+------------------+\n             | 5      | EE0B             | EE1B             |\n             +--------+------------------+------------------+\n             | 2      | (empty)          | (empty)          |\n             +--------+------------------+------------------+\n\n                  Table 5: Fields included in AccECN TCP\n                     Options of each length and order\n\n   The empty option of Length=2 is provided to allow for a case where an\n   AccECN Option has to be sent (e.g., on the SYN/ACK to test the path),\n   but there is very limited space for the option.\n\n   All implementations of a Data Sender that read any AccECN Option MUST\n   be able to read AccECN Options of any of the above lengths.  For\n   forward compatibility, if the AccECN Option is of any other length,\n   implementations MUST use those whole 3-octet fields that fit within\n   the length and ignore the remainder of the option, treating it as\n   padding.\n\n   AccECN Options have to be optional to implement, because both sender\n   and receiver have to be able to cope without options anyway - in\n   cases where they do not traverse a network path.  It is RECOMMENDED\n   to implement both sending and receiving of AccECN Options.  Support\n   for AccECN Options is particularly valuable over paths that introduce\n   a high degree of ACK filtering, where the 3-bit ACE counter alone \n   might sometimes be insufficient, when it is ambiguous whether it has\n   wrapped.  If sending of AccECN Options is implemented, the fall-backs\n   described in this document will need to be implemented as well\n   (unless solely for a controlled environment where path traversal is\n   not considered a problem).  Even if a developer does not implement\n   logic to understand received AccECN Options, it is RECOMMENDED that\n   they implement logic to send AccECN Options.  Otherwise, those remote\n   peers that implement the receiving logic will still be excluded from\n   congestion feedback that is robust against the increasingly\n   aggressive ACK filtering in the Internet.  The logic to send AccECN\n   Options is the simpler to implement of the two sides.\n\n   If a Data Receiver intends to send an AccECN Option at any time\n   during the rest of the connection it is RECOMMENDED to also test path\n   traversal of the AccECN Option as specified in Section 3.2.3.2.",
                "children": {
                  "3.2.3.1": {
                    "title": "Encoding and Decoding Feedback in the AccECN Option Fields",
                    "content": "   Whenever the Data Receiver includes any of the counter fields (ECEB,\n   EE0B, EE1B) in an AccECN Option, it MUST encode the 24 least\n   significant bits of the current value of the associated counter into\n   the field (respectively r.ceb, r.e0b, r.e1b).\n\n   Whenever the Data Sender receives an ACK carrying an AccECN Option,\n   it first checks whether the ACK has already been superseded by\n   another ACK in which case it ignores the ECN feedback.  If the ACK\n   has not been superseded, the Data Sender normally decodes the fields\n   in the AccECN Option as follows.  For each field, it takes the least\n   significant 24 bits of its associated local counter (s.ceb, s.e0b or\n   s.e1b) and subtracts them from the counter in the associated field of\n   the incoming AccECN Option (respectively ECEB, EE0B, EE1B), to work\n   out the minimum positive increment it could apply to s.ceb, s.e0b or\n   s.e1b (assuming the field in the option only wrapped at most once). Appendix A.1 gives an example algorithm for the Data Receiver to\n   encode its byte counters into an AccECN Option, and for the Data\n   Sender to decode the AccECN Option fields into its byte counters.\n\n   Note that, as specified in Section 3.2, any data on the SYN (SYN=1,\n   ACK=0) is not included in any of the byte counters held locally for\n   each ECN marking nor in an AccECN Option on the wire.",
                    "children": {}
                  },
                  "3.2.3.2": {
                    "title": "Path Traversal of the AccECN Option",
                    "content": "\n\n\n\n\n\n\n\n\n\n\n\n\n",
                    "children": {
                      "3.2.3.2.1": {
                        "title": "Testing the AccECN Option during the Handshake",
                        "content": "   The TCP Client MUST NOT include an AccECN TCP Option on the SYN.  If\n   there is somehow an AccECN Option on a SYN, it MUST be ignored when\n   forwarded or received.\n\n   A TCP Server that confirms its support for AccECN (in response to an\n   AccECN SYN from the Client as described in Section 3.1) SHOULD\n   include an AccECN TCP Option on the SYN/ACK.\n\n   A TCP Client that has successfully negotiated AccECN SHOULD include\n   an AccECN Option in the first ACK at the end of the three-way\n   handshake.  However, this first ACK is not delivered reliably, so the\n   TCP Client SHOULD also include an AccECN Option on the first data\n   segment it sends (if it ever sends one).\n\n   A host MAY omit an AccECN Option in any of the above three cases due\n   to insufficient option space or if it has cached knowledge that the\n   packet would be likely to be blocked on the path to the other host if\n   it included an AccECN Option.",
                        "children": {}
                      },
                      "3.2.3.2.2": {
                        "title": "Testing for Loss of Packets Carrying the AccECN Option",
                        "content": "   If the TCP Server has not received an ACK to acknowledge its SYN/ACK\n   after the normal TCP timeout or it receives a second SYN with a\n   request for AccECN support, then either the SYN/ACK might just have\n   been lost, e.g., due to congestion, or a middlebox might be blocking\n   AccECN Options.  To expedite connection setup in deployment scenarios\n   where AccECN path traversal might be problematic, the TCP Server\n   SHOULD retransmit the SYN/ACK, but with no AccECN Option.  If this\n   retransmission times out, to expedite connection setup, the TCP\n   Server SHOULD retransmit the SYN/ACK with (AE,CWR,ECE) = (0,0,0) and\n   no AccECN Option, but it remains in AccECN feedback mode (per Section 3.1.5).\n\n      |  Note that a retransmitted AccECN SYN/ACK will not necessarily\n      |  have the same TCP-ECN flags as the original SYN/ACK, because it\n      |  feeds back the IP-ECN field of the latest SYN to have arrived\n      |  (by the rule in Section 3.1.5).\n\n   The above fall-back approach limits any interference by middleboxes\n   that might drop packets with unknown options, even though it is more\n   likely that SYN/ACK loss is due to congestion.  The TCP Server MAY\n   try to send another packet with an AccECN Option at a later point\n   during the connection but it ought to monitor if that packet got lost\n   as well, in which case it SHOULD disable the sending of AccECN\n   Options for this half-connection. \n   Implementers MAY use other fall-back strategies if they are found to\n   be more effective (e.g., retrying an AccECN Option for a second time\n   before fall-back - most appropriate during high levels of\n   congestion).  However, other fall-back strategies will need to follow\n   all the rules in Section 3.1.5, which concern behaviour when SYNs or\n   SYN/ACKs negotiating different types of feedback have been sent\n   within the same connection.\n\n   Further it might make sense to also remove any other new or\n   experimental fields or options on the SYN/ACK, although the required\n   behaviour will depend on the specification of the other option(s) and\n   on any attempt to co-ordinate fall-back between different modules of\n   the stack.\n\n   If the TCP Client detects that the first data segment it sent with an\n   AccECN Option was lost, in deployment scenarios where AccECN path\n   traversal might be problematic, it SHOULD fall back to no AccECN\n   Option on the retransmission.  Again, implementers MAY use other\n   fall-back strategies such as attempting to retransmit a second\n   segment with an AccECN Option before fall-back, and/or caching\n   whether AccECN Options are blocked for subsequent connections.\n   [RFC9040] further discusses caching of TCP parameters and status\n   information.\n\n   If a middlebox is dropping packets with options it does not\n   recognize, a host that is sending little or no data but mostly pure\n   ACKs will not inherently detect such losses.  Such a host MAY detect\n   loss of ACKs carrying the AccECN Option by detecting whether the\n   acknowledged data always reappears as a retransmission.  In such\n   cases, the host SHOULD disable the sending of the AccECN Option for\n   this half-connection.\n\n   If a host falls back to not sending AccECN Options, it will continue\n   to process any incoming AccECN Options as normal.\n\n   Either host MAY include AccECN Options in a subsequent segment or\n   segments to retest whether AccECN Options can traverse the path.\n\n   Similarly, an AccECN endpoint MAY separately memorize which data\n   packets carried an AccECN Option and disable the sending of AccECN\n   Options if the loss probability of those packets is significantly\n   higher than that of all other data packets in the same connection. \n\n\n\n",
                        "children": {}
                      },
                      "3.2.3.2.3": {
                        "title": "Testing for Absence of the AccECN Option",
                        "content": "   If the TCP Client has successfully negotiated AccECN but does not\n   receive an AccECN Option on the SYN/ACK (e.g., because is has been\n   stripped by a middlebox or not sent by the Server), the Client\n   switches into a mode that assumes that the AccECN Option is not\n   available for this half connection.\n\n   Similarly, if the TCP Server has successfully negotiated AccECN but\n   does not receive an AccECN Option on the first segment that\n   acknowledges sequence space at least covering the ISN, it switches\n   into a mode that assumes that the AccECN Option is not available for\n   this half connection.\n\n   While a host is in this mode that assumes incoming AccECN Options are\n   not available, it MUST adopt the conservative interpretation of the\n   ACE field discussed in Section 3.2.2.5.  However, it cannot make any\n   assumption about support of outgoing AccECN Options on the other half\n   connection, so it SHOULD continue to send AccECN Options itself\n   (unless it has established that sending AccECN Options is causing\n   packets to be blocked as in Section 3.2.3.2.2).\n\n   If a host is in the mode that assumes incoming AccECN Options are not\n   available, but it receives an AccECN Option at any later point during\n   the connection, this clearly indicates that AccECN Options are no\n   longer blocked on the respective path, and the AccECN endpoint MAY\n   switch out of the mode that assumes AccECN Options are not available\n   for this half connection.",
                        "children": {}
                      },
                      "3.2.3.2.4": {
                        "title": "Test for Zeroing of the AccECN Option",
                        "content": "   For a related test for invalid initialization of the ACE field, see Section 3.2.2.4\n\n   Section 3.2.1 required the Data Receiver to initialize the r.e0b and\n   r.e1b counters to a non-zero value.  Therefore, in either direction\n   the initial value of the EE0B field or EE1B field in an AccECN Option\n   (if one exists) ought to be non-zero.  If AccECN has been negotiated:\n\n   *  the TCP Server MAY check that the initial value of the EE0B field\n      or the EE1B field is non-zero in the first segment that\n      acknowledges sequence space that at least covers the ISN plus 1.\n      If it runs a test and either initial value is zero, the Server\n      will switch into a mode that ignores AccECN Options for this half\n      connection. \n   *  the TCP Client MAY check the initial value of the EE0B field or\n      the EE1B field is non-zero on the SYN/ACK.  If it runs a test and\n      either initial value is zero, the Client will switch into a mode\n      that ignores AccECN Options for this half connection.\n\n   While a host is in the mode that ignores AccECN Options it MUST adopt\n   the conservative interpretation of the ACE field discussed in Section 3.2.2.5.\n\n   Note that the Data Sender MUST NOT test whether the arriving byte\n   counters in an initial AccECN Option have been initialized to\n   specific valid values - the above checks solely test whether these\n   fields have been incorrectly zeroed.  This allows hosts to use\n   different initial values as an additional signalling channel in\n   future.  Also note that the initial value of either field might be\n   greater than its expected initial value, because the counters might\n   already have been incremented.  Nonetheless, the initial values of\n   the counters have been chosen so that they cannot wrap to zero on\n   these initial segments.",
                        "children": {}
                      },
                      "3.2.3.2.5": {
                        "title": "Consistency between AccECN Feedback Fields",
                        "content": "   When AccECN Options are available they ought to provide more\n   unambiguous feedback.  However, they supplement but do not replace\n   the ACE field.  An endpoint using AccECN feedback MUST always\n   reconcile the information provided in the ACE field with that in any\n   AccECN Option, so that the state of the ACE-related packet counter\n   can be relied on if future feedback does not carry an AccECN Option.\n\n   If an AccECN Option is present, the s.cep counter might increase more\n   than expected from the increase of the s.ceb counter (e.g., due to a\n   CE-marked control packet).  The sender's response to such a situation\n   is out of scope, and needs to be dealt with in a specification that\n   uses ECN-capable control packets.  Theoretically, this situation\n   could also occur if a middlebox mangled an AccECN Option but not the\n   ACE field.  However, the Data Sender has to assume that the integrity\n   of AccECN Options is sound, based on the above test of the well-known\n   initial values and optionally other integrity tests (Section 5.3).\n\n   If either endpoint detects that the s.ceb counter has increased but\n   the s.cep has not (and by testing ACK coverage it is certain how much\n   the ACE field has wrapped), and if there is no explanation other than\n   an invalid protocol transition due to some form of feedback mangling,\n   the Data Sender MUST disable sending ECN-capable packets for the\n   remainder of the half-connection by setting the IP-ECN field in all\n   subsequent packets to Not-ECT. \n\n\n\n",
                        "children": {}
                      }
                    }
                  },
                  "3.2.3.3": {
                    "title": "Usage of the AccECN TCP Option",
                    "content": "   If a Data Receiver in AccECN mode intends to use AccECN TCP Options\n   to provide feedback, the rules below determine when it includes an\n   AccECN TCP Option, and which fields to include, given other options\n   might be competing for limited option space:\n\n   Importance of Congestion Control:  AccECN is for congestion control,\n      which implementations SHOULD generally prioritize over other TCP\n      options when there is insufficient space for all the options in\n      use.\n\n      If SACK has been negotiated [RFC2018], and the smallest\n      recommended AccECN Option would leave insufficient space for two\n      SACK blocks on a particular ACK, the Data Receiver MUST give\n      precedence to the SACK option (total 18 octets), because loss\n      feedback is more critical.\n\n   Recommended Simple Scheme:  The Data Receiver SHOULD include an\n      AccECN TCP Option on every scheduled ACK if any byte counter has\n      incremented since the last ACK.  Whenever possible, it SHOULD\n      include a field for every byte counter that has changed at some\n      time during the connection (see examples later).\n\n      A scheduled ACK means an ACK that the Data Receiver would send by\n      its regular delayed ACK rules.  Recall that Section 1.3 defines an\n      'ACK' as either with data payload or without.  But the above rule\n      is worded so that, in the common case when most of the data is\n      from a Server to a Client, the Server only includes an AccECN TCP\n      Option while it is acknowledging data from the Client.\n\n   When available TCP option space is limited on particular packets, the\n   recommended scheme will need to include compromises.  To guide the\n   implementer the rules below are ranked in order of importance, but\n   the final decision has to be implementation-dependent, because\n   tradeoffs will alter as new TCP options are defined and new use-cases\n   arise.\n\n   Necessary Option Length:  When TCP option space is limited, an AccECN\n      TCP option MAY be truncated to omit one or two fields from the end\n      of the option, as indicated by the permitted variants listed in\n      Table 5, provided that the counter(s) that have changed since the\n      previous AccECN TCP option are not omitted.\n\n      If there is insufficient space to include an AccECN TCP option\n      containing the counter(s) that have changed since the previous\n      AccECN TCP option, then the entire AccECN TCP option MUST be\n      omitted. (see Section 3.2.3);\n   Change-Triggered AccECN TCP Options:  If an arriving packet\n      increments a different byte counter to that incremented by the\n      previous packet, the Data Receiver SHOULD feed it back in an\n      AccECN Option on the next scheduled ACK.\n\n      For the avoidance of doubt, this rule does not concern the arrival\n      of control packets with no payload, because they cannot alter any\n      byte counters.\n\n   Continual Repetition:  Otherwise, if arriving packets continue to\n      increment the same byte counter:\n\n      *  the Data Receiver SHOULD include a counter that has continued\n         to increment on the next scheduled ACK following a change-\n         triggered AccECN TCP Option;\n\n      *  while the same counter continues to increment, it SHOULD\n         include the counter every n ACKs as consistently as possible,\n         where n can be chosen by the implementer;\n\n      *  It SHOULD always include an AccECN Option if the r.ceb counter\n         is incrementing and it MAY include an AccECN Option if r.ec0b\n         or r.ec1b is incrementing\n\n      *  It SHOULD include each counter at least once for every 2^22\n         bytes incremented to prevent overflow during continual\n         repetition.\n\n   The above rules complement those in Section 3.2.2.5, which determine\n   when to generate an ACK irrespective of whether an AccECN TCP Option\n   is to be included.\n\n   The recommended scheme is intended as a simple way to ensure that all\n   the relevant byte counters will be carried on any ACK that reaches\n   the Data Sender, no matter how many pure ACKs are filtered or\n   coalesced along the network path, and without consuming the space\n   available for payload data with counter field(s) that have never\n   changed.\n\n   As an example of the recommended scheme, if ECT(0) is the only\n   codepoint that has ever arrived in the IP-ECN field, the Data\n   Receiver will feed back an AccECN0 TCP Option with only the EE0B\n   field on every packet that acknowledges new data.  However, as soon\n   as even one CE-marked packet arrives, on every packet that\n   acknowledges new data it will start to include an option with two\n   fields, EE0B and ECEB.  As a second example, if the first packet to\n   arrive happens to be CE-marked, the Data Receiver will have to\n   arbitrarily choose whether to precede the ECEB field with an EE0B \n   field or an EE1B field.  If it chooses, say, EEB0 but it turns out\n   never to receive ECT(0), it can start sending EE1B and ECEB instead -\n   it does not have to include the EE0B field if the r.e0b counter has\n   never changed during the connection.\n\n   With the recommended scheme, if the data sending direction switches\n   during a connection, there can be cases where the AccECN TCP Option\n   that is meant to feed back the counter values at the end of a volley\n   in one direction never reaches the other peer, due to packet loss.\n   ACE feedback ought to be sufficient to fill this gap, given accurate\n   feedback becomes moot after data transmission has paused. Appendix A.3 gives an example algorithm to estimate the number of\n   marked bytes from the ACE field alone, if AccECN Options are not\n   available.\n\n   If a host has determined that segments with AccECN Options always\n   seem to be discarded somewhere along the path, it is no longer\n   obliged to follow any of the rules in this section.",
                    "children": {}
                  }
                }
              }
            }
          },
          "3.3": {
            "title": "AccECN Compliance Requirements for TCP Proxies, Offload Engines",
            "content": "\n      and other Middleboxes    Given AccECN alters the TCP protocol on the wire, this section\n   specifies new requirements on certain networking equipment that\n   forwards TCP and inspects TCP header information.",
            "children": {
              "3.3.1": {
                "title": "Requirements for TCP Proxies",
                "content": "   A large class of middleboxes split TCP connections.  Such a middlebox\n   would be compliant with the AccECN protocol if the TCP implementation\n   on each side complied with the present AccECN specification and each\n   side negotiated AccECN independently of the other side.",
                "children": {}
              },
              "3.3.2": {
                "title": "Requirements for Transparent Middleboxes and TCP Normalizers",
                "content": "   Another large class of middleboxes intervenes to some degree at the\n   transport layer, but attempts to be transparent (invisible) to the\n   end-to-end connection.  A subset of this class of middleboxes\n   attempts to `normalize' the TCP wire protocol by checking that all\n   values in header fields comply with a rather narrow interpretation of\n   the TCP specifications that is also not always up to date.\n\n   A middlebox that is not normalizing the TCP protocol and does not\n   itself act as a back-to-back pair of TCP endpoints (i.e., a middlebox\n   that intends to be transparent or invisible at the transport layer)\n   ought to forward AccECN TCP Options unaltered, whether or not the\n   length value matches one of those specified in Section 3.2.3, and \n   whether or not the initial values of the byte-counter fields match\n   those in Section 3.2.1.  This is because blocking apparently invalid\n   values prevents the standardized set of values being extended in\n   future (such outdated normalizers would block updated hosts from\n   using the extended AccECN standard).\n\n   A TCP normalizer is likely to block or alter an AccECN TCP Option if\n   the length value or the initial values of its byte-counter fields do\n   not match one of those specified in Section 3.2.3 or Section 3.2.1.\n   However, to comply with the present AccECN specification, a middlebox\n   MUST NOT change the ACE field; or those fields of an AccECN Option\n   that are currently specified in Section 3.2.3; or any AccECN field\n   covered by integrity protection (e.g., [RFC5925]).",
                "children": {}
              },
              "3.3.3": {
                "title": "Requirements for TCP ACK Filtering",
                "content": "\n\n   Section 5.2.1 of BCP 69 [RFC3449] gives best current practice on\n   filtering (aka. thinning or coalescing) of pure TCP ACKs.  It advises\n   that filtering ACKs carrying ECN feedback ought to preserve the\n   correct operation of ECN feedback.  As the present specification\n   updates the operation of ECN feedback, this section discusses how an\n   ACK filter might preserve correct operation of AccECN feedback as\n   well.\n\n   The problem divides into two parts: determining if an ACK is part of\n   a connection that is using AccECN and then preserving the correct\n   operation of AccECN feedback:\n\n   *  To determine whether a pure TCP ACK is part of an AccECN\n      connection without resorting to connection tracking and per-flow\n      state, a useful heuristic would be to check for a non-zero ECN\n      field at the IP layer (because the ECN++ experiment only allows\n      TCP pure ACKs to be ECN-capable if AccECN has been negotiated\n      [I-D.ietf-tcpm-generalized-ecn ]).  This heuristic is simple and\n      stateless.  However, it might omit some AccECN ACKs, because\n      AccECN can be used without ECN++ and even if it is, ECN++ does not\n      have to make pure ACKs ECN-capable - only deployment experience\n      will tell.  Also, TCP ACKs might be ECN-capable owing to some\n      scheme other than AccECN, e.g., [RFC5690] or some future standards\n      action.  Again, only deployment experience will tell.\n\n   *  The main concern with preserving correct AccECN operation involves\n      leaving enough ACKs for the Data Sender to work out whether the\n      3-bit ACE field has wrapped.  In the worst case, in feedback about\n      a run of received packets that were all ECN-marked, the ACE field\n      will wrap every 8 acknowledged packets.  ACE field wrap might be\n      of less concern if packets also carry AccECN TCP Options.\n      However, note that logic to read an AccECN TCP Option is optional \n      to implement (albeit recommended \u2014 see Section 3.2.3).  So one end\n      writing an AccECN TCP Option into a packet does not necessarily\n      imply that the other end will read it.\n\n   Note that the present specification of AccECN in TCP does not presume\n   to rely on any of the above ACK filtering behaviour in the network,\n   because it has to be robust against pre-existing network nodes that\n   do not distinguish AccECN ACKs, and robust against ACK loss during\n   overload more generally.",
                "children": {}
              },
              "3.3.4": {
                "title": "Requirements for TCP Segmentation Offload and Large Receive",
                "content": "\n        Offload    Hardware to offload certain TCP processing represents another large\n   class of middleboxes (even though it is often a function of a host's\n   network interface and rarely in its own 'box').\n\n   Offloading can happen in the transmit path, usually referred to as\n   TCP Segmentation Offload (TSO), and the receive path where it is\n   called Large Receive Offload (LRO).\n\n   In the transmit direction, with AccECN, all segments created from the\n   same super-segment should retain the same ACE field, which should\n   make TSO straighforward.\n\n   However, with TSO hardware that supports [RFC3168], the CWR bit is\n   usually masked out on the middle and last segment.  If applied to an\n   AccECN segment, this would change the ACE field, and would be\n   interpreted as having received numerous CE marks in the receive\n   direction.  Therefore, currently available TSO hardware with\n   [RFC3168] support may need some minor driver changes, to adjust the\n   bitmask for the first, middle and last segment processed with TSO.\n\n   Initially, when Classic ECN [RFC3168] and Accurate ECN flows coexist\n   on the same offloading engine, the host software may need to work\n   around incompatibilities (e.g., when only global configurable TSO TCP\n   Flag bitmasks are available), otherwise this would cause some issues.\n\n   One way around this could be to only negotiate for Accurate ECN, but\n   not offer a fall back to [RFC3168] ECN.  Another way could be to\n   allow TSO only as long as the CWR flag in the TCP header is not set -\n   at the cost of more processing overhead while the ACE field has this\n   bit set.\n\n   For LRO in the receive direction, a different issue may get exposed\n   with [RFC3168] ECN supporting hardware. \n   The ACE field changes with every received CE marking, so today's\n   receive offloading could lead to many interrupts in high congestion\n   situations.  Although that would be useful (because congestion\n   information is received sooner), it could also significantly increase\n   processor load, particularly in scenarios such as DCTCP or L4S where\n   the marking rate is generally higher.\n\n   Current offload hardware ejects a segment from the coalescing process\n   whenever the TCP ECN flags change.  In data centres it has been\n   fortunate for this offload hardware that DCTCP-style feedback changes\n   less often when there are long sequences of CE marks, which is more\n   common with a step marking threshold (but less likely the more short\n   flows are in the mix).  The ACE counter approach has been designed so\n   that coalescing can continue over arbitrary patterns of marking and\n   only needs to stop when the counter wraps.  Nonetheless, until the\n   particular offload hardware in use implements this more efficient\n   approach, it is likely to be more efficient for AccECN connections to\n   implement this counter-style logic using software segmentation\n   offload.\n\n   ECN encodes a varying signal in the ACK stream, so it is inevitable\n   that offload hardware will ultimately need to handle any form of ECN\n   feedback exceptionally.  The ACE field has been designed as a counter\n   so that it is straightforward for offload hardware to pass on the\n   highest counter, and to push a segment from its cache before the\n   counter wraps.  The purpose of working towards standardized TCP ECN\n   feedback is to reduce the risk for hardware developers, who would\n   otherwise have to guess which scheme is likely to become dominant.\n\n   The above process has been designed to enable a continuing\n   incremental deployment path - to more highly dynamic congestion\n   control.  Once offload hardware supports AccECN, it will be able to\n   coalesce efficiently for any sequence of marks, instead of relying\n   for efficiency on the long marking sequences from step marking.  In\n   the next stage, marking can evolve from a step to a ramp function.\n   That in turn will allow host congestion control algorithms to respond\n   faster to dynamics, while being backwards compatible with existing\n   host algorithms.",
                "children": {}
              }
            }
          }
        }
      },
      "4": {
        "title": "Updates to RFC 3168",
        "content": "   This section clarifies which parts of RFC3168 are updated and maps\n   them to the sections of the present AccECN specification that update\n   them:\n\n   *  The whole of \"6.1.1 TCP Initialization\" of [RFC3168] is updated by Section 3.1 of the present specification. \n   *  In \"6.1.2.  The TCP Sender\" of [RFC3168], all mentions of a\n      congestion response to an ECN-Echo (ECE) ACK packet are updated by Section 3.2 of the present specification to mean an increment to\n      the sender's count of CE-marked packets, s.cep.  And the\n      requirements to set the CWR flag no longer apply, as specified in Section 3.1.5 of the present specification.  Otherwise, the\n      remaining requirements in \"6.1.2.  The TCP Sender\" still stand.\n\n      It will be noted that RFC 8311 already updates, or potentially\n      updates, a number of the requirements in \"6.1.2.  The TCP Sender\". Section 6.1.2 of RFC 3168 extended standard TCP congestion control\n      [RFC5681] to cover ECN marking as well as packet drop.  Whereas,RFC 8311 enables experimentation with alternative responses to ECN\n      marking, if specified for instance by an experimental RFC on the\n      IETF document stream.  RFC 8311 also strengthened the statement\n      that \"ECT(0) SHOULD be used\" to a \"MUST\" (see [RFC8311] for the\n      details).\n\n   *  The whole of \"6.1.3.  The TCP Receiver\" of [RFC3168] is updated by Section 3.2 of the present specification, with the exception of\n      the last paragraph (about congestion response to drop and ECN in\n      the same round trip), which still stands.  Incidentally, this last\n      paragraph is in the wrong section, because it relates to \"TCP\n      Sender\" behaviour.\n\n   *  The following text within \"6.1.5.  Retransmitted TCP packets\":\n\n         \"the TCP data receiver SHOULD ignore the ECN field on arriving\n         data packets that are outside of the receiver's current\n         window.\"\n\n      is updated by more stringent acceptability tests for any packet\n      (not just data packets) in the present specification.\n      Specifically, in the normative specification of AccECN (Section 3)\n      only 'Acceptable' packets contribute to the ECN counters at the\n      AccECN receiver and Section 1.3 defines an Acceptable packet as\n      one that passes acceptability tests equivalent in strength to\n      those in both [RFC9293] and [RFC5961].\n\n   *  Sections 5.2, 6.1.1, 6.1.4, 6.1.5 and 6.1.6 of [RFC3168] prohibit\n      use of ECN on TCP control packets and retransmissions.  The\n      present specification does not update that aspect of RFC 3168, but\n      it does say what feedback an AccECN Data Receiver ought to provide\n      if it receives an ECN-capable control packet or retransmission.\n      This ensures AccECN is forward compatible with any future scheme\n      that allows ECN on these packets, as provided for in section 4.3\n      of [RFC8311] and as proposed in [I-D.ietf-tcpm-generalized-ecn ]. \n\n\n\n",
        "children": {}
      },
      "5": {
        "title": "Interaction with TCP Variants",
        "content": "   This section is informative, not normative.",
        "children": {
          "5.1": {
            "title": "Compatibility with SYN Cookies",
            "content": "   A TCP Server can use SYN Cookies (see Appendix A of [RFC4987]) to\n   protect itself from SYN flooding attacks.  It places minimal commonly\n   used connection state in the SYN/ACK, and deliberately does not hold\n   any state while waiting for the subsequent ACK (e.g., it closes the\n   thread).  Therefore it cannot record the fact that it entered AccECN\n   mode for both half-connections.  Indeed, it cannot even remember\n   whether it negotiated the use of Classic ECN [RFC3168].\n\n   Nonetheless, such a Server can determine that it negotiated AccECN as\n   follows.  If a TCP Server using SYN Cookies supports AccECN and if it\n   receives a pure ACK that acknowledges an ISN that is a valid SYN\n   cookie, and if the ACK contains an ACE field with the value 0b010 to\n   0b111 (decimal 2 to 7), the Server can infer the first two stages of\n   the handshake:\n\n   *  the TCP Client has to have requested AccECN support on the SYN;\n\n   *  then, even though the Server kept no state, it has to have\n      confirmed that it supported AccECN.\n\n   Therefore the Server can switch itself into AccECN mode, and continue\n   as if it had never forgotten that it switched itself into AccECN mode\n   earlier.\n\n   If the pure ACK that acknowledges a SYN cookie contains an ACE field\n   with the value 0b000 or 0b001, these values indicate that the TCP\n   Client did not request support for AccECN and therefore the Server\n   does not enter AccECN mode for this connection.  Further, 0b001 on\n   the ACK implies that the Server sent an ECN-capable SYN/ACK, which\n   was marked CE in the network, and the non-AccECN TCP Client fed this\n   back by setting ECE on the ACK of the SYN/ACK.",
            "children": {}
          },
          "5.2": {
            "title": "Compatibility with TCP Experiments and Common TCP Options",
            "content": "   AccECN is compatible (at least on paper) with the most commonly used\n   TCP options: MSS, time-stamp, window scaling, SACK and TCP-AO.  It is\n   also compatible with Multipath TCP (MPTCP [RFC8684]) and the\n   experimental TCP option TCP Fast Open (TFO [RFC7413]).  AccECN is\n   friendly to all these protocols, because space for TCP options is\n   particularly scarce on the SYN, where AccECN consumes zero additional\n   header space. \n   When option space is under pressure from other options,Section 3.2.3.3 provides guidance on how important it is to send an\n   AccECN Option relative to other options, and which fields are more\n   important to include.\n\n   Implementers of TFO need to take careful note of the recommendation\n   in Section 3.2.2.1.  That section recommends that, if the TCP Client\n   has successfully negotiated AccECN, when acknowledging the SYN/ACK,\n   even if it has data to send, it sends a pure ACK immediately before\n   the data.  Then it can reflect the IP-ECN field of the SYN/ACK on\n   this pure ACK, which allows the Server to detect ECN mangling.  Note\n   that, as specified in Section 3.2, any data on the SYN (SYN=1, ACK=0)\n   is not included in any of the byte counters held locally for each ECN\n   marking, nor in the AccECN Option on the wire.\n\n   AccECN feedback is compatible with the ECN++\n   [I-D.ietf-tcpm-generalized-ecn ] experiment, which allows TCP control\n   packets and retransmissions to be ECN-capable ([RFC3168] was updated\n   by [RFC8311] to permit such experiments).  AccECN is likely to\n   inherently support any experiment with ECN-capable packets, because\n   it feeds back the contents of the ECN field mechanistically, without\n   judging whether a packet ought to use the ECN capability or not\n   (Section 2.5).  This specification does not discuss implementing\n   AccECN alongside [RFC5562], which was an earlier experimental\n   protocol with narrower scope than ECN++ and a 5-way handshake.",
            "children": {}
          },
          "5.3": {
            "title": "Compatibility with Feedback Integrity Mechanisms",
            "content": "   Three alternative mechanisms are available to assure the integrity of\n   ECN and/or loss signals.  AccECN is compatible with any of these\n   approaches:\n\n   *  The Data Sender can test the integrity of the receiver's ECN (or\n      loss) feedback by occasionally setting the IP-ECN field to a value\n      normally only set by the network (and/or deliberately leaving a\n      sequence number gap).  Then it can test whether the Data\n      Receiver's feedback faithfully reports what it expects (similar to\n      paragraph 2 of Section 20.2 of [RFC3168]).  Unlike the ECN Nonce\n      [RFC3540], this approach does not waste the ECT(1) codepoint in\n      the IP header, it does not require standardization and it does not\n      rely on misbehaving receivers volunteering to reveal feedback\n      information that allows them to be detected.  However, setting the\n      CE mark by the sender might conceal actual congestion feedback\n      from the network and therefore ought to only be done sparingly.\n\n   *  Networks generate congestion signals when they are becoming\n      congested, so networks are more likely than Data Senders to be\n      concerned about the integrity of the receiver's feedback of these \n      signals.  A network can enforce a congestion response to its ECN\n      markings (or packet losses) using congestion exposure (ConEx)\n      audit [RFC7713].  Whether the receiver or a downstream network is\n      suppressing congestion feedback or the sender is unresponsive to\n      the feedback, or both, ConEx audit can neutralize any advantage\n      that any of these three parties would otherwise gain.\n\n      ConEx is an experimental change to the Data Sender that would be\n      most useful when combined with AccECN.  Without AccECN, the ConEx\n      behaviour of a Data Sender would have to be more conservative than\n      would be necessary if it had the accurate feedback of AccECN.\n\n   *  The standards track TCP authentication option (TCP-AO [RFC5925])\n      can be used to detect any tampering with AccECN feedback between\n      the Data Receiver and the Data Sender (whether malicious or\n      accidental).  The AccECN fields are immutable end-to-end, so they\n      are amenable to TCP-AO protection, which covers TCP options by\n      default.  However, TCP-AO is often too brittle to use on many end-\n      to-end paths, where middleboxes can make verification fail in\n      their attempts to improve performance or security, e.g., Network\n      Address (and Port) Translation (NAT/NAPT), resegmentation or\n      shifting the sequence space.",
            "children": {}
          }
        }
      },
      "6": {
        "title": "Summary: Protocol Properties",
        "content": "   This section is informative not normative.  It describes how well the\n   protocol satisfies the agreed requirements for a more Accurate ECN\n   feedback protocol [RFC7560].\n\n   Accuracy:  From each ACK, the Data Sender can infer the number of new\n      CE marked segments since the previous ACK.  This provides better\n      accuracy on CE feedback than Classic ECN.  In addition if an\n      AccECN Option is present (not blocked by the network path) the\n      number of bytes marked with CE, ECT(1) and ECT(0) are provided.\n\n   Overhead:  The AccECN scheme is divided into two parts.  The\n      essential feedback part reuses the 3 flags already assigned to ECN\n      in the TCP header.  The supplementary feedback part adds an\n      additional TCP option consuming up to 11 bytes.  However, no TCP\n      option space is consumed in the SYN.\n\n   Ordering:  The order in which marks arrive at the Data Receiver is\n      preserved in AccECN feedback, because the Data Receiver is\n      expected to send an ACK immediately whenever a different mark\n      arrives.\n\n   Timeliness:  While the same ECN markings are arriving continually at \n      the Data Receiver, it can defer ACKs as TCP does normally, but it\n      will immediately send an ACK as soon as a different ECN marking\n      arrives.\n\n   Timeliness vs Overhead:  Change-Triggered ACKs are intended to enable\n      latency-sensitive uses of ECN feedback by capturing the timing of\n      transitions but not wasting resources while the state of the\n      signalling system is stable.  Within the constraints of the\n      change-triggered ACK rules, the receiver can control how\n      frequently it sends AccECN TCP Options and therefore to some\n      extent it can control the overhead induced by AccECN.\n\n   Resilience:  All information is provided based on counters.\n      Therefore if ACKs are lost, the counters on the first ACK\n      following the losses allows the Data Sender to immediately recover\n      the number of the ECN markings that it missed.  And if data or\n      ACKs are reordered, stale congestion information can be identified\n      and ignored.\n\n   Resilience against Bias:  Because feedback is based on repetition of\n      counters, random losses do not remove any information, they only\n      delay it.  Therefore, even though some ACKs are change-triggered,\n      random losses will not alter the proportions of the different ECN\n      markings in the feedback.\n\n   Resilience vs Overhead:  If space is limited in some segments\n      (e.g., because more options are needed on some segments, such as\n      the SACK option after loss), the Data Receiver can send AccECN\n      Options less frequently or truncate fields that have not changed,\n      usually down to as little as 5 bytes.\n\n   Resilience vs Timeliness and Ordering:  Ordering information and the\n      timing of transitions cannot be communicated in three cases: i)\n      during ACK loss; ii) if something on the path strips AccECN\n      Options; or iii) if the Data Receiver is unable to support Change-\n      Triggered ACKs.  Following ACK reordering, the Data Sender can\n      reconstruct the order in which feedback was sent, but not until\n      all the missing feedback has arrived.\n\n   Complexity:  An AccECN implementation solely involves simple counter\n      increments, some modulo arithmetic to communicate the least\n      significant bits and allow for wrap, and some heuristics for\n      safety against fields cycling due to prolonged periods of ACK\n      loss.  Each host needs to maintain eight additional counters.  The\n      hosts have to apply some additional tests to detect tampering by\n      middleboxes, but in general the protocol is simple to understand,\n      simple to implement and requires few cycles per packet to execute. \n   Integrity:  AccECN is compatible with at least three approaches that\n      can assure the integrity of ECN feedback.  If AccECN Options are\n      stripped the resolution of the feedback is degraded, but the\n      integrity of this degraded feedback can still be assured.\n\n   Backward Compatibility:  If only one endpoint supports the AccECN\n      scheme, it will fall-back to the most advanced ECN feedback scheme\n      supported by the other end.\n\n      If AccECN Options are stripped by a middlebox, AccECN still\n      provides basic congestion feedback in the ACE field.  Further,\n      AccECN can be used to detect mangling of the IP ECN field;\n      mangling of the TCP ECN flags; blocking of ECT-marked segments;\n      and blocking of segments carrying an AccECN Option.  It can detect\n      these conditions during TCP's three-way handshake so that it can\n      fall back to operation without ECN and/or operation without AccECN\n      Options.\n\n   Forward Compatibility:  The behaviour of endpoints and middleboxes is\n      carefully defined for all reserved or currently unused codepoints\n      in the scheme.  Then, the designers of security devices can\n      understand which currently unused values might appear in future.\n      So, even if they choose to treat such values as anomalous while\n      they are not widely used, any blocking will at least be under\n      policy control not hard-coded.  Then, if previously unused values\n      start to appear on the Internet (or in standards), such policies\n      could be quickly reversed.",
        "children": {}
      },
      "7": {
        "title": "IANA Considerations",
        "content": "   This document reassigns the TCP header flag at bit offset 7 to the\n   AccECN protocol.  This bit was previously called the Nonce Sum (NS)\n   flag [RFC3540], but RFC 3540 has been reclassified as historic\n   [RFC8311].  The flag will now be defined as the following in the \"TCP\n   Header Flags\" registry in the \"Transmission Control Protocol (TCP)\n   Parameters\" registry group:\n\n     +=====+==============+===========+==============================+\n     | Bit | Name         | Reference | Assignment Notes             |\n     +=====+==============+===========+==============================+\n     | 7   | AE (Accurate | RFC XXXX  | Previously used as NS (Nonce |\n     |     | ECN)         |           | Sum) by [RFC3540], which is  |\n     |     |              |           | now historic [RFC8311]       |\n     +-----+--------------+-----------+------------------------------+\n\n                   Table 6: TCP header flag reassignment \n   [TO BE REMOVED: IANA is requested to update the existing entry in the\n   TCP Header Flags registry (https://www.iana.org/assignments/tcp-\n   parameters/tcp-parameters.xhtml#tcp-header-flags ) for Bit 7 to \"AE\n   (Accurate ECN)\" and to change the reference to this RFC-to-be instead\n   of RFC8311.  Also IANA is requested to change the assignment note to\n   \"Previously used as NS (Nonce Sum) by [RFC3540], which is now\n   historic [RFC8311].\"]\n\n   This document also defines two new TCP options for AccECN, assigned\n   values of 172 and 174 (decimal) from the TCP option space.  These\n   values are defined as the following in the \"TCP Option Kind Numbers\"\n   registry in the \"Transmission Control Protocol (TCP) Parameters\"\n   registry group:\n\n      +======+========+================================+===========+\n      | Kind | Length | Meaning                        | Reference |\n      +======+========+================================+===========+\n      | 172  | N      | Accurate ECN Order 0 (AccECN0) | RFC XXXX  |\n      +------+--------+--------------------------------+-----------+\n      | 174  | N      | Accurate ECN Order 1 (AccECN1) | RFC XXXX  |\n      +------+--------+--------------------------------+-----------+\n\n                   Table 7: New TCP Option assignments\n\n   [TO BE REMOVED: These registrations have taken place using the early\n   registration procedure, which may be temporary if this draft does not\n   proceed, at the following location: http://www.iana.org/assignments/\n   tcp-parameters/tcp-parameters.xhtml#tcp-parameters-1 ]\n\n   Early experimental implementations of the two AccECN Options used\n   experimental option 254 per [RFC6994] with the 16-bit magic numbers\n   0xACC0 and 0xACC1 respectively for Order 0 and 1, as allocated in the\n   IANA \"TCP Experimental Option Experiment Identifiers (TCP ExIDs)\"\n   registry.  Even earlier experimental implementations used the single\n   magic number 0xACCE (16 bits).  Uses of these experimental options\n   SHOULD migrate to use the new option kinds (172 & 174).\n\n   [TO BE REMOVED: IANA is requested to replace the references for all\n   three of the above experimental options (0xACC0, 0xACC1 and 0xACCE)\n   with a reference to the present RFC XXXX.]\n\n   [TO BE REMOVED: If the early registrations, which may be temporary,\n   do not proceed, the three references to them in the TCP ExIDs\n   registry at the following location will also need to be edited out:https://www.iana.org/assignments/tcp-parameters/tcp-\n   parameters.xhtml#tcp-exids  ]\n\n\n\n",
        "children": {}
      },
      "8": {
        "title": "Security and Privacy Considerations",
        "content": "   If ever the supplementary feedback part of AccECN based on one of the\n   new AccECN TCP Options is unusable (due for example to middlebox\n   interference) the essential feedback part of AccECN's congestion\n   feedback offers only limited resilience to long runs of ACK loss (see Section 3.2.2.5).  These problems are unlikely to be due to malicious\n   intervention (because if an attacker could strip a TCP option or\n   discard a long run of ACKs it could wreak other arbitrary havoc).\n   However, it would be of concern if AccECN's resilience could be\n   indirectly compromised during a flooding attack.  AccECN is still\n   considered safe though, because if AccECN Options are not present,\n   the AccECN Data Sender is then required to switch to more\n   conservative assumptions about wrap of congestion indication counters\n   (see Section 3.2.2.5 and Appendix A.2). Section 5.1 describes how a TCP Server can negotiate AccECN and use\n   the SYN cookie method for mitigating SYN flooding attacks.\n\n   There is concern that ECN feedback could be altered or suppressed,\n   particularly because a misbehaving Data Receiver could increase its\n   own throughput at the expense of others.  AccECN is compatible with\n   the three schemes known to assure the integrity of ECN feedback (see Section 5.3 for details).  If AccECN Options are stripped by an\n   incorrectly implemented middlebox, the resolution of the feedback\n   will be degraded, but the integrity of this degraded information can\n   still be assured.  Assuring that Data Senders respond appropriately\n   to ECN feedback is possible, but the scope of the present document is\n   confined to the feedback protocol, and excludes the response to this\n   feedback.\n\n   In Section 3.2.3 a Data Sender is allowed to ignore an unrecognized\n   TCP AccECN Option length and read as many whole 3-octet fields from\n   it as possible up to a maximum of 3, treating the remainder as\n   padding.  This opens up a potential covert channel of up to 29B (40 -\n   (2+3*3)) B.  However, it is really an overt channel (not hidden) and\n   it is no different to the use of unknown TCP options with unknown\n   option lengths in general.  Therefore, where this is of concern, it\n   can already be adequately mitigated by regular TCP normalizer\n   technology (see Section 3.3.2).\n\n   The AccECN protocol is not believed to introduce any new privacy\n   concerns, because it merely counts and feeds back signals at the\n   transport layer that had already been visible at the IP layer.  A\n   covert channel can be used to compromise privacy.  However, as\n   explained above, undefined TCP options in general open up such\n   channels and common techniques are available to close them off. \n   There is a potential concern that a Data Receiver could deliberately\n   omit AccECN Options pretending that they had been stripped by a\n   middlebox.  No known way can yet be contrived for a receiver to take\n   advantage of this behaviour, which seems to always degrade its own\n   performance.  However, the concern is mentioned here for\n   completeness.\n\n   A generic privacy concern of any new protocol is that for a while it\n   will be used by a small population of hosts, and thus show up more\n   easily.  However, it is expected that this option will become\n   available in operating systems over time, and eventually turned on by\n   default in them.  Thus a individual identification of a particular\n   user is less of a concern than the fingerprinting of specific\n   versions of operation systems.  However, the latter can be done using\n   different means independent of Accurate ECN.\n\n   As Accurate ECN exposes more bits in the TCP header which could be\n   tampered with without interfering with the transport excessively, it\n   may allow an additional way to identify specific data streams across\n   a virtual private network (VPN) to an attacker which has access to\n   the datastream before and after the VPN tunnel endpoints.  This may\n   be achieved by injecting or modifying the ACE field in specific\n   patters that can be recognized.\n\n   Overall, Accurate ECN does not change the risk profile on privacy to\n   a user dramatically beyond what is already possible using classic\n   ECN.  However, in order to prevent such attacks and means of easier\n   identification of flows, it is adviseable for privacy conscious users\n   behind VPNs to not enable the Accurate ECN, or Classic ECN for that\n   matter.",
        "children": {}
      },
      "A": {
        "title": "Example Algorithms",
        "content": "   This appendix is informative, not normative.  It gives example\n   algorithms that would satisfy the normative requirements of the\n   AccECN protocol.  However, implementers are free to choose other ways\n   to implement the requirements.",
        "children": {
          "A.1": {
            "title": "Example Algorithm to Encode/Decode the AccECN Option",
            "content": "   The example algorithms below show how a Data Receiver in AccECN mode\n   could encode its CE byte counter r.ceb into the ECEB field within an\n   AccECN TCP Option, and how a Data Sender in AccECN mode could decode\n   the ECEB field into its byte counter s.ceb.  The other counters for\n   bytes marked ECT(0) and ECT(1) in an AccECN Option would be similarly\n   encoded and decoded.\n\n   It is assumed that each local byte counter is an unsigned integer\n   greater than 24b (probably 32b), and that the following constant has\n   been assigned:\n\n      DIVOPT = 2^24\n\n   Every time a CE marked data segment arrives, the Data Receiver\n   increments its local value of r.ceb by the size of the TCP Data.\n   Whenever it sends an ACK with an AccECN Option, the value it writes\n   into the ECEB field is\n\n      ECEB = r.ceb % DIVOPT \n   where '%' is the remainder operator.\n\n   On the arrival of an AccECN Option, the Data Sender first makes sure\n   the ACK has not been superseded in order to avoid winding the s.ceb\n   counter backwards.  It uses the TCP acknowledgement number and any\n   SACK options [RFC2018] to calculate newlyAckedB, the amount of new\n   data that the ACK acknowledges in bytes (newlyAckedB can be zero but\n   not negative).  If newlyAckedB is zero, either the ACK has been\n   superseded or CE-marked packet(s) without data could have arrived.\n   To break the tie for the latter case, the Data Sender could use time-\n   stamps [RFC7323] (if present) to work out newlyAckedT, the amount of\n   new time that the ACK acknowledges.  If the Data Sender determines\n   that the ACK has been superseded it ignores the AccECN Option.\n   Otherwise, the Data Sender calculates the minimum non-negative\n   difference d.ceb between the ECEB field and its local s.ceb counter,\n   using modulo arithmetic as follows:\n\n      if ((newlyAckedB > 0) || (newlyAckedT > 0)) {\n          d.ceb = (ECEB + DIVOPT - (s.ceb % DIVOPT)) % DIVOPT\n          s.ceb += d.ceb\n      }\n\n   For example, if s.ceb is 33,554,433 and ECEB is 1461 (both decimal),\n   then\n\n      s.ceb % DIVOPT = 1\n      d.ceb = (1461 + 2^24 - 1) % 2^24\n            = 1460\n      s.ceb = 33,554,433 + 1460\n            = 33,555,893\n\n   In practice an implementation might use heuristics to guess the\n   feedback in missing ACKs, then when it subsequently receives feedback\n   it might find that it needs to correct its earlier heuristics as part\n   of the decoding process.  The above decoding process does not include\n   any such heuristics.",
            "children": {}
          },
          "A.2": {
            "title": "Example Algorithm for Safety Against Long Sequences of ACK Loss",
            "content": "   The example algorithms below show how a Data Receiver in AccECN mode\n   could encode its CE packet counter r.cep into the ACE field, and how\n   the Data Sender in AccECN mode could decode the ACE field into its\n   s.cep counter.  The Data Sender's algorithm includes code to\n   heuristically detect a long enough unbroken string of ACK losses that\n   could have concealed a cycle of the congestion counter in the ACE\n   field of the next ACK to arrive. \n   Two variants of the algorithm are given: i) a more conservative\n   variant for a Data Sender to use if it detects that AccECN Options\n   are not available (see Section 3.2.2.5 and Section 3.2.3.2); and ii)\n   a less conservative variant that is feasible when complementary\n   information is available from AccECN Options.",
            "children": {
              "A.2.1": {
                "title": "Safety Algorithm without the AccECN Option",
                "content": "   It is assumed that each local packet counter is a sufficiently sized\n   unsigned integer (probably 32b) and that the following constant has\n   been assigned:\n\n      DIVACE = 2^3\n\n   Every time an Acceptable CE marked packet arrives (Section 3.2.2.2),\n   the Data Receiver increments its local value of r.cep by 1.  It\n   repeats the same value of ACE in every subsequent ACK until the next\n   CE marking arrives, where\n\n      ACE = r.cep % DIVACE.\n\n   If the Data Sender received an earlier value of the counter that had\n   been delayed due to ACK reordering, it might incorrectly calculate\n   that the ACE field had wrapped.  Therefore, on the arrival of every\n   ACK, the Data Sender ensures the ACK has not been superseded using\n   the TCP acknowledgement number, any SACK options and timestamps (if\n   available) to calculate newlyAckedB, as in Appendix A.1.  If the ACK\n   has not been superseded, the Data Sender calculates the minimum\n   difference d.cep between the ACE field and its local s.cep counter,\n   using modulo arithmetic as follows:\n\n      if ((newlyAckedB > 0) || (newlyAckedT > 0))\n          d.cep = (ACE + DIVACE - (s.cep % DIVACE)) % DIVACE Section 3.2.2.5 expects the Data Sender to assume that the ACE field\n   cycled if it is the safest likely case under prevailing conditions.\n   The 3-bit ACE field in an arriving ACK could have cycled and become\n   ambiguous to the Data Sender if a sequence of ACKs goes missing that\n   covers a stream of data long enough to contain 8 or more CE marks.\n   We use the word `missing' rather than `lost', because some or all the\n   missing ACKs might arrive eventually, but out of order.  Even if some\n   of the missing ACKs were piggy-backed on data (i.e., not pure ACKs)\n   retransmissions will not repair the lost AccECN information, because\n   AccECN requires retransmissions to carry the latest AccECN counters,\n   not the original ones. \n   The phrase `under prevailing conditions' allows for implementation-\n   dependent interpretation.  A Data Sender might take account of the\n   prevailing size of data segments and the prevailing CE marking rate\n   just before the sequence of missing ACKs.  However, we shall start\n   with the simplest algorithm, which assumes segments are all full-\n   sized and ultra-conservatively it assumes that ECN marking was 100%\n   on the forward path when ACKs on the reverse path started to all be\n   dropped.  Specifically, if newlyAckedB is the amount of data that an\n   ACK acknowledges since the previous ACK, then the Data Sender could\n   assume that this acknowledges newlyAckedPkt full-sized segments,\n   where newlyAckedPkt = newlyAckedB/MSS.  Then it could assume that the\n   ACE field incremented by\n\n       dSafer.cep = newlyAckedPkt - ((newlyAckedPkt - d.cep) % DIVACE),\n\n   For example, imagine an ACK acknowledges newlyAckedPkt=9 more full-\n   size segments than any previous ACK, and that ACE increments by a\n   minimum of 2 CE marks (d.cep=2).  The above formula works out that it\n   would still be safe to assume 2 CE marks (because 9 - ((9-2) % 8) =\n   2).  However, if ACE increases by a minimum of 2 but acknowledges 10\n   full-sized segments, then it would be necessary to assume that there\n   could have been 10 CE marks (because 10 - ((10-2) % 8) = 10).\n\n   Note that checks would need to be added to the above pseudocode for\n   (d.cep > newlyAckedPkt), which could occur if newlyAckedPkt had been\n   wrongly estimated using an inappropriate packet size.\n\n   ACKs that acknowledge a large stretch of packets might be common in\n   data centres to achieve a high packet rate or might be due to ACK\n   thinning by a middlebox.  In these cases, cycling of the ACE field\n   would often appear to have been possible, so the above algorithm\n   would be over-conservative, leading to a false high marking rate and\n   poor performance.  Therefore it would be reasonable to only use\n   dSafer.cep rather than d.cep if the moving average of newlyAckedPkt\n   was well below 8.\n\n   Implementers could build in more heuristics to estimate prevailing\n   average segment size and prevailing ECN marking.  For instance,\n   newlyAckedPkt in the above formula could be replaced with\n   newlyAckedPktHeur = newlyAckedPkt*p*MSS/s, where s is the prevailing\n   segment size and p is the prevailing ECN marking probability.\n   However, ultimately, if TCP's ECN feedback becomes inaccurate it\n   still has loss detection to fall back on.  Therefore, it would seem\n   safe to implement a simple algorithm, rather than a perfect one. \n   The simple algorithm for dSafer.cep above requires no monitoring of\n   prevailing conditions and it would still be safe if, for example,\n   segments were on average at least 5% of full-sized as long as ECN\n   marking was 5% or less.  Assuming it was used, the Data Sender would\n   increment its packet counter as follows:\n\n      s.cep += dSafer.cep\n\n   If missing acknowledgement numbers arrive later (due to reordering),Section 3.2.2.5 says \"the Data Sender MAY attempt to neutralize the\n   effect of any action it took based on a conservative assumption that\n   it later found to be incorrect\".  To do this, the Data Sender would\n   have to store the values of all the relevant variables whenever it\n   made assumptions, so that it could re-evaluate them later.  Given\n   this could become complex and it is not required, we do not attempt\n   to provide an example of how to do this.",
                "children": {}
              },
              "A.2.2": {
                "title": "Safety Algorithm with the AccECN Option",
                "content": "   When AccECN Options are available on the ACKs before and after the\n   possible sequence of ACK losses, if the Data Sender only needs CE-\n   marked bytes, it will have sufficient information in AccECN Options\n   without needing to process the ACE field.  If for some reason it\n   needs CE-marked packets, if dSafer.cep is different from d.cep, it\n   can determine whether d.cep is likely to be a safe enough estimate by\n   checking whether the average marked segment size (s = d.ceb/d.cep) is\n   less than the MSS (where d.ceb is the amount of newly CE-marked bytes\n   - see Appendix A.1).  Specifically, it could use the following\n   algorithm:\n\n      SAFETY_FACTOR = 2\n      if (dSafer.cep > d.cep) {\n          if (d.ceb <= MSS * d.cep) {  % Same as (s <= MSS), but no DBZ\n             sSafer = d.ceb/dSafer.cep\n             if (sSafer < MSS/SAFETY_FACTOR)\n                 dSafer.cep = d.cep    % d.cep is a safe enough estimate\n          } % else\n              % No need for else; dSafer.cep is already correct,\n              % because d.cep must have been too small\n      }\n\n   The chart below shows when the above algorithm will consider d.cep\n   can replace dSafer.cep as a safe enough estimate of the number of CE-\n   marked packets:\n                    ^\n              sSafer|\n                    |\n                 MSS+\n                    |\n                    |         dSafer.cep\n                    |                  is\n   MSS/SAFETY_FACTOR+--------------+    safest\n                    |              |\n                    | d.cep is safe|\n                    |    enough    |\n                    +-------------------->\n                                  MSS     s\n\n   The following examples give the reasoning behind the algorithm,\n   assuming MSS=1460 :\n\n   *  if d.cep=0, dSafer.cep=8 and d.ceb=1460, then s=infinity and\n      sSafer=182.5.\n\n      Therefore even though the average size of 8 data segments is\n      unlikely to have been as small as MSS/8, d.cep cannot have been\n      correct, because it would imply an average segment size greater\n      than the MSS.\n\n   *  if d.cep=2, dSafer.cep=10 and d.ceb=1460, then s=730 and\n      sSafer=146.\n\n      Therefore d.cep is safe enough, because the average size of 10\n      data segments is unlikely to have been as small as MSS/10.\n\n   *  if d.cep=7, dSafer.cep=15 and d.ceb=10200, then s=1457 and\n      sSafer=680.\n\n      Therefore d.cep is safe enough, because the average data segment\n      size is more likely to have been just less than one MSS, rather\n      than below MSS/2.\n\n   If pure ACKs were allowed to be ECN-capable, missing ACKs would be\n   far less likely.  However, because [RFC3168] currently precludes\n   this, the above algorithm assumes that pure ACKs are not ECN-capable. \n\n\n\n",
                "children": {}
              }
            }
          },
          "A.3": {
            "title": "Example Algorithm to Estimate Marked Bytes from Marked Packets",
            "content": "   If AccECN Options are not available, the Data Sender can only decode\n   CE-marking from the ACE field in packets.  Every time an ACK arrives,\n   to convert this into an estimate of CE-marked bytes, it needs an\n   average of the segment size, s_ave.  Then it can add or subtract\n   s_ave from the value of d.ceb as the value of d.cep increments or\n   decrements.  Some possible ways to calculate s_ave are outlined\n   below.  The precise details will depend on why an estimate of marked\n   bytes is needed.\n\n   The implementation could keep a record of the byte numbers of all the\n   boundaries between packets in flight (including control packets), and\n   recalculate s_ave on every ACK.  However it would be simpler to\n   merely maintain a counter packets_in_flight for the number of packets\n   in flight (including control packets), which is reset once per RTT.\n   Either way, it would estimate s_ave as:\n\n      s_ave ~= flightsize / packets_in_flight,\n\n   where flightsize is the variable that TCP already maintains for the\n   number of bytes in flight and '~=' means 'approximately equal to'.\n   To avoid floating point arithmetic, it could right-bit-shift by\n   lg(packets_in_flight), where lg() means log base 2.\n\n   An alternative would be to maintain an exponentially weighted moving\n   average (EWMA) of the segment size:\n\n      s_ave = a * s + (1-a) * s_ave,\n\n   where a is the decay constant for the EWMA.  However, then it is\n   necessary to choose a good value for this constant, which ought to\n   depend on the number of packets in flight.  Also the decay constant\n   needs to be power of two to avoid floating point arithmetic.",
            "children": {}
          },
          "A.4": {
            "title": "Example Algorithm to Count Not-ECT Bytes",
            "content": "   A Data Sender in AccECN mode can infer the amount of TCP payload data\n   arriving at the receiver marked Not-ECT from the difference between\n   the amount of newly ACKed data and the sum of the bytes with the\n   other three markings, d.ceb, d.e0b and d.e1b.\n\n   For this approach to be precise, it has to be assumed that spurious\n   (unnecessary) retransmissions do not lead to double counting.  This\n   assumption is currently correct, given that RFC 3168 requires that\n   the Data Sender marks retransmitted segments as Not-ECT.  However,\n   the converse is not true; necessary retransmissions will result in\n   under-counting. \n   However, such precision is unlikely to be necessary.  The only known\n   use of a count of Not-ECT marked bytes is to test whether equipment\n   on the path is clearing the ECN field (perhaps due to an out-dated\n   attempt to clear, or bleach, what used to be the IPv4 ToS byte or the\n   IPv6 Traffic Class field).  To detect bleaching it will be sufficient\n   to detect whether nearly all bytes arrive marked as Not-ECT.\n   Therefore there ought to be no need to keep track of the details of\n   retransmissions.",
            "children": {}
          }
        }
      },
      "B": {
        "title": "Rationale for Usage of TCP Header Flags",
        "content": "\n\n",
        "children": {
          "B.1": {
            "title": "Three TCP Header Flags in the SYN-SYN/ACK Handshake",
            "content": "   AccECN uses a rather unorthodox approach to negotiate the highest\n   version TCP ECN feedback scheme that both ends support, as justified\n   below.  It follows from the original TCP ECN capability negotiation\n   [RFC3168], in which the Client set the 2 least significant of the\n   original reserved flags in the TCP header, and fell back to no ECN\n   support if the Server responded with the 2 flags cleared, which had\n   previously been the default.\n\n   Classic ECN used header flags rather than a TCP option because it was\n   considered more efficient to use a header flag for 1 bit of feedback\n   per ACK, and this bit could be overloaded to indicate support for\n   Classic ECN during the handshake.  During the development of ECN, 1\n   bit crept up to 2, in order to deliver the feedback reliably and to\n   work round some broken hosts that reflected the reserved flags during\n   the handshake.\n\n   In order to be backward compatible with RFC 3168, AccECN continues\n   this approach, using the 3rd least significant TCP header flag that\n   had previously been allocated for the ECN nonce (now historic).\n   Then, whatever form of Server an AccECN Client encounters, the\n   connection can fall back to the highest version of feedback protocol\n   that both ends support, as explained in Section 3.1.\n\n   If AccECN capability negotiation had used the more orthodox approach\n   of a TCP option, it would still have had to set the two ECN flags in\n   the main TCP header, in order to be able to fall back to Classic RFC \n   3168 ECN, or to disable ECN support, without another round of\n   negotiation.  Then AccECN would also have had to handle all the\n   different ways that Servers currently respond to settings of the ECN\n   flags in the main TCP header, including all the conflicting cases\n   where a Server might have said it supported one approach in the flags\n   and another approach in a new TCP option.  And AccECN would have had\n   to deal with all the additional possibilities where a middlebox might\n   have mangled the ECN flags, or removed TCP options.  Thus, usage of\n   the 3rd reserved TCP header flag simplified the protocol. \n   The third flag was used in a way that could be distinguished from the\n   ECN nonce, in case any nonce deployment was encountered.  Previous\n   usage of this flag for the ECN nonce was integrated into the original\n   ECN negotiation.  This further justified the 3rd flag's use for\n   AccECN, because a non-ECN usage of this flag would have had to use it\n   as a separate single bit, rather than in combination with the other 2\n   ECN flags.\n\n   Indeed, having overloaded the original uses of these three flags for\n   its handshake, AccECN overloads all three bits again as a 3-bit\n   counter.",
            "children": {},
            "decomposed_content": [
              {
                "text": "   AccECN uses a rather unorthodox approach to negotiate the highest\n   version TCP ECN feedback scheme that both ends support, as justified\n   below.  It follows from the original TCP ECN capability negotiation\n   [RFC3168], in which the Client set the 2 least significant of the\n   original reserved flags in the TCP header, and fell back to no ECN\n   support if the Server responded with the 2 flags cleared, which had\n   previously been the default.",
                "references": [
                  {
                    "rfc_number": "RFC3168",
                    "section_id": "6.1"
                  }
                ],
                "external_references": []
              },
              {
                "text": "   Classic ECN used header flags rather than a TCP option because it was\n   considered more efficient to use a header flag for 1 bit of feedback\n   per ACK, and this bit could be overloaded to indicate support for\n   Classic ECN during the handshake.  During the development of ECN, 1\n   bit crept up to 2, in order to deliver the feedback reliably and to\n   work round some broken hosts that reflected the reserved flags during\n   the handshake.",
                "references": [],
                "external_references": []
              },
              {
                "text": "   In order to be backward compatible with RFC 3168, AccECN continues\n   this approach, using the 3rd least significant TCP header flag that\n   had previously been allocated for the ECN nonce (now historic).\n   Then, whatever form of Server an AccECN Client encounters, the\n   connection can fall back to the highest version of feedback protocol\n   that both ends support, as explained in Section 3.1.",
                "references": [
                  {
                    "rfc_number": "RFC3168",
                    "section_id": "23.1"
                  }
                ],
                "external_references": []
              },
              {
                "text": "   If AccECN capability negotiation had used the more orthodox approach\n   of a TCP option, it would still have had to set the two ECN flags in\n   the main TCP header, in order to be able to fall back to Classic RFC \n   3168 ECN, or to disable ECN support, without another round of\n   negotiation.  Then AccECN would also have had to handle all the\n   different ways that Servers currently respond to settings of the ECN\n   flags in the main TCP header, including all the conflicting cases\n   where a Server might have said it supported one approach in the flags\n   and another approach in a new TCP option.  And AccECN would have had\n   to deal with all the additional possibilities where a middlebox might\n   have mangled the ECN flags, or removed TCP options.  Thus, usage of\n   the 3rd reserved TCP header flag simplified the protocol. \n   The third flag was used in a way that could be distinguished from the\n   ECN nonce, in case any nonce deployment was encountered.  Previous\n   usage of this flag for the ECN nonce was integrated into the original\n   ECN negotiation.  This further justified the 3rd flag's use for\n   AccECN, because a non-ECN usage of this flag would have had to use it\n   as a separate single bit, rather than in combination with the other 2\n   ECN flags.",
                "references": [
                  {
                    "rfc_number": "RFC3168",
                    "section_id": "3"
                  }
                ],
                "external_references": []
              },
              {
                "text": "   Indeed, having overloaded the original uses of these three flags for\n   its handshake, AccECN overloads all three bits again as a 3-bit\n   counter.",
                "references": [],
                "external_references": []
              }
            ]
          },
          "B.2": {
            "title": "Four Codepoints in the SYN/ACK",
            "content": "   Of the 8 possible codepoints that the 3 TCP header flags can indicate\n   on the SYN/ACK, 4 already indicated earlier (or broken) versions of\n   ECN support, 1 now being historic.  In the early design of AccECN, an\n   AccECN Server could use only 2 of the 4 remaining codepoints.  They\n   both indicated AccECN support, but one fed back that the SYN had\n   arrived marked as CE.  Even though ECN support on a SYN is not yet on\n   the standards track, the idea is for either end to act as a\n   mechanistic reflector, so that future capabilities can be\n   unilaterally deployed without requiring 2-ended deployment (justified\n   in Section 2.5).\n\n   During traversal testing it was discovered that the IP-ECN field in\n   the SYN was mangled on a non-negligible proportion of paths.\n   Therefore it was necessary to allow the SYN/ACK to feed all four IP-\n   ECN codepoints that the SYN could arrive with back to the Client.\n   Without this, the Client could not know whether to disable ECN for\n   the connection due to mangling of the IP-ECN field (also explained in Section 2.5).  This development consumed the remaining 2 codepoints\n   on the SYN/ACK that had been reserved for future use by AccECN in\n   earlier versions.",
            "children": {},
            "decomposed_content": [
              {
                "text": "   Of the 8 possible codepoints that the 3 TCP header flags can indicate\n   on the SYN/ACK, 4 already indicated earlier (or broken) versions of\n   ECN support, 1 now being historic.  In the early design of AccECN, an\n   AccECN Server could use only 2 of the 4 remaining codepoints.  They\n   both indicated AccECN support, but one fed back that the SYN had\n   arrived marked as CE.  Even though ECN support on a SYN is not yet on\n   the standards track, the idea is for either end to act as a\n   mechanistic reflector, so that future capabilities can be\n   unilaterally deployed without requiring 2-ended deployment (justified\n   in Section 2.5).",
                "references": [
                  {
                    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
                    "section_id": "2.5"
                  }
                ],
                "external_references": []
              },
              {
                "text": "   During traversal testing it was discovered that the IP-ECN field in\n   the SYN was mangled on a non-negligible proportion of paths.\n   Therefore it was necessary to allow the SYN/ACK to feed all four IP-\n   ECN codepoints that the SYN could arrive with back to the Client.\n   Without this, the Client could not know whether to disable ECN for\n   the connection due to mangling of the IP-ECN field (also explained in Section 2.5).  This development consumed the remaining 2 codepoints\n   on the SYN/ACK that had been reserved for future use by AccECN in\n   earlier versions.",
                "references": [
                  {
                    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
                    "section_id": "2.5"
                  }
                ],
                "external_references": []
              }
            ]
          },
          "B.3": {
            "title": "Space for Future Evolution",
            "content": "   Despite availability of usable TCP header space being extremely\n   scarce, the AccECN protocol has taken all possible steps to ensure\n   that there is space to negotiate possible future variants of the\n   protocol, either if a variant of AccECN is required, or if a\n   completely different ECN feedback approach is needed:\n\n   Future AccECN variants:  When the AccECN capability is negotiated\n      during TCP's three-way handshake, the rows in Table 2 tagged as\n      'Nonce' and 'Broken' in the column for the capability of node B\n      are unused by any current protocol in the RFC series.  These could\n      be used by TCP Servers in future to indicate a variant of the \n      AccECN protocol.  In recent measurement studies in which the\n      response of large numbers of Servers to an AccECN SYN has been\n      tested, e.g., [Mandalari18], a very small number of SYN/ACKs\n      arrive with the pattern tagged as 'Nonce', and a small but more\n      significant number arrive with the pattern tagged as 'Broken'.\n      The 'Nonce' pattern could be a sign that a few Servers have\n      implemented the ECN Nonce [RFC3540], which has now been\n      reclassified as historic [RFC8311], or it could be the random\n      result of some unknown middlebox behaviour.  The greater\n      prevalence of the 'Broken' pattern suggests that some instances\n      still exist of the broken code that reflects the reserved flags on\n      the SYN.\n\n      The requirement not to reject unexpected initial values of the ACE\n      counter (in the main TCP header) in the last paragraph of Section 3.2.2.4 ensures that 3 unused codepoints on the ACK of the\n      SYN/ACK, 6 unused values on the first SYN=0 data packet from the\n      Client and 7 unused values on the first SYN=0 data packet from the\n      Server could be used to declare future variants of the AccECN\n      protocol.  The word 'declare' is used rather than 'negotiate'\n      because, at this late stage in the three-way handshake, it would\n      be too late for a negotiation between the endpoints to be\n      completed.  A similar requirement not to reject unexpected initial\n      values in AccECN TCP Options (Section 3.2.3.2.4) is for the same\n      purpose.  If traversal of AccECN TCP Options were reliable, this\n      would have enabled a far wider range of future variation of the\n      whole AccECN protocol.  Nonetheless, it could be used to reliably\n      negotiate a wide range of variation in the semantics of the AccECN\n      Option.\n\n   Future non-AccECN variants:  Five codepoints out of the 8 possible in\n      the 3 TCP header flags used by AccECN are unused on the initial\n      SYN (in the order (AE,CWR,ECE)): (0,0,1), (0,1,0), (1,0,0),\n      (1,0,1), (1,1,0).  Section 3.1.3 ensures that the installed base\n      of AccECN Servers will all assume these are equivalent to AccECN\n      negotiation with (1,1,1) on the SYN.  These codepoints would not\n      allow fall-back to Classic ECN support for a Server that did not\n      understand them, but this approach ensures they are available in\n      future, perhaps for uses other than ECN alongside the AccECN\n      scheme.  All possible combinations of SYN/ACK could be used in\n      response except either (0,0,0) or reflection of the same values\n      sent on the SYN.\n\n      In order to extend AccECN or ECN in future, other ways could be\n      resorted to, although their traversal properties are likely to be\n      inferior.  They include a new TCP option; using the remaining\n      reserved flags in the main TCP header (preferably extending the\n      3-bit combinations used by AccECN to 4-bit combinations, rather \n      than burning one bit for just one state); a non-zero urgent\n      pointer in combination with the URG flag cleared; or some other\n      unexpected combination of fields yet to be invented.\n",
            "children": {},
            "decomposed_content": [
              {
                "text": "   Despite availability of usable TCP header space being extremely\n   scarce, the AccECN protocol has taken all possible steps to ensure\n   that there is space to negotiate possible future variants of the\n   protocol, either if a variant of AccECN is required, or if a\n   completely different ECN feedback approach is needed:",
                "references": [],
                "external_references": []
              },
              {
                "text": "   Future AccECN variants:  When the AccECN capability is negotiated\n      during TCP's three-way handshake, the rows in Table 2 tagged as\n      'Nonce' and 'Broken' in the column for the capability of node B\n      are unused by any current protocol in the RFC series.  These could\n      be used by TCP Servers in future to indicate a variant of the \n      AccECN protocol.  In recent measurement studies in which the\n      response of large numbers of Servers to an AccECN SYN has been\n      tested, e.g., [Mandalari18], a very small number of SYN/ACKs\n      arrive with the pattern tagged as 'Nonce', and a small but more\n      significant number arrive with the pattern tagged as 'Broken'.\n      The 'Nonce' pattern could be a sign that a few Servers have\n      implemented the ECN Nonce [RFC3540], which has now been\n      reclassified as historic [RFC8311], or it could be the random\n      result of some unknown middlebox behaviour.  The greater\n      prevalence of the 'Broken' pattern suggests that some instances\n      still exist of the broken code that reflects the reserved flags on\n      the SYN.",
                "references": [
                  {
                    "rfc_number": "RFC3540",
                    "section_id": "6.2"
                  },
                  {
                    "rfc_number": "RFC8311",
                    "section_id": "9"
                  }
                ],
                "external_references": [
                  {
                    "tag": "Mandalari18",
                    "reference_type": "TEXT",
                    "reference_value": "Measuring ECN++"
                  }
                ]
              },
              {
                "text": "      The requirement not to reject unexpected initial values of the ACE\n      counter (in the main TCP header) in the last paragraph of Section 3.2.2.4 ensures that 3 unused codepoints on the ACK of the\n      SYN/ACK, 6 unused values on the first SYN=0 data packet from the\n      Client and 7 unused values on the first SYN=0 data packet from the\n      Server could be used to declare future variants of the AccECN\n      protocol.  The word 'declare' is used rather than 'negotiate'\n      because, at this late stage in the three-way handshake, it would\n      be too late for a negotiation between the endpoints to be\n      completed.  A similar requirement not to reject unexpected initial\n      values in AccECN TCP Options (Section 3.2.3.2.4) is for the same\n      purpose.  If traversal of AccECN TCP Options were reliable, this\n      would have enabled a far wider range of future variation of the\n      whole AccECN protocol.  Nonetheless, it could be used to reliably\n      negotiate a wide range of variation in the semantics of the AccECN\n      Option.",
                "references": [
                  {
                    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
                    "section_id": "3.2.2.4"
                  },
                  {
                    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
                    "section_id": "3.2.3.2.4"
                  }
                ],
                "external_references": []
              },
              {
                "text": "   Future non-AccECN variants:  Five codepoints out of the 8 possible in\n      the 3 TCP header flags used by AccECN are unused on the initial\n      SYN (in the order (AE,CWR,ECE)): (0,0,1), (0,1,0), (1,0,0),\n      (1,0,1), (1,1,0).  Section 3.1.3 ensures that the installed base\n      of AccECN Servers will all assume these are equivalent to AccECN\n      negotiation with (1,1,1) on the SYN.  These codepoints would not\n      allow fall-back to Classic ECN support for a Server that did not\n      understand them, but this approach ensures they are available in\n      future, perhaps for uses other than ECN alongside the AccECN\n      scheme.  All possible combinations of SYN/ACK could be used in\n      response except either (0,0,0) or reflection of the same values\n      sent on the SYN.",
                "references": [
                  {
                    "rfc_number": "draft-ietf-tcpm-accurate-ecn-34",
                    "section_id": "3.1.3"
                  }
                ],
                "external_references": []
              },
              {
                "text": "      In order to extend AccECN or ECN in future, other ways could be\n      resorted to, although their traversal properties are likely to be\n      inferior.  They include a new TCP option; using the remaining\n      reserved flags in the main TCP header (preferably extending the\n      3-bit combinations used by AccECN to 4-bit combinations, rather \n      than burning one bit for just one state); a non-zero urgent\n      pointer in combination with the URG flag cleared; or some other\n      unexpected combination of fields yet to be invented.\n",
                "references": [],
                "external_references": []
              }
            ]
          }
        },
        "decomposed_content": []
      }
    }
  }
]