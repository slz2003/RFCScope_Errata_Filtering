================================================================================
SYSTEM PROMPT
================================================================================

You are ErrataPacketizer.
Input: an analyzer output containing router analysis and multiple expert analyses.
Task: produce deduplicated errata reports as structured JSON.

Constraints:
- Read the ENTIRE analysis carefully from start to finish. Do not skip any sections.
- Extract ALL issues mentioned anywhere in the analysis, including:
  * candidate issues (even if marked as "candidate" or "potential")
  * Expert-identified issues (even if experts conclude "no issue" or "editorial only")
  * Issues discussed in expert reasoning sections, even if not in formal issue lists
  * Any inconsistencies, ambiguities, or problems mentioned in any part of the text
  * Issues labeled as "potential", "candidate", "may cause", "underspecification", or similar
- Only use information present in the input text.
- Labels must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (include specific terms, values, or section references when relevant).
- Evidence snippets (5a) must be copied verbatim from the input text (without quotes). Snippets must be complete and sufficient - include all relevant context needed to understand and verify the issue. Do not use partial snippets.
- Evidence summary (5b) must be derived ONLY from the evidence snippets E1..En and must cite (E#) per bullet.
- Deduplicate: merge issues that refer to the same underlying erratum and list all experts.
- Severity/Confidence: prefer explicit expert values; otherwise infer conservatively and state "inferred".

================================================================================
USER PROMPT
================================================================================

Read the ENTIRE analyzer output below carefully from start to finish. Extract ALL issues, problems, inconsistencies, or ambiguities mentioned anywhere in the text.

Include ALL issues mentioned in the analysis:
- Router candidate issues (even if marked "candidate" or "potential")
- Expert-identified issues (check all expert sections: Scope, Causal, Quantitative, Structural, CrossRFC, Terminology, etc.)
- Issues discussed in expert reasoning/analysis sections, even if not in formal issue lists
- Any inconsistencies, ambiguities, underspecifications, or problems mentioned anywhere
- Issues labeled as "potential", "candidate", "may cause", "editorial", "underspecification", or similar
- Do NOT skip issues just because an expert concludes "no issue" or "editorial only" - if it's discussed, include it

Produce deduplicated errata reports as JSON.

Each errata report MUST contain exactly these fields:
1) label: Errata short Label (must be explicit and descriptive - readers should understand the problem at a glance, e.g., "Misnamed LDAP/X.509 CA certificate attribute ("caCertificate" vs "cACertificate")")
2) bug_type: Bug Type
3) explanation: Concise Explanation (1-2 sentences, neutral)
4) justification: Justification (array of bullets, must be supported by Evidence snippets)
5) evidence: Object with:
   - snippets: Array of {id: "E1", text: "..."} (verbatim, complete and sufficient excerpts, no quotes around text)
   - summary: Array of strings, each citing (E1), (E2), etc.
6) fix_direction: Fix Direction if exists, else null
7) severity: Low | Medium | High | Unspecified
8) severity_basis: Basis for severity
9) confidence: High | Medium | Low | Unspecified
10) experts: Array of "ExpertName: issue_id" strings

Constraints:
- Label must be explicit and descriptive - clearly state what the problem is so readers understand it at a glance (e.g., include specific terms, section references, or conflicting values when relevant).
- Evidence snippets must be verbatim from input (format: text directly, no quotes).
- Evidence snippets must be complete and sufficient - include all relevant context needed to understand the issue.
- Evidence summary must cite (E1), (E2), ... and contain no new facts beyond snippets.
- Keep each errata report concise.

Analyzer output:
<<<
REASONING EXPERT ANALYSES
================================================================================

## Temporal Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
TemporalAnalysis:
  HighLevelSummary: Section 2 informally sketches when Application Data can be sent, while Section 4.4.4 gives the formal gating condition in terms of Finished messages plus explicit exceptions. The two sections are logically compatible given the mandated handshake message ordering, but the overview text in Section 2 is weaker and could be misread as a complete normative rule. This creates a modest risk of misinterpretation about when a client is allowed to start sending 1‑RTT application data.
  OverallTemporalRisk: Low
  CandidateIssues:
    - Id: T1
      Type: Underspecification
      ShortLabel: "When may endpoints start sending Application Data (Section 2 vs 4.4.4)?"
      Description: |
        Section 2 states that “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3” and then notes that the server may send data before receiving the client's authentication messages. Read in isolation, this sentence looks like the only normative precondition for sending non‑0‑RTT Application Data is “have sent your own Finished”. Section 4.4.4, however, gives the formal rule: an endpoint may start sending and receiving Application Data only after it has both sent its Finished and received/validated the peer’s Finished, with precisely two exceptions (client 0‑RTT, and server data after its first flight). Because message ordering elsewhere in the spec forces the client to receive the server's Finished before it can send its own, there is no actual executable conflict, but Section 2’s wording is weaker and could be misinterpreted as sufficient rather than merely necessary. A brief cross‑reference or tightening of the wording in Section 2 would reduce this temporal ambiguity.
      TemporalReasoning: |
        1. Section 2 describes the basic full handshake. After listing the server’s Authentication messages ending in its Finished, it says the client responds with its Certificate/CertificateVerify (if any) and Finished. It then states:

           - “At this point, the handshake is complete, and the client and server derive the keying material required by the record layer to exchange application-layer data protected through authenticated encryption. Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.”  

           This gives one normative temporal constraint: before you have sent your Finished, you must not send Application Data, unless you are using 0‑RTT (Section 2.3).
        2. Section 4.4.4 later provides the formal rule:

           - “Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: (1) Clients sending 0‑RTT data as described in Section 4.2.10. (2) Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness.”

           This adds an extra temporal precondition beyond Section 2: you must also have received and validated the peer’s Finished, unless you are in one of the two enumerated exception cases.
        3. Given the mandated handshake order (Section 4.4.1: “Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an 'unexpected_message' alert.”), the client always receives the server’s Finished before it is even allowed to send its own Finished in a normal 1‑RTT handshake (see Figure 1 and the client state machine in Appendix A.1). So any conformant client that obeys the message ordering rules and “MUST NOT send Application Data prior to sending Finished” will, in practice, also satisfy “have received the peer’s Finished” before sending 1‑RTT Application Data.
        4. For the server, the situation is explicitly carved out: the server sends its first flight containing its own Finished, then MAY send Application Data before receiving the client's Authentication messages and Finished, which matches both Section 2’s note (“server may send Application Data prior to receiving the client's Authentication messages”) and the exception (2) in Section 4.4.4. It still satisfies Section 2’s “MUST NOT be sent prior to sending the Finished message”, because such data is after the server’s own Finished.
        5. Thus, there is no literal temporal contradiction between the two sections: Section 2 provides a necessary condition (“not before sending your Finished”), and Section 4.4.4 adds an additional necessary condition (“and, except for the two stated cases, not before receiving the peer’s Finished”). The mandated handshake ordering ensures that clients will in fact have received the peer’s Finished before sending their own Finished in all the legal flows (full handshake, PSK/resumption, 0‑RTT).
        6. However, because Section 2 is an “Overview” section that nonetheless uses RFC 2119 “MUST NOT” language, an implementer skimming it might treat “MUST NOT be sent prior to sending the Finished message” as both necessary and sufficient, and not notice that later text requires having validated the peer’s Finished as well. For clients, that misreading would conceptually allow an implementation to start 1‑RTT Application Data immediately after sending its Finished, even if (hypothetically, in a non‑conformant implementation) it has not yet processed the server’s Finished. That would violate Section 4.4.4, but the tension only becomes apparent when the two sections are read together.
        7. Additionally, Section 2’s phrase “At this point, the handshake is complete” (right after describing the client sending its Finished) can be read as defining handshake completion earlier than Section 4.4.4 implies (which implicitly treats the handshake as “complete” only once both sides’ Finished messages have been sent and validated). This is another small place where temporal terminology (“handshake is complete”) is used more loosely in Section 2 than in the formal sections, and could be tightened for consistency.
      KeyEvidence:
        ExcerptPoints:
          - Section 2, after describing the client’s Authentication messages: “At this point, the handshake is complete, and the client and server derive the keying material required by the record layer to exchange application-layer data... Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.”
          - Section 4.4.4 (Finished): “Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0‑RTT data as described in Section 4.2.10. 2. Servers MAY send data after sending their first flight...”
          - Section 4.4.1 (Transcript Hash / handshake ordering): “Protocol messages MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2. A peer which receives a handshake message in an unexpected order MUST abort the handshake with an 'unexpected_message' alert.”
          - Appendix A.1 / A.2 client and server state machines showing that the client receives the server’s Finished before it sends its own Finished, and the server may send application data while still in WAIT_FLIGHT2 (i.e., after its own Finished but before receiving the client’s Finished).
        ContextPoints:
          - None beyond the excerpt itself; this behavior matches the established RFC 8446 text.
      ImpactOnImplementations: |
        A fully compliant implementation that follows the detailed handshake rules in Section 4.x and the state machines in Appendix A will naturally send 1‑RTT Application Data only after both sides’ Finished messages are sent and the peer’s Finished has been validated, with the two explicit exceptions (client 0‑RTT and early server data). So interoperability should not be harmed. The risk is mainly one of clarity: an implementer who reads and implements only from Section 2 might not realize that “have sent our Finished” is not, by itself, sufficient for starting 1‑RTT application data on the client side, and might conceptually or in edge‑case code paths violate the stricter rule of Section 4.4.4. Adding a short pointer in Section 2 (“see Section 4.4.4 for the precise conditions under which application data may be sent”) or tightening its wording to reflect the “sent and received Finished” condition would reduce this ambiguity.
      AffectedArtifacts:
        - "Section 2, paragraph beginning 'At this point, the handshake is complete... Application Data MUST NOT be sent prior to sending the Finished message...'"
        - "Section 4.4.4, first two paragraphs describing when Application Data may be sent"
      Severity: Low

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## ActorDirectionality Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
ActorDirectionalityReport:
- ExcerptSummary: The excerpt describes the TLS 1.3 handshake and variants (full handshake, HelloRetryRequest, PSK resumption, and 0‑RTT), detailing which side (client or server) sends which handshake, alert, and extension messages, how encryption keys are derived and applied, and how extensions are negotiated in specific directions (request vs response).
- OverallAssessment: NoBug

- FindingsOnRoutedIssues:
  # No routed IssueIds were provided in the prompt, so no router-specified hypotheses to evaluate.
  []

- AdditionalActorIssues:
  # After scanning the handshake diagrams, prose descriptions, extension rules, and state machines with a focus on who sends what, in which direction, and under which conditions, no actor/direction/role problems were identified.

- IfNoActorIssues:
  Comment: "No actor/direction/role problems detected in this excerpt. Roles (client vs server, sender vs receiver), message directions (who sends which handshake and which extensions), and origin/echo responsibilities for fields (e.g., cookies, PSK identities, key_share, early_data, Certificate/CertificateVerify/Finished, NewSessionTicket, KeyUpdate, EndOfEarlyData) are all consistently assigned and match the diagrams and state-machine descriptions. The informal overview in Section 2 aligns with the normative behavior in Sections 4.x and A.x from an actor/direction perspective."

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## Scope Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
ScopeAnalysis:
- ExcerptSummary:  
  Section 2 gives an informal but partially normative overview of TLS 1.3 handshakes (full, HRR, PSK/resumption, and 0‑RTT), including when Application Data may be sent. Later sections (notably 4.2.11) give the formal rules for PSKs and their associated hash algorithms, key schedule, early data, and state machines.  
  The main scope issue is a normative conflict between the overview’s requirements on externally provisioned PSKs and the detailed PSK rules.

- ScopeModel:
  - Targets:
    - All TLS 1.3 handshakes (full (EC)DHE, PSK-only, PSK+(EC)DHE), including HRR and 0‑RTT, as summarized in Section 2 diagrams.
    - Use of externally provisioned PSKs vs resumption PSKs, especially their associated hash/KDF algorithms.
    - Rules governing when Application Data may be sent relative to Finished and early data.
  - Conditions:
    - External PSKs vs resumption PSKs (tickets) are treated differently for how their hash algorithm is defined.
    - Early data (0‑RTT) is only permitted when a PSK is in use and the “early_data” extension is negotiated; otherwise Application Data is forbidden before sending Finished.
    - The detailed PSK behavior is normatively defined in Section 4.2.11; Section 2.2 is intended as an overview but uses 2119 keywords.
  - NotedAmbiguities:
    - Section 2’s phrase “At this point, the handshake is complete, and the client and server derive the keying material…” informally ties key derivation to the client’s Finished, whereas Section 7.1 shows application traffic secrets can be derived earlier (after server Finished) and Section 4.4.4 ties *sending* data to Finished, not derivation. This seems descriptive rather than a hard rule but could mislead implementers about when keys may be computed.
    - Section 4.1’s statement that protocol messages “MUST be sent in the order defined in Section 4.4.1 and shown in the diagrams in Section 2” is naturally read as applying to the main handshake only, but the phrase “protocol messages” is broad while the diagrams omit post‑handshake messages (NewSessionTicket, KeyUpdate, post‑handshake auth). This is more of a wording breadth issue than a concrete behavioral contradiction.

- CandidateIssues:
  - Issue-1:
    - BugType: Inconsistency
    - ShortLabel: Conflicting requirements on hash/KDF algorithm provisioning for externally provisioned PSKs
    - ScopeProblemType: Over‑broad MUST in overview vs narrower rule with default; inconsistent scope of allowed external PSK configurations
    - Evidence:
      - Section 2.2 (Resumption and PSK):  
        “When PSKs are provisioned externally, the PSK identity and the KDF hash algorithm to be used with the PSK MUST also be provisioned.”  
      - Section 4.2.11 (Pre‑Shared Key Extension):  
        “Each PSK is associated with a single Hash algorithm. For PSKs established via the ticket mechanism (Section 4.6.1), this is the KDF Hash algorithm on the connection where the ticket was established. For externally established PSKs, the Hash algorithm MUST be set when the PSK is established or default to SHA‑256 if no such algorithm is defined.”
    - DetailedReasoning:
      1. Section 2.2 is part of the “Protocol Overview” but it uses BCP 14 language and clearly states that for *all* externally provisioned PSKs, both the PSK identity and the “KDF hash algorithm to be used with the PSK MUST also be provisioned.” That is, it normatively requires an explicit hash/KDF parameter at provisioning time for every external PSK.
      2. Section 4.2.11 gives the formal definition of how each PSK is associated with a hash algorithm. For resumption PSKs (from NewSessionTicket), the hash is determined by the original connection; for externally established PSKs, it says: “the Hash algorithm MUST be set when the PSK is established *or default to SHA‑256 if no such algorithm is defined*.”
      3. These two requirements conflict in scope. Section 2.2’s rule is unconditional: external PSKs without an explicitly provisioned “KDF hash algorithm” are forbidden. Section 4.2.11 explicitly defines and permits a second case where “no such algorithm is defined,” in which case SHA‑256 is implicitly used.
      4. Because both statements use “MUST” and apply to the same population (externally established PSKs), an implementation cannot satisfy them simultaneously. A stack that offers an API for external PSKs where the hash is optional and defaults to SHA‑256 is compliant with Section 4.2.11 but non‑compliant with Section 2.2. Conversely, insisting that callers always supply an explicit hash complies with Section 2.2 but makes the “or default to SHA‑256 if no such algorithm is defined” branch in 4.2.11 unreachable.
      5. This is not merely editorial: it changes the allowed configuration space for external PSKs. Under 4.2.11, an implementation that assumes “SHA‑256 if the application doesn’t specify anything” is explicitly allowed. Under 2.2, such a configuration would violate a MUST because the KDF hash was not “also provisioned.”
      6. Given that Section 1.2 explicitly lists “Removes ambiguity around which hash is used with PreSharedKeys and HelloRetryRequest” as a technical change of this bis revision, the detailed rules in 4.2.11 appear to be the intended normative behavior, and the overview text in 2.2 was likely not updated to match.
      7. From a scope perspective, the problem is that the overview’s MUST is written with global scope over all externally provisioned PSKs and does not acknowledge the later “default to SHA‑256” case, while the detailed section intentionally carves out that case. This produces an internal normative inconsistency about what external PSK configurations are allowed.
      8. A minimal repair would be to relax or clarify Section 2.2 so that its scope matches 4.2.11, for example by changing it to: “When PSKs are provisioned externally, the PSK identity and the (explicit or default) KDF hash algorithm to be used with the PSK MUST be known (see Section 4.2.11),” or by downgrading the requirement there to descriptive text and pointing to Section 4.2.11 for the normative rule.

- ResidualUncertainties:
  - The phrase in Section 2 that the handshake is “complete” immediately after the client sends its Finished could be read as a timing requirement on when keys are derived, whereas Sections 4.4.4 and 7.1 only constrain when Application Data may be *sent* and allow application traffic secrets to be derived earlier. This appears to be an imprecise overview rather than a true behavioral conflict, but if future text relies on that notion of “complete” handshake, clarifying its exact phase (e.g., “logically complete once both sides have sent and validated Finished”) might avoid confusion.

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## Causal Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
1. **Summary**

Following Section 2 literally does not produce any behavior that conflicts with the more detailed rules in Section 4.4.4. The apparent discrepancy disappears once you track the actual handshake message order; the conditions “must have sent Finished” and “must have sent Finished and received peer’s Finished” become equivalent for the client at the point when it could reasonably start sending 1‑RTT application data.

---

2. **Causal Analysis**

Let’s restate the two pieces of text:

- **Section 2 (overview):**

> “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.”

Mechanically, this says for either endpoint:

- You are not allowed to send Application Data until *you* have sent your Finished, except:
  - Client 0‑RTT (Section 2.3).
  - The note explicitly acknowledges the server sending app data before receiving the client’s auth, i.e., before server has received client’s Finished.

- **Section 4.4.4 (Finished):**

> “Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished:  
>  1. Clients sending 0‑RTT data …  
>  2. Servers MAY send data after sending their first flight, but … [before receiving the client’s Finished].”

So the *general* rule is:

- You may send/receive Application Data only after:
  - You have sent your own Finished, **and**
  - You have received and validated the peer’s Finished.

With **two explicit send‑side exceptions**:

1. Client 0‑RTT.
2. Server sending app data after its own Finished but before receiving client’s Finished.

Now check what actually happens in the TLS 1.3 state machine.

### 2.1 Client side: when does it see the server’s Finished?

In the ordinary 1‑RTT handshake (with or without client auth), the order on the wire is:

- Client: ClientHello
- Server: ServerHello, EncryptedExtensions, Certificate*, CertificateVerify*, Finished
- Client: Certificate*, CertificateVerify*, Finished

Thus:

- **The client receives and validates the server’s Finished *before* it sends its own Finished.**
- The client’s Finished MAC *itself* is computed over a transcript hash that includes the server’s Finished; so this ordering is unavoidable.

So, from the client’s perspective:

- Between **receiving server Finished** and **sending its own Finished**:
  - Condition “must have sent Finished” (Section 2) is **false** ⇒ client must not send app data.
  - Condition “must have sent Finished and received peer’s Finished” (Section 4.4.4) is **also false** (has not yet sent its own Finished) ⇒ client must not send app data.

- Immediately **after sending its own Finished**:
  - It **has already received+validated server Finished**.
  - It **has now sent its Finished**.
  - So the Section 4.4.4 condition is satisfied.
  - The Section 2 condition (“must have sent Finished”) is also satisfied.

Therefore, for the client:

- Earliest legal send‑time for 1‑RTT Application Data under Section 4.4.4 is **“just after sending client Finished”**.
- Section 2’s simpler condition (“must have sent Finished”) selects the **same earliest send‑time**, because the client necessarily has the peer’s Finished by that time.

So an implementer who only enforces “don’t send app data until you’ve sent Finished” (per Section 2) behaves identically to an implementer who enforces the stricter “sent Finished *and* received peer Finished” from Section 4.4.4, simply because of the mandated message order.

### 2.2 Server side

On the server we have:

- Server sends: EncryptedExtensions, Certificate*, CertificateVerify*, Finished (the “first flight”).
- Only afterwards does it receive the client’s Certificate*/CertificateVerify*/Finished.

Section 4.4.4 explicitly exempts servers from the “must have received peer’s Finished” condition:

> “Servers MAY send data after sending their first flight, but because the handshake is not yet complete, they have no assurance of either the peer's identity or its liveness…”

Combined with Section 2:

- Section 2 requires only that the server **has sent its own Finished** before sending Application Data; it explicitly notes that this can happen before receiving the client’s auth.
- That is precisely the same permission granted by the exception in Section 4.4.4.

So again, there is no conflict:

- Both sections agree: **server must not send app data before its own Finished**, but may send it immediately after its Finished and before receiving the client’s Finished.

### 2.3 Receiving vs. sending

Section 2’s normative text is about **sending** Application Data:

> “Application Data MUST NOT be sent prior to sending the Finished…”

Section 4.4.4 adds rules for when a side “may begin to send and receive Application Data”, and only provides explicit exceptions for **sending** prior to peer Finished (0‑RTT, or server after its first flight). The intended reading is:

- A client may have to decrypt/buffer app‑data records before its own Finished (because the server is allowed to send them), but it should *not* treat the connection as fully usable for application I/O until it has:
  - Received+validated the server’s Finished, and
  - Sent its own Finished.

Again, for the client that happens immediately after sending its Finished.

The state machines in Appendix A line up with this:

- Client: only after sending its Finished and updating `K_send = K_recv = application` does it enter CONNECTED with “Can send app data after here”.
- Server: can send app data once it has sent its Finished (even though it is still waiting for the client’s Finished).

So there is no unimplementable or contradictory path.

---

3. **Problem Classification**

- The hypothesized problem (“client might think it can send 1‑RTT app data after sending its Finished but before validating the server’s Finished”) cannot actually occur, because the client *must already have validated the server’s Finished* before it can calculate and send its own Finished.
- Section 2’s “MUST NOT be sent prior to sending the Finished message” is consistent with the more detailed rule in Section 4.4.4 once the real message order is taken into account.

Therefore:

- This is **not** a Causal Inconsistency and **not** a Causal Underspecification in the protocol behavior.
- At most, it is a stylistic / explanatory issue (Section 2 being an overview with slightly simplified wording).

---

4. **Minimal Fix Shape (Optional)**

If the editors want to reduce the chance of misreading Section 2 as a standalone normative definition, a minimal tweak would be:

- Add an explicit forward reference such as:
  - “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3 and further constrained by Section 4.4.4.”
- Or preface Section 2 with a short note that the *definitive* handshake rules are in Section 4, and Section 2 is an informal overview.

This would purely clarify, not change, behavior.

---

5. **Non-Issues**

- There is **no scenario** in the defined TLS 1.3 handshake where a compliant client has “sent its Finished but not yet received the server’s Finished”. The ordering makes that state impossible, so the extra condition in Section 4.4.4 does not further restrict the client beyond what Section 2 already says.
- The server’s ability to send app data before receiving the client’s auth is explicitly acknowledged in both sections and does not cause a conflict.

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## Deontic Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
DeonticAnalysis:
- ExcerptSummary: Section 2 gives an informal/narrative overview of the TLS 1.3 handshake, including a single BCP14 requirement about when application data may be sent. Later sections (notably 4.4.4) give the formal normative rules for when each side may send application data, including 0‑RTT and the server’s ability to send data before client authentication. The question is whether Section 2’s wording is normatively inconsistent with (or dangerously weaker than) Section 4.4.4.

- OverallDeonticRisk: None

- Issues:
  - Issue-1:
    - BugType: None
    - Title: Section 2 vs 4.4.4 on when application data may be sent – norms are consistent
    - Description:
      The key overview requirement in Section 2 is: “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3.” This is a one‑sided prohibition (a necessary condition), not an explicit grant of permission to send immediately afterward. It does not say, e.g., “MAY be sent as soon as Finished is sent,” so it does not by itself define the *earliest* legal send time in all cases; more detailed rules can further restrict behavior later in the document.
      
      Section 4.4.4 then provides the full normative rule: a side may send and receive application data once it has *both* sent its own Finished and received and validated the peer’s Finished, with two explicit exceptions: client 0‑RTT and servers sending data after sending their first flight (before receiving the client’s Finished). For the client in TLS 1.3, this is effectively equivalent to Section 2’s condition: by the time the client sends its own Finished, it has already received and validated the server’s Finished, so “after sending its Finished” and “after sending its Finished AND receiving/validating peer Finished” coincide in time. For the server, Section 2’s requirement (“not before sending its own Finished”) and Section 4.4.4’s explicit exception (“Servers MAY send data after sending their first flight…”) are also aligned: both permit server application data immediately after the server Finished, before the client’s Finished arrives.
      
      Importantly, the line “Note that while the server may send Application Data prior to receiving the client's Authentication messages…” in Section 2 uses lowercase “may” and is explicitly non‑normative per the document’s BCP14 conventions; the real normative permission for that behavior is in Section 4.4.4. Thus, there is no case where Section 2 *authorizes* behavior that Section 4.4.4 *forbids*. Section 2 provides an informal, high‑level necessary condition (“don’t send before your own Finished, except 0‑RTT”), while Section 4.4.4 gives the complete, more precise set of permissions and exceptions. Taken together, they form a coherent requirement set; there is no deontic inconsistency, only an overview vs. detailed layering that is typical in RFCs.
    - KeyTextSnippets:
      - “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is, of course, being sent to an unauthenticated peer.”
      - “Once a side has sent its Finished message and has received and validated the Finished message from its peer, it may begin to send and receive Application Data over the connection. There are two settings in which it is permitted to send data prior to receiving the peer's Finished: 1. Clients sending 0‑RTT data… 2. Servers MAY send data after sending their first flight…”
    - Impact:
      Because the apparent tension dissolves when the handshake message ordering is taken into account and Section 2 is read as a high‑level prohibition rather than a full timing spec, implementers who follow the detailed rules in Section 4.4.4 will behave consistently with Section 2. No interoperability or security issue arises from the current normative structure, so no spec change is strictly required; at most, an editorial note could clarify that Section 4.x defines the authoritative application‑data timing rules.

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## Structural Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
AnalysisSummary:
- ExcerptSummary: I compared the Section 2 handshake overview (Figures 1–4, prose around HelloRetryRequest, PSK/resumption, and 0‑RTT) against the formal handshake structures, key schedule, and state machines in Sections 4 and Appendix A, plus the TLS presentation language in Section 3 and related external RFC text.
- OverallBugLikelihood: None

Issues:
  - Issue-1:
    - BugType: None
    - ShortLabel: "No structural or syntactic inconsistencies between overview and formal definitions"
    - TechnicalExplanation: |
        I checked that each message-flow diagram in Section 2 (full handshake, HelloRetryRequest, PSK/resumption, and 0‑RTT) is structurally compatible with:
        - the HandshakeType enum and Handshake struct, including the special encoding of HelloRetryRequest as a ServerHello with a distinguished Random value;
        - the detailed rules for message ordering and presence/omission of Certificate / CertificateRequest / CertificateVerify / Finished in Sections 4.3–4.4;
        - the encryption domains (early-data keys, handshake-traffic keys, and application-traffic keys) as defined in Sections 4.4, 4.5, 5.2, and 7.1–7.3; and
        - the client and server state machines in Appendix A.
        In each diagram:
        - Messages that are shown as encrypted with handshake keys (`{...}`) or application keys (`[...]`) match the key-derivation stages and the normative text (e.g., server’s first flight including Finished is handshake-key protected; NewSessionTicket and post‑handshake flows are application-key protected; EndOfEarlyData is 0‑RTT–key protected).
        - Optional messages (marked with `*`) agree with the formal conditions under which they may or may not appear (e.g., CertificateRequest and client Certificate/CertificateVerify are correctly absent from PSK-only and 0‑RTT flows, consistent with the prohibition on certificate-based client auth in PSK handshakes unless extended by RFC 8773).
        - The sequencing in the diagrams (ClientHello → [optional HelloRetryRequest] → ServerHello → EncryptedExtensions → optional CertificateRequest/Certificate/CertificateVerify → Finished) matches both the normative ordering in Section 4.4.1 and the state transitions in Appendix A.
        The 2119 rule in Section 2 that Application Data “MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3” is also consistent with the stricter rules in Section 4.4.4: an implementation that waits for both sides’ Finished before sending or accepting application data (except for the explicitly carved-out 0‑RTT and “server after its first flight” cases) automatically satisfies the simpler overview constraint. No examples or diagrams contradict these ordering or encryption rules.

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]

## Boundary Expert
--------------------------------------------------------------------------------

### Expert Analysis:
--------------------------------------------------------------------------------
BoundaryAnalysis:
- ExcerptUnderstanding: Section 2 informally describes the TLS 1.3 handshake variants (full, HRR, PSK/resumption, 0‑RTT) and includes a small number of 2119 requirements, especially about when application data may be sent. The surrounding sections (4.x, A.x) give the formal definitions: exact message sequences, state machines, and precise rules for early data, HRR, and Finished/application‑data timing. The question is whether the overview’s normative text or diagrams introduce inconsistencies or underspecified behavior at boundary/exceptional cases relative to those formal sections.

- OverallBoundaryBugLikelihood: None

- Findings:
  - Finding-1:
    - BugType: None
    - ShortLabel: No boundary/exceptional-case bugs detected
    - BoundaryAxis: Application Data timing; HelloRetryRequest; 0‑RTT/PSK/resumption message flows
    - ExcerptEvidence:
      - Section 2 (full handshake) says: “Application Data MUST NOT be sent prior to sending the Finished message, except as specified in Section 2.3. Note that while the server may send Application Data prior to receiving the client's Authentication messages, any data sent at that point is… sent to an unauthenticated peer.”  
      - Section 4.4.4 clarifies: a side may begin sending Application Data once it has sent its own Finished and received/validated the peer’s Finished, with *two* exceptions: (1) client 0‑RTT and (2) a server MAY send data “after sending their first flight” (i.e., after its own Finished) even before receiving the client’s Finished.  
      - The server handshake state machine (Appendix A.2) explicitly labels that the server can “send app data after here” immediately after sending ServerHello/EncryptedExtensions/(CertificateRequest)/(Certificate)/(CertificateVerify)/Finished and before receiving the client’s Finished.  
      - Section 4.1.2 / 4.1.4 define the precise constraints on HelloRetryRequest, including that a second HRR is forbidden and what must change in the second ClientHello; Section 4.2.10 and 4.5 give the formal rules for 0‑RTT early_data / EndOfEarlyData, including HRR interaction and mandatory removal of the early_data extension in the second ClientHello.
    - Reasoning:
      - **Application Data timing:** Section 2’s normative text only forbids sending application data *before sending your own Finished* (except for 0‑RTT). It does not require waiting for the peer’s Finished. For servers, the allowed exceptional case in 4.4.4 (“MAY send data after sending their first flight”) still respects Section 2’s rule because the first flight includes the server’s Finished; thus the server is not sending application data before sending its own Finished. For clients, the general rule in 4.4.4 (send after sending *and* after receiving/validating the peer’s Finished) is automatically satisfied at the moment a client sends its Finished in a 1‑RTT handshake, because it sends its Finished only after receiving and validating the server’s Finished. There is therefore no state where Section 2 would permit application data but Section 4 would forbid it, nor vice versa.
      - **HRR behavior:** Section 2.1 and Figure 2 give a high‑level HRR flow, but all boundary conditions are normatively nailed down in 4.1.2 and 4.1.4: only one HRR per connection, the updated ClientHello must differ in specified ways (key_share, cookie, early_data removal, PSK binder recomputation), and cipher_suite and selected_version in HRR and final ServerHello must match. The overview does not add any contradictory normative condition about HRR; it simply says the server “corrects the mismatch with a HelloRetryRequest” and MUST abort only if no common parameters can be negotiated, which matches 4.1.1’s requirements.
      - **0‑RTT and PSK/resumption:** Section 2.2’s PSK/resumption diagram and Section 2.3’s 0‑RTT diagram are consistent with the detailed rules in 4.2.10 and 4.5. The overview text “0‑RTT data is just added to the 1‑RTT handshake in the first flight. The rest of the handshake uses the same messages as for a 1‑RTT handshake with PSK resumption” is clarified (but not contradicted) by Section 4.5, which adds the mandatory EndOfEarlyData message when early_data is accepted. The overview correctly states that early data is encrypted under a different traffic secret and notes that it is replayable and not forward‑secret; the precise conditions under which early data is allowed (PSK marked as permitting early data, early_data + pre_shared_key extensions, server parameter matching, HRR handling, max_early_data_size, etc.) are handled entirely in Section 4.2.10. There is no conflicting MUST in Section 2.
      - **Message ordering vs diagrams:** Section 4’s generic rule that handshake messages MUST be sent in the order of 4.4.1 “and shown in the diagrams in Section 2” is satisfied: the Section 2 diagrams for full, HRR, PSK, and 0‑RTT handshakes exactly match the formal sequences (ServerHello → EncryptedExtensions → optional CertificateRequest → optional Certificate → optional CertificateVerify → Finished; EndOfEarlyData only in the 0‑RTT flow where early_data is accepted). Optional messages are clearly marked and are consistent with the conditions described in Section 4.3 and 4.4.
    - ImpactAssessment: The overview in Section 2 and the formal rules in Sections 4 and A describe the same boundary behaviors for application‑data timing, HRR, and 0‑RTT. I do not see a reachable state where the overview’s normative language or diagrams would lead an implementer to a behavior that contradicts the detailed state machines or message‑ordering rules in a way that would cause interoperability or security problems.

- Notes:
  - Not a bug: Section 2.3 informally says that “the rest of the handshake uses the same messages as for a 1‑RTT handshake with PSK resumption,” even though in the 0‑RTT case there is an extra EndOfEarlyData message before the client’s Finished. Figure 4 and Section 4.5 make this explicit. This is a minor imprecision in the overview, but it is corrected by the later normative sections and should not cause divergent implementations.

[Used vector stores: vs_6958cda3dae081919bf20a5fc7c770d1]


Vector Stores Used: vs_6958cda3dae081919bf20a5fc7c770d1
>>>

Return JSON array of errata reports:
{
  "reports": [
    {
      "label": "...",
      "bug_type": "...",
      "explanation": "...",
      "justification": ["...", "..."],
      "evidence": {
        "snippets": [
          {"id": "E1", "text": "..."}
        ],
        "summary": ["(E1) ...", "(E2) ..."]
      },
      "fix_direction": "..." or null,
      "severity": "...",
      "severity_basis": "...",
      "confidence": "...",
      "experts": ["..."]
    }
  ]
}